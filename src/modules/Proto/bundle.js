/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
import * as $protobuf from 'protobufjs/minimal';
import Long from 'long';

$protobuf.util.Long = Long;
$protobuf.configure();

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});

export const proto = $root.proto = (() => {

  /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
  const proto = {};

  proto.ChannelAddAdmin = (function() {

    /**
         * Properties of a ChannelAddAdmin.
         * @memberof proto
         * @interface IChannelAddAdmin
         * @property {proto.Request|null} [request] ChannelAddAdmin request
         * @property {Long|null} [roomId] ChannelAddAdmin roomId
         * @property {Long|null} [memberId] ChannelAddAdmin memberId
         */

    /**
         * Constructs a new ChannelAddAdmin.
         * @memberof proto
         * @classdesc Represents a ChannelAddAdmin.
         * @implements IChannelAddAdmin
         * @constructor
         * @param {proto.IChannelAddAdmin=} [properties] Properties to set
         */
    function ChannelAddAdmin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddAdmin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAddAdmin
         * @instance
         */
    ChannelAddAdmin.prototype.request = null;

    /**
         * ChannelAddAdmin roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddAdmin
         * @instance
         */
    ChannelAddAdmin.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddAdmin memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelAddAdmin
         * @instance
         */
    ChannelAddAdmin.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAddAdmin instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddAdmin
         * @static
         * @param {proto.IChannelAddAdmin=} [properties] Properties to set
         * @returns {proto.ChannelAddAdmin} ChannelAddAdmin instance
         */
    ChannelAddAdmin.create = function create(properties) {
      return new ChannelAddAdmin(properties);
    };

    /**
         * Encodes the specified ChannelAddAdmin message. Does not implicitly {@link proto.ChannelAddAdmin.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddAdmin
         * @static
         * @param {proto.ChannelAddAdmin} message ChannelAddAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddAdmin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelAddAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddAdmin} ChannelAddAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddAdmin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddAdmin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddAdmin message.
         * @function verify
         * @memberof proto.ChannelAddAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddAdmin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAddAdmin;
  })();

  proto.ChannelAddAdminResponse = (function() {

    /**
         * Properties of a ChannelAddAdminResponse.
         * @memberof proto
         * @interface IChannelAddAdminResponse
         * @property {proto.Response|null} [response] ChannelAddAdminResponse response
         * @property {Long|null} [roomId] ChannelAddAdminResponse roomId
         * @property {Long|null} [memberId] ChannelAddAdminResponse memberId
         */

    /**
         * Constructs a new ChannelAddAdminResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAddAdminResponse.
         * @implements IChannelAddAdminResponse
         * @constructor
         * @param {proto.IChannelAddAdminResponse=} [properties] Properties to set
         */
    function ChannelAddAdminResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddAdminResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAddAdminResponse
         * @instance
         */
    ChannelAddAdminResponse.prototype.response = null;

    /**
         * ChannelAddAdminResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddAdminResponse
         * @instance
         */
    ChannelAddAdminResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddAdminResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelAddAdminResponse
         * @instance
         */
    ChannelAddAdminResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAddAdminResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddAdminResponse
         * @static
         * @param {proto.IChannelAddAdminResponse=} [properties] Properties to set
         * @returns {proto.ChannelAddAdminResponse} ChannelAddAdminResponse instance
         */
    ChannelAddAdminResponse.create = function create(properties) {
      return new ChannelAddAdminResponse(properties);
    };

    /**
         * Encodes the specified ChannelAddAdminResponse message. Does not implicitly {@link proto.ChannelAddAdminResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddAdminResponse
         * @static
         * @param {proto.ChannelAddAdminResponse} message ChannelAddAdminResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddAdminResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelAddAdminResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddAdminResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddAdminResponse} ChannelAddAdminResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddAdminResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddAdminResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddAdminResponse message.
         * @function verify
         * @memberof proto.ChannelAddAdminResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddAdminResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAddAdminResponse;
  })();

  proto.Request = (function() {

    /**
         * Properties of a Request.
         * @memberof proto
         * @interface IRequest
         * @property {string|null} [id] Request id
         */

    /**
         * Constructs a new Request.
         * @memberof proto
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {proto.IRequest=} [properties] Properties to set
         */
    function Request(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Request id.
         * @member {string} id
         * @memberof proto.Request
         * @instance
         */
    Request.prototype.id = '';

    /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof proto.Request
         * @static
         * @param {proto.IRequest=} [properties] Properties to set
         * @returns {proto.Request} Request instance
         */
    Request.create = function create(properties) {
      return new Request(properties);
    };

    /**
         * Encodes the specified Request message. Does not implicitly {@link proto.Request.verify|verify} messages.
         * @function encode
         * @memberof proto.Request
         * @static
         * @param {proto.Request} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Request.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);}
      return writer;
    };

    /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Request.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Request();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Request message.
         * @function verify
         * @memberof proto.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Request.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isString(message.id)) {return 'id: string expected';}
      }
      return null;
    };

    return Request;
  })();

  proto.Response = (function() {

    /**
         * Properties of a Response.
         * @memberof proto
         * @interface IResponse
         * @property {string|null} [id] Response id
         * @property {number|null} [timestamp] Response timestamp
         */

    /**
         * Constructs a new Response.
         * @memberof proto
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {proto.IResponse=} [properties] Properties to set
         */
    function Response(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Response id.
         * @member {string} id
         * @memberof proto.Response
         * @instance
         */
    Response.prototype.id = '';

    /**
         * Response timestamp.
         * @member {number} timestamp
         * @memberof proto.Response
         * @instance
         */
    Response.prototype.timestamp = 0;

    /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse=} [properties] Properties to set
         * @returns {proto.Response} Response instance
         */
    Response.create = function create(properties) {
      return new Response(properties);
    };

    /**
         * Encodes the specified Response message. Does not implicitly {@link proto.Response.verify|verify} messages.
         * @function encode
         * @memberof proto.Response
         * @static
         * @param {proto.Response} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Response.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);}
      if (message.timestamp != null && message.hasOwnProperty('timestamp')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp);}
      return writer;
    };

    /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Response.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Response();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader.string();
            break;
          case 2:
            message.timestamp = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Response message.
         * @function verify
         * @memberof proto.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Response.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isString(message.id)) {return 'id: string expected';}
      }
      if (message.timestamp != null && message.hasOwnProperty('timestamp')) {
        if (!$util.isInteger(message.timestamp)) {return 'timestamp: integer expected';}
      }
      return null;
    };

    return Response;
  })();

  proto.ChannelAddMember = (function() {

    /**
         * Properties of a ChannelAddMember.
         * @memberof proto
         * @interface IChannelAddMember
         * @property {proto.Request|null} [request] ChannelAddMember request
         * @property {Long|null} [roomId] ChannelAddMember roomId
         * @property {proto.ChannelAddMember.Member|null} [member] ChannelAddMember member
         */

    /**
         * Constructs a new ChannelAddMember.
         * @memberof proto
         * @classdesc Represents a ChannelAddMember.
         * @implements IChannelAddMember
         * @constructor
         * @param {proto.IChannelAddMember=} [properties] Properties to set
         */
    function ChannelAddMember(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddMember request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAddMember
         * @instance
         */
    ChannelAddMember.prototype.request = null;

    /**
         * ChannelAddMember roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddMember
         * @instance
         */
    ChannelAddMember.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddMember member.
         * @member {proto.ChannelAddMember.Member|null|undefined} member
         * @memberof proto.ChannelAddMember
         * @instance
         */
    ChannelAddMember.prototype.member = null;

    /**
         * Creates a new ChannelAddMember instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddMember
         * @static
         * @param {proto.IChannelAddMember=} [properties] Properties to set
         * @returns {proto.ChannelAddMember} ChannelAddMember instance
         */
    ChannelAddMember.create = function create(properties) {
      return new ChannelAddMember(properties);
    };

    /**
         * Encodes the specified ChannelAddMember message. Does not implicitly {@link proto.ChannelAddMember.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddMember
         * @static
         * @param {proto.ChannelAddMember} message ChannelAddMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddMember.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.member != null && message.hasOwnProperty('member')) {$root.proto.ChannelAddMember.Member.encode(message.member, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelAddMember message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddMember} ChannelAddMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddMember.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddMember();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.member = $root.proto.ChannelAddMember.Member.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddMember message.
         * @function verify
         * @memberof proto.ChannelAddMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddMember.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.member != null && message.hasOwnProperty('member')) {
        let error = $root.proto.ChannelAddMember.Member.verify(message.member);
        if (error) {return 'member.' + error;}
      }
      return null;
    };

    ChannelAddMember.Member = (function() {

      /**
             * Properties of a Member.
             * @memberof proto.ChannelAddMember
             * @interface IMember
             * @property {Long|null} [userId] Member userId
             */

      /**
             * Constructs a new Member.
             * @memberof proto.ChannelAddMember
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {proto.ChannelAddMember.IMember=} [properties] Properties to set
             */
      function Member(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Member userId.
             * @member {Long} userId
             * @memberof proto.ChannelAddMember.Member
             * @instance
             */
      Member.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof proto.ChannelAddMember.Member
             * @static
             * @param {proto.ChannelAddMember.IMember=} [properties] Properties to set
             * @returns {proto.ChannelAddMember.Member} Member instance
             */
      Member.create = function create(properties) {
        return new Member(properties);
      };

      /**
             * Encodes the specified Member message. Does not implicitly {@link proto.ChannelAddMember.Member.verify|verify} messages.
             * @function encode
             * @memberof proto.ChannelAddMember.Member
             * @static
             * @param {proto.ChannelAddMember.Member} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Member.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        return writer;
      };

      /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ChannelAddMember.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ChannelAddMember.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Member.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddMember.Member();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Member message.
             * @function verify
             * @memberof proto.ChannelAddMember.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Member.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        return null;
      };

      return Member;
    })();

    return ChannelAddMember;
  })();

  proto.ChannelAddMemberResponse = (function() {

    /**
         * Properties of a ChannelAddMemberResponse.
         * @memberof proto
         * @interface IChannelAddMemberResponse
         * @property {proto.Response|null} [response] ChannelAddMemberResponse response
         * @property {Long|null} [roomId] ChannelAddMemberResponse roomId
         * @property {Long|null} [userId] ChannelAddMemberResponse userId
         * @property {proto.ChannelRoom.Role|null} [role] ChannelAddMemberResponse role
         */

    /**
         * Constructs a new ChannelAddMemberResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAddMemberResponse.
         * @implements IChannelAddMemberResponse
         * @constructor
         * @param {proto.IChannelAddMemberResponse=} [properties] Properties to set
         */
    function ChannelAddMemberResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddMemberResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAddMemberResponse
         * @instance
         */
    ChannelAddMemberResponse.prototype.response = null;

    /**
         * ChannelAddMemberResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddMemberResponse
         * @instance
         */
    ChannelAddMemberResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddMemberResponse userId.
         * @member {Long} userId
         * @memberof proto.ChannelAddMemberResponse
         * @instance
         */
    ChannelAddMemberResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddMemberResponse role.
         * @member {proto.ChannelRoom.Role} role
         * @memberof proto.ChannelAddMemberResponse
         * @instance
         */
    ChannelAddMemberResponse.prototype.role = 0;

    /**
         * Creates a new ChannelAddMemberResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddMemberResponse
         * @static
         * @param {proto.IChannelAddMemberResponse=} [properties] Properties to set
         * @returns {proto.ChannelAddMemberResponse} ChannelAddMemberResponse instance
         */
    ChannelAddMemberResponse.create = function create(properties) {
      return new ChannelAddMemberResponse(properties);
    };

    /**
         * Encodes the specified ChannelAddMemberResponse message. Does not implicitly {@link proto.ChannelAddMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddMemberResponse
         * @static
         * @param {proto.ChannelAddMemberResponse} message ChannelAddMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddMemberResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.role);}
      return writer;
    };

    /**
         * Decodes a ChannelAddMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddMemberResponse} ChannelAddMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddMemberResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddMemberResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          case 4:
            message.role = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddMemberResponse message.
         * @function verify
         * @memberof proto.ChannelAddMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddMemberResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.role != null && message.hasOwnProperty('role')) {
        switch (message.role) {
          default:
            return 'role: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    return ChannelAddMemberResponse;
  })();

  /**
     * Gender enum.
     * @name proto.Gender
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} MALE=1 MALE value
     * @property {number} FEMALE=2 FEMALE value
     */
  proto.Gender = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'UNKNOWN'] = 0;
    values[valuesById[1] = 'MALE'] = 1;
    values[valuesById[2] = 'FEMALE'] = 2;
    return values;
  })();

  /**
     * Device enum.
     * @name proto.Device
     * @enum {string}
     * @property {number} UNKNOWN_DEVICE=0 UNKNOWN_DEVICE value
     * @property {number} PC=1 PC value
     * @property {number} TABLET=2 TABLET value
     * @property {number} MOBILE=3 MOBILE value
     */
  proto.Device = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'UNKNOWN_DEVICE'] = 0;
    values[valuesById[1] = 'PC'] = 1;
    values[valuesById[2] = 'TABLET'] = 2;
    values[valuesById[3] = 'MOBILE'] = 3;
    return values;
  })();

  /**
     * Platform enum.
     * @name proto.Platform
     * @enum {string}
     * @property {number} UNKNOWN_PLATFORM=0 UNKNOWN_PLATFORM value
     * @property {number} ANDROID=1 ANDROID value
     * @property {number} IOS=2 IOS value
     * @property {number} MAC_OS=3 MAC_OS value
     * @property {number} WINDOWS=4 WINDOWS value
     * @property {number} LINUX=5 LINUX value
     * @property {number} BLACK_BERRY=6 BLACK_BERRY value
     */
  proto.Platform = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'UNKNOWN_PLATFORM'] = 0;
    values[valuesById[1] = 'ANDROID'] = 1;
    values[valuesById[2] = 'IOS'] = 2;
    values[valuesById[3] = 'MAC_OS'] = 3;
    values[valuesById[4] = 'WINDOWS'] = 4;
    values[valuesById[5] = 'LINUX'] = 5;
    values[valuesById[6] = 'BLACK_BERRY'] = 6;
    return values;
  })();

  /**
     * Language enum.
     * @name proto.Language
     * @enum {string}
     * @property {number} EN_US=0 EN_US value
     * @property {number} FA_IR=1 FA_IR value
     */
  proto.Language = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'EN_US'] = 0;
    values[valuesById[1] = 'FA_IR'] = 1;
    return values;
  })();

  /**
     * RoomMessageType enum.
     * @name proto.RoomMessageType
     * @enum {string}
     * @property {number} TEXT=0 TEXT value
     * @property {number} IMAGE=1 IMAGE value
     * @property {number} IMAGE_TEXT=2 IMAGE_TEXT value
     * @property {number} VIDEO=3 VIDEO value
     * @property {number} VIDEO_TEXT=4 VIDEO_TEXT value
     * @property {number} AUDIO=5 AUDIO value
     * @property {number} AUDIO_TEXT=6 AUDIO_TEXT value
     * @property {number} VOICE=7 VOICE value
     * @property {number} GIF=8 GIF value
     * @property {number} GIF_TEXT=14 GIF_TEXT value
     * @property {number} FILE=9 FILE value
     * @property {number} FILE_TEXT=10 FILE_TEXT value
     * @property {number} LOCATION=11 LOCATION value
     * @property {number} LOG=12 LOG value
     * @property {number} CONTACT=13 CONTACT value
     */
  proto.RoomMessageType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'TEXT'] = 0;
    values[valuesById[1] = 'IMAGE'] = 1;
    values[valuesById[2] = 'IMAGE_TEXT'] = 2;
    values[valuesById[3] = 'VIDEO'] = 3;
    values[valuesById[4] = 'VIDEO_TEXT'] = 4;
    values[valuesById[5] = 'AUDIO'] = 5;
    values[valuesById[6] = 'AUDIO_TEXT'] = 6;
    values[valuesById[7] = 'VOICE'] = 7;
    values[valuesById[8] = 'GIF'] = 8;
    values[valuesById[14] = 'GIF_TEXT'] = 14;
    values[valuesById[9] = 'FILE'] = 9;
    values[valuesById[10] = 'FILE_TEXT'] = 10;
    values[valuesById[11] = 'LOCATION'] = 11;
    values[valuesById[12] = 'LOG'] = 12;
    values[valuesById[13] = 'CONTACT'] = 13;
    return values;
  })();

  /**
     * RoomMessageStatus enum.
     * @name proto.RoomMessageStatus
     * @enum {string}
     * @property {number} FAILED=0 FAILED value
     * @property {number} SENDING=1 SENDING value
     * @property {number} SENT=2 SENT value
     * @property {number} DELIVERED=3 DELIVERED value
     * @property {number} SEEN=4 SEEN value
     * @property {number} LISTENED=5 LISTENED value
     */
  proto.RoomMessageStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'FAILED'] = 0;
    values[valuesById[1] = 'SENDING'] = 1;
    values[valuesById[2] = 'SENT'] = 2;
    values[valuesById[3] = 'DELIVERED'] = 3;
    values[valuesById[4] = 'SEEN'] = 4;
    values[valuesById[5] = 'LISTENED'] = 5;
    return values;
  })();

  /**
     * RoomMessageReaction enum.
     * @name proto.RoomMessageReaction
     * @enum {string}
     * @property {number} THUMBS_UP=0 THUMBS_UP value
     * @property {number} THUMBS_DOWN=1 THUMBS_DOWN value
     */
  proto.RoomMessageReaction = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'THUMBS_UP'] = 0;
    values[valuesById[1] = 'THUMBS_DOWN'] = 1;
    return values;
  })();

  proto.RoomMessageLocation = (function() {

    /**
         * Properties of a RoomMessageLocation.
         * @memberof proto
         * @interface IRoomMessageLocation
         * @property {number|null} [lat] RoomMessageLocation lat
         * @property {number|null} [lon] RoomMessageLocation lon
         */

    /**
         * Constructs a new RoomMessageLocation.
         * @memberof proto
         * @classdesc Represents a RoomMessageLocation.
         * @implements IRoomMessageLocation
         * @constructor
         * @param {proto.IRoomMessageLocation=} [properties] Properties to set
         */
    function RoomMessageLocation(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomMessageLocation lat.
         * @member {number} lat
         * @memberof proto.RoomMessageLocation
         * @instance
         */
    RoomMessageLocation.prototype.lat = 0;

    /**
         * RoomMessageLocation lon.
         * @member {number} lon
         * @memberof proto.RoomMessageLocation
         * @instance
         */
    RoomMessageLocation.prototype.lon = 0;

    /**
         * Creates a new RoomMessageLocation instance using the specified properties.
         * @function create
         * @memberof proto.RoomMessageLocation
         * @static
         * @param {proto.IRoomMessageLocation=} [properties] Properties to set
         * @returns {proto.RoomMessageLocation} RoomMessageLocation instance
         */
    RoomMessageLocation.create = function create(properties) {
      return new RoomMessageLocation(properties);
    };

    /**
         * Encodes the specified RoomMessageLocation message. Does not implicitly {@link proto.RoomMessageLocation.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomMessageLocation
         * @static
         * @param {proto.RoomMessageLocation} message RoomMessageLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomMessageLocation.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.lat != null && message.hasOwnProperty('lat')) {writer.uint32(/* id 1, wireType 1 =*/9).double(message.lat);}
      if (message.lon != null && message.hasOwnProperty('lon')) {writer.uint32(/* id 2, wireType 1 =*/17).double(message.lon);}
      return writer;
    };

    /**
         * Decodes a RoomMessageLocation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomMessageLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomMessageLocation} RoomMessageLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomMessageLocation.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessageLocation();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.lat = reader.double();
            break;
          case 2:
            message.lon = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomMessageLocation message.
         * @function verify
         * @memberof proto.RoomMessageLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomMessageLocation.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.lat != null && message.hasOwnProperty('lat')) {
        if (typeof message.lat !== 'number') {return 'lat: number expected';}
      }
      if (message.lon != null && message.hasOwnProperty('lon')) {
        if (typeof message.lon !== 'number') {return 'lon: number expected';}
      }
      return null;
    };

    return RoomMessageLocation;
  })();

  proto.RoomMessageLog = (function() {

    /**
         * Properties of a RoomMessageLog.
         * @memberof proto
         * @interface IRoomMessageLog
         * @property {proto.RoomMessageLog.Type|null} [type] RoomMessageLog type
         * @property {proto.RoomMessageLog.ExtraType|null} [extraType] RoomMessageLog extraType
         * @property {proto.RoomMessageLog.TargetUser|null} [targetUser] RoomMessageLog targetUser
         */

    /**
         * Constructs a new RoomMessageLog.
         * @memberof proto
         * @classdesc Represents a RoomMessageLog.
         * @implements IRoomMessageLog
         * @constructor
         * @param {proto.IRoomMessageLog=} [properties] Properties to set
         */
    function RoomMessageLog(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomMessageLog type.
         * @member {proto.RoomMessageLog.Type} type
         * @memberof proto.RoomMessageLog
         * @instance
         */
    RoomMessageLog.prototype.type = 0;

    /**
         * RoomMessageLog extraType.
         * @member {proto.RoomMessageLog.ExtraType} extraType
         * @memberof proto.RoomMessageLog
         * @instance
         */
    RoomMessageLog.prototype.extraType = 0;

    /**
         * RoomMessageLog targetUser.
         * @member {proto.RoomMessageLog.TargetUser|null|undefined} targetUser
         * @memberof proto.RoomMessageLog
         * @instance
         */
    RoomMessageLog.prototype.targetUser = null;

    /**
         * Creates a new RoomMessageLog instance using the specified properties.
         * @function create
         * @memberof proto.RoomMessageLog
         * @static
         * @param {proto.IRoomMessageLog=} [properties] Properties to set
         * @returns {proto.RoomMessageLog} RoomMessageLog instance
         */
    RoomMessageLog.create = function create(properties) {
      return new RoomMessageLog(properties);
    };

    /**
         * Encodes the specified RoomMessageLog message. Does not implicitly {@link proto.RoomMessageLog.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomMessageLog
         * @static
         * @param {proto.RoomMessageLog} message RoomMessageLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomMessageLog.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);}
      if (message.extraType != null && message.hasOwnProperty('extraType')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.extraType);}
      if (message.targetUser != null && message.hasOwnProperty('targetUser')) {$root.proto.RoomMessageLog.TargetUser.encode(message.targetUser, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a RoomMessageLog message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomMessageLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomMessageLog} RoomMessageLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomMessageLog.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessageLog();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.type = reader.int32();
            break;
          case 2:
            message.extraType = reader.int32();
            break;
          case 3:
            message.targetUser = $root.proto.RoomMessageLog.TargetUser.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomMessageLog message.
         * @function verify
         * @memberof proto.RoomMessageLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomMessageLog.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.extraType != null && message.hasOwnProperty('extraType')) {
        switch (message.extraType) {
          default:
            return 'extraType: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.targetUser != null && message.hasOwnProperty('targetUser')) {
        let error = $root.proto.RoomMessageLog.TargetUser.verify(message.targetUser);
        if (error) {return 'targetUser.' + error;}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.RoomMessageLog.Type
         * @enum {string}
         * @property {number} USER_JOINED=0 USER_JOINED value
         * @property {number} USER_DELETED=1 USER_DELETED value
         * @property {number} ROOM_CREATED=2 ROOM_CREATED value
         * @property {number} MEMBER_ADDED=3 MEMBER_ADDED value
         * @property {number} MEMBER_KICKED=4 MEMBER_KICKED value
         * @property {number} MEMBER_LEFT=5 MEMBER_LEFT value
         * @property {number} ROOM_CONVERTED_TO_PUBLIC=6 ROOM_CONVERTED_TO_PUBLIC value
         * @property {number} ROOM_CONVERTED_TO_PRIVATE=7 ROOM_CONVERTED_TO_PRIVATE value
         * @property {number} MEMBER_JOINED_BY_INVITE_LINK=8 MEMBER_JOINED_BY_INVITE_LINK value
         * @property {number} ROOM_DELETED=9 ROOM_DELETED value
         * @property {number} MISSED_VOICE_CALL=10 MISSED_VOICE_CALL value
         * @property {number} MISSED_VIDEO_CALL=11 MISSED_VIDEO_CALL value
         * @property {number} MISSED_SCREEN_SHARE=12 MISSED_SCREEN_SHARE value
         * @property {number} MISSED_SECRET_CHAT=13 MISSED_SECRET_CHAT value
         * @property {number} PINNED_MESSAGE=14 PINNED_MESSAGE value
         */
    RoomMessageLog.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'USER_JOINED'] = 0;
      values[valuesById[1] = 'USER_DELETED'] = 1;
      values[valuesById[2] = 'ROOM_CREATED'] = 2;
      values[valuesById[3] = 'MEMBER_ADDED'] = 3;
      values[valuesById[4] = 'MEMBER_KICKED'] = 4;
      values[valuesById[5] = 'MEMBER_LEFT'] = 5;
      values[valuesById[6] = 'ROOM_CONVERTED_TO_PUBLIC'] = 6;
      values[valuesById[7] = 'ROOM_CONVERTED_TO_PRIVATE'] = 7;
      values[valuesById[8] = 'MEMBER_JOINED_BY_INVITE_LINK'] = 8;
      values[valuesById[9] = 'ROOM_DELETED'] = 9;
      values[valuesById[10] = 'MISSED_VOICE_CALL'] = 10;
      values[valuesById[11] = 'MISSED_VIDEO_CALL'] = 11;
      values[valuesById[12] = 'MISSED_SCREEN_SHARE'] = 12;
      values[valuesById[13] = 'MISSED_SECRET_CHAT'] = 13;
      values[valuesById[14] = 'PINNED_MESSAGE'] = 14;
      return values;
    })();

    /**
         * ExtraType enum.
         * @name proto.RoomMessageLog.ExtraType
         * @enum {string}
         * @property {number} NO_EXTRA=0 NO_EXTRA value
         * @property {number} TARGET_USER=1 TARGET_USER value
         */
    RoomMessageLog.ExtraType = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'NO_EXTRA'] = 0;
      values[valuesById[1] = 'TARGET_USER'] = 1;
      return values;
    })();

    RoomMessageLog.TargetUser = (function() {

      /**
             * Properties of a TargetUser.
             * @memberof proto.RoomMessageLog
             * @interface ITargetUser
             * @property {Long|null} [id] TargetUser id
             */

      /**
             * Constructs a new TargetUser.
             * @memberof proto.RoomMessageLog
             * @classdesc Represents a TargetUser.
             * @implements ITargetUser
             * @constructor
             * @param {proto.RoomMessageLog.ITargetUser=} [properties] Properties to set
             */
      function TargetUser(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * TargetUser id.
             * @member {Long} id
             * @memberof proto.RoomMessageLog.TargetUser
             * @instance
             */
      TargetUser.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Creates a new TargetUser instance using the specified properties.
             * @function create
             * @memberof proto.RoomMessageLog.TargetUser
             * @static
             * @param {proto.RoomMessageLog.ITargetUser=} [properties] Properties to set
             * @returns {proto.RoomMessageLog.TargetUser} TargetUser instance
             */
      TargetUser.create = function create(properties) {
        return new TargetUser(properties);
      };

      /**
             * Encodes the specified TargetUser message. Does not implicitly {@link proto.RoomMessageLog.TargetUser.verify|verify} messages.
             * @function encode
             * @memberof proto.RoomMessageLog.TargetUser
             * @static
             * @param {proto.RoomMessageLog.TargetUser} message TargetUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      TargetUser.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);}
        return writer;
      };

      /**
             * Decodes a TargetUser message from the specified reader or buffer.
             * @function decode
             * @memberof proto.RoomMessageLog.TargetUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.RoomMessageLog.TargetUser} TargetUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      TargetUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessageLog.TargetUser();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a TargetUser message.
             * @function verify
             * @memberof proto.RoomMessageLog.TargetUser
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      TargetUser.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.id != null && message.hasOwnProperty('id')) {
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
        }
        return null;
      };

      return TargetUser;
    })();

    return RoomMessageLog;
  })();

  proto.RoomMessageContact = (function() {

    /**
         * Properties of a RoomMessageContact.
         * @memberof proto
         * @interface IRoomMessageContact
         * @property {string|null} [firstName] RoomMessageContact firstName
         * @property {string|null} [lastName] RoomMessageContact lastName
         * @property {string|null} [nickname] RoomMessageContact nickname
         * @property {Array.<string>|null} [phone] RoomMessageContact phone
         * @property {Array.<string>|null} [email] RoomMessageContact email
         */

    /**
         * Constructs a new RoomMessageContact.
         * @memberof proto
         * @classdesc Represents a RoomMessageContact.
         * @implements IRoomMessageContact
         * @constructor
         * @param {proto.IRoomMessageContact=} [properties] Properties to set
         */
    function RoomMessageContact(properties) {
      this.phone = [];
      this.email = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomMessageContact firstName.
         * @member {string} firstName
         * @memberof proto.RoomMessageContact
         * @instance
         */
    RoomMessageContact.prototype.firstName = '';

    /**
         * RoomMessageContact lastName.
         * @member {string} lastName
         * @memberof proto.RoomMessageContact
         * @instance
         */
    RoomMessageContact.prototype.lastName = '';

    /**
         * RoomMessageContact nickname.
         * @member {string} nickname
         * @memberof proto.RoomMessageContact
         * @instance
         */
    RoomMessageContact.prototype.nickname = '';

    /**
         * RoomMessageContact phone.
         * @member {Array.<string>} phone
         * @memberof proto.RoomMessageContact
         * @instance
         */
    RoomMessageContact.prototype.phone = $util.emptyArray;

    /**
         * RoomMessageContact email.
         * @member {Array.<string>} email
         * @memberof proto.RoomMessageContact
         * @instance
         */
    RoomMessageContact.prototype.email = $util.emptyArray;

    /**
         * Creates a new RoomMessageContact instance using the specified properties.
         * @function create
         * @memberof proto.RoomMessageContact
         * @static
         * @param {proto.IRoomMessageContact=} [properties] Properties to set
         * @returns {proto.RoomMessageContact} RoomMessageContact instance
         */
    RoomMessageContact.create = function create(properties) {
      return new RoomMessageContact(properties);
    };

    /**
         * Encodes the specified RoomMessageContact message. Does not implicitly {@link proto.RoomMessageContact.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomMessageContact
         * @static
         * @param {proto.RoomMessageContact} message RoomMessageContact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomMessageContact.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.firstName);}
      if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.lastName);}
      if (message.nickname != null && message.hasOwnProperty('nickname')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);}
      if (message.phone != null && message.phone.length) {
        for (let i = 0; i < message.phone.length; ++i) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.phone[i]);}
      }
      if (message.email != null && message.email.length) {
        for (let i = 0; i < message.email.length; ++i) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.email[i]);}
      }
      return writer;
    };

    /**
         * Decodes a RoomMessageContact message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomMessageContact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomMessageContact} RoomMessageContact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomMessageContact.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessageContact();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.firstName = reader.string();
            break;
          case 2:
            message.lastName = reader.string();
            break;
          case 3:
            message.nickname = reader.string();
            break;
          case 4:
            if (!(message.phone && message.phone.length)) {message.phone = [];}
            message.phone.push(reader.string());
            break;
          case 5:
            if (!(message.email && message.email.length)) {message.email = [];}
            message.email.push(reader.string());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomMessageContact message.
         * @function verify
         * @memberof proto.RoomMessageContact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomMessageContact.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {
        if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
      }
      if (message.lastName != null && message.hasOwnProperty('lastName')) {
        if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
      }
      if (message.nickname != null && message.hasOwnProperty('nickname')) {
        if (!$util.isString(message.nickname)) {return 'nickname: string expected';}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!Array.isArray(message.phone)) {return 'phone: array expected';}
        for (let i = 0; i < message.phone.length; ++i) {
          if (!$util.isString(message.phone[i])) {return 'phone: string[] expected';}
        }
      }
      if (message.email != null && message.hasOwnProperty('email')) {
        if (!Array.isArray(message.email)) {return 'email: array expected';}
        for (let i = 0; i < message.email.length; ++i) {
          if (!$util.isString(message.email[i])) {return 'email: string[] expected';}
        }
      }
      return null;
    };

    return RoomMessageContact;
  })();

  proto.RoomMessageForwardFrom = (function() {

    /**
         * Properties of a RoomMessageForwardFrom.
         * @memberof proto
         * @interface IRoomMessageForwardFrom
         * @property {Long|null} [roomId] RoomMessageForwardFrom roomId
         * @property {Long|null} [messageId] RoomMessageForwardFrom messageId
         */

    /**
         * Constructs a new RoomMessageForwardFrom.
         * @memberof proto
         * @classdesc Represents a RoomMessageForwardFrom.
         * @implements IRoomMessageForwardFrom
         * @constructor
         * @param {proto.IRoomMessageForwardFrom=} [properties] Properties to set
         */
    function RoomMessageForwardFrom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomMessageForwardFrom roomId.
         * @member {Long} roomId
         * @memberof proto.RoomMessageForwardFrom
         * @instance
         */
    RoomMessageForwardFrom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessageForwardFrom messageId.
         * @member {Long} messageId
         * @memberof proto.RoomMessageForwardFrom
         * @instance
         */
    RoomMessageForwardFrom.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new RoomMessageForwardFrom instance using the specified properties.
         * @function create
         * @memberof proto.RoomMessageForwardFrom
         * @static
         * @param {proto.IRoomMessageForwardFrom=} [properties] Properties to set
         * @returns {proto.RoomMessageForwardFrom} RoomMessageForwardFrom instance
         */
    RoomMessageForwardFrom.create = function create(properties) {
      return new RoomMessageForwardFrom(properties);
    };

    /**
         * Encodes the specified RoomMessageForwardFrom message. Does not implicitly {@link proto.RoomMessageForwardFrom.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomMessageForwardFrom
         * @static
         * @param {proto.RoomMessageForwardFrom} message RoomMessageForwardFrom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomMessageForwardFrom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a RoomMessageForwardFrom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomMessageForwardFrom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomMessageForwardFrom} RoomMessageForwardFrom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomMessageForwardFrom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessageForwardFrom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.roomId = reader.uint64();
            break;
          case 2:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomMessageForwardFrom message.
         * @function verify
         * @memberof proto.RoomMessageForwardFrom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomMessageForwardFrom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return RoomMessageForwardFrom;
  })();

  proto.RegisteredUser = (function() {

    /**
         * Properties of a RegisteredUser.
         * @memberof proto
         * @interface IRegisteredUser
         * @property {Long|null} [id] RegisteredUser id
         * @property {string|null} [username] RegisteredUser username
         * @property {Long|null} [phone] RegisteredUser phone
         * @property {string|null} [firstName] RegisteredUser firstName
         * @property {string|null} [lastName] RegisteredUser lastName
         * @property {string|null} [displayName] RegisteredUser displayName
         * @property {string|null} [initials] RegisteredUser initials
         * @property {string|null} [color] RegisteredUser color
         * @property {proto.RegisteredUser.Status|null} [status] RegisteredUser status
         * @property {number|null} [lastSeen] RegisteredUser lastSeen
         * @property {number|null} [avatarCount] RegisteredUser avatarCount
         * @property {proto.Avatar|null} [avatar] RegisteredUser avatar
         * @property {boolean|null} [mutual] RegisteredUser mutual
         * @property {boolean|null} [deleted] RegisteredUser deleted
         * @property {string|null} [cacheId] RegisteredUser cacheId
         * @property {string|null} [bio] RegisteredUser bio
         * @property {boolean|null} [verified] RegisteredUser verified
         */

    /**
         * Constructs a new RegisteredUser.
         * @memberof proto
         * @classdesc Represents a RegisteredUser.
         * @implements IRegisteredUser
         * @constructor
         * @param {proto.IRegisteredUser=} [properties] Properties to set
         */
    function RegisteredUser(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RegisteredUser id.
         * @member {Long} id
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RegisteredUser username.
         * @member {string} username
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.username = '';

    /**
         * RegisteredUser phone.
         * @member {Long} phone
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.phone = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RegisteredUser firstName.
         * @member {string} firstName
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.firstName = '';

    /**
         * RegisteredUser lastName.
         * @member {string} lastName
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.lastName = '';

    /**
         * RegisteredUser displayName.
         * @member {string} displayName
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.displayName = '';

    /**
         * RegisteredUser initials.
         * @member {string} initials
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.initials = '';

    /**
         * RegisteredUser color.
         * @member {string} color
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.color = '';

    /**
         * RegisteredUser status.
         * @member {proto.RegisteredUser.Status} status
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.status = 0;

    /**
         * RegisteredUser lastSeen.
         * @member {number} lastSeen
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.lastSeen = 0;

    /**
         * RegisteredUser avatarCount.
         * @member {number} avatarCount
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.avatarCount = 0;

    /**
         * RegisteredUser avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.avatar = null;

    /**
         * RegisteredUser mutual.
         * @member {boolean} mutual
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.mutual = false;

    /**
         * RegisteredUser deleted.
         * @member {boolean} deleted
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.deleted = false;

    /**
         * RegisteredUser cacheId.
         * @member {string} cacheId
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.cacheId = '';

    /**
         * RegisteredUser bio.
         * @member {string} bio
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.bio = '';

    /**
         * RegisteredUser verified.
         * @member {boolean} verified
         * @memberof proto.RegisteredUser
         * @instance
         */
    RegisteredUser.prototype.verified = false;

    /**
         * Creates a new RegisteredUser instance using the specified properties.
         * @function create
         * @memberof proto.RegisteredUser
         * @static
         * @param {proto.IRegisteredUser=} [properties] Properties to set
         * @returns {proto.RegisteredUser} RegisteredUser instance
         */
    RegisteredUser.create = function create(properties) {
      return new RegisteredUser(properties);
    };

    /**
         * Encodes the specified RegisteredUser message. Does not implicitly {@link proto.RegisteredUser.verify|verify} messages.
         * @function encode
         * @memberof proto.RegisteredUser
         * @static
         * @param {proto.RegisteredUser} message RegisteredUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RegisteredUser.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.phone);}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.firstName);}
      if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.lastName);}
      if (message.displayName != null && message.hasOwnProperty('displayName')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.displayName);}
      if (message.initials != null && message.hasOwnProperty('initials')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.initials);}
      if (message.color != null && message.hasOwnProperty('color')) {writer.uint32(/* id 8, wireType 2 =*/66).string(message.color);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 9, wireType 0 =*/72).int32(message.status);}
      if (message.lastSeen != null && message.hasOwnProperty('lastSeen')) {writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.lastSeen);}
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.avatarCount);}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();}
      if (message.mutual != null && message.hasOwnProperty('mutual')) {writer.uint32(/* id 13, wireType 0 =*/104).bool(message.mutual);}
      if (message.deleted != null && message.hasOwnProperty('deleted')) {writer.uint32(/* id 14, wireType 0 =*/112).bool(message.deleted);}
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 15, wireType 2 =*/122).string(message.cacheId);}
      if (message.bio != null && message.hasOwnProperty('bio')) {writer.uint32(/* id 16, wireType 2 =*/130).string(message.bio);}
      if (message.verified != null && message.hasOwnProperty('verified')) {writer.uint32(/* id 17, wireType 0 =*/136).bool(message.verified);}
      return writer;
    };

    /**
         * Decodes a RegisteredUser message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RegisteredUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RegisteredUser} RegisteredUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RegisteredUser.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RegisteredUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader.uint64();
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.phone = reader.uint64();
            break;
          case 4:
            message.firstName = reader.string();
            break;
          case 5:
            message.lastName = reader.string();
            break;
          case 6:
            message.displayName = reader.string();
            break;
          case 7:
            message.initials = reader.string();
            break;
          case 8:
            message.color = reader.string();
            break;
          case 9:
            message.status = reader.int32();
            break;
          case 10:
            message.lastSeen = reader.uint32();
            break;
          case 11:
            message.avatarCount = reader.uint32();
            break;
          case 12:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          case 13:
            message.mutual = reader.bool();
            break;
          case 14:
            message.deleted = reader.bool();
            break;
          case 15:
            message.cacheId = reader.string();
            break;
          case 16:
            message.bio = reader.string();
            break;
          case 17:
            message.verified = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RegisteredUser message.
         * @function verify
         * @memberof proto.RegisteredUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RegisteredUser.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isInteger(message.phone) && !(message.phone && $util.isInteger(message.phone.low) && $util.isInteger(message.phone.high))) {return 'phone: integer|Long expected';}
      }
      if (message.firstName != null && message.hasOwnProperty('firstName')) {
        if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
      }
      if (message.lastName != null && message.hasOwnProperty('lastName')) {
        if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
      }
      if (message.displayName != null && message.hasOwnProperty('displayName')) {
        if (!$util.isString(message.displayName)) {return 'displayName: string expected';}
      }
      if (message.initials != null && message.hasOwnProperty('initials')) {
        if (!$util.isString(message.initials)) {return 'initials: string expected';}
      }
      if (message.color != null && message.hasOwnProperty('color')) {
        if (!$util.isString(message.color)) {return 'color: string expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      }
      if (message.lastSeen != null && message.hasOwnProperty('lastSeen')) {
        if (!$util.isInteger(message.lastSeen)) {return 'lastSeen: integer expected';}
      }
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {
        if (!$util.isInteger(message.avatarCount)) {return 'avatarCount: integer expected';}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      if (message.mutual != null && message.hasOwnProperty('mutual')) {
        if (typeof message.mutual !== 'boolean') {return 'mutual: boolean expected';}
      }
      if (message.deleted != null && message.hasOwnProperty('deleted')) {
        if (typeof message.deleted !== 'boolean') {return 'deleted: boolean expected';}
      }
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
        if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
      }
      if (message.bio != null && message.hasOwnProperty('bio')) {
        if (!$util.isString(message.bio)) {return 'bio: string expected';}
      }
      if (message.verified != null && message.hasOwnProperty('verified')) {
        if (typeof message.verified !== 'boolean') {return 'verified: boolean expected';}
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.RegisteredUser.Status
         * @enum {string}
         * @property {number} LONG_TIME_AGO=0 LONG_TIME_AGO value
         * @property {number} LAST_MONTH=1 LAST_MONTH value
         * @property {number} LAST_WEEK=2 LAST_WEEK value
         * @property {number} ONLINE=3 ONLINE value
         * @property {number} EXACTLY=4 EXACTLY value
         * @property {number} RECENTLY=5 RECENTLY value
         * @property {number} SUPPORT=6 SUPPORT value
         * @property {number} SERVICE_NOTIFICATIONS=7 SERVICE_NOTIFICATIONS value
         */
    RegisteredUser.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'LONG_TIME_AGO'] = 0;
      values[valuesById[1] = 'LAST_MONTH'] = 1;
      values[valuesById[2] = 'LAST_WEEK'] = 2;
      values[valuesById[3] = 'ONLINE'] = 3;
      values[valuesById[4] = 'EXACTLY'] = 4;
      values[valuesById[5] = 'RECENTLY'] = 5;
      values[valuesById[6] = 'SUPPORT'] = 6;
      values[valuesById[7] = 'SERVICE_NOTIFICATIONS'] = 7;
      return values;
    })();

    return RegisteredUser;
  })();

  /**
     * ClientAction enum.
     * @name proto.ClientAction
     * @enum {string}
     * @property {number} CANCEL=0 CANCEL value
     * @property {number} TYPING=1 TYPING value
     * @property {number} SENDING_IMAGE=2 SENDING_IMAGE value
     * @property {number} CAPTURING_IMAGE=3 CAPTURING_IMAGE value
     * @property {number} SENDING_VIDEO=4 SENDING_VIDEO value
     * @property {number} CAPTURING_VIDEO=5 CAPTURING_VIDEO value
     * @property {number} SENDING_AUDIO=6 SENDING_AUDIO value
     * @property {number} RECORDING_VOICE=7 RECORDING_VOICE value
     * @property {number} SENDING_VOICE=8 SENDING_VOICE value
     * @property {number} SENDING_DOCUMENT=9 SENDING_DOCUMENT value
     * @property {number} SENDING_GIF=10 SENDING_GIF value
     * @property {number} SENDING_FILE=11 SENDING_FILE value
     * @property {number} SENDING_LOCATION=12 SENDING_LOCATION value
     * @property {number} CHOOSING_CONTACT=13 CHOOSING_CONTACT value
     * @property {number} PAINTING=14 PAINTING value
     */
  proto.ClientAction = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'CANCEL'] = 0;
    values[valuesById[1] = 'TYPING'] = 1;
    values[valuesById[2] = 'SENDING_IMAGE'] = 2;
    values[valuesById[3] = 'CAPTURING_IMAGE'] = 3;
    values[valuesById[4] = 'SENDING_VIDEO'] = 4;
    values[valuesById[5] = 'CAPTURING_VIDEO'] = 5;
    values[valuesById[6] = 'SENDING_AUDIO'] = 6;
    values[valuesById[7] = 'RECORDING_VOICE'] = 7;
    values[valuesById[8] = 'SENDING_VOICE'] = 8;
    values[valuesById[9] = 'SENDING_DOCUMENT'] = 9;
    values[valuesById[10] = 'SENDING_GIF'] = 10;
    values[valuesById[11] = 'SENDING_FILE'] = 11;
    values[valuesById[12] = 'SENDING_LOCATION'] = 12;
    values[valuesById[13] = 'CHOOSING_CONTACT'] = 13;
    values[valuesById[14] = 'PAINTING'] = 14;
    return values;
  })();

  proto.Avatar = (function() {

    /**
         * Properties of an Avatar.
         * @memberof proto
         * @interface IAvatar
         * @property {Long|null} [id] Avatar id
         * @property {proto.File|null} [file] Avatar file
         */

    /**
         * Constructs a new Avatar.
         * @memberof proto
         * @classdesc Represents an Avatar.
         * @implements IAvatar
         * @constructor
         * @param {proto.IAvatar=} [properties] Properties to set
         */
    function Avatar(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Avatar id.
         * @member {Long} id
         * @memberof proto.Avatar
         * @instance
         */
    Avatar.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Avatar file.
         * @member {proto.File|null|undefined} file
         * @memberof proto.Avatar
         * @instance
         */
    Avatar.prototype.file = null;

    /**
         * Creates a new Avatar instance using the specified properties.
         * @function create
         * @memberof proto.Avatar
         * @static
         * @param {proto.IAvatar=} [properties] Properties to set
         * @returns {proto.Avatar} Avatar instance
         */
    Avatar.create = function create(properties) {
      return new Avatar(properties);
    };

    /**
         * Encodes the specified Avatar message. Does not implicitly {@link proto.Avatar.verify|verify} messages.
         * @function encode
         * @memberof proto.Avatar
         * @static
         * @param {proto.Avatar} message Avatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Avatar.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);}
      if (message.file != null && message.hasOwnProperty('file')) {$root.proto.File.encode(message.file, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes an Avatar message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Avatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Avatar} Avatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Avatar.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Avatar();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader.uint64();
            break;
          case 2:
            message.file = $root.proto.File.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an Avatar message.
         * @function verify
         * @memberof proto.Avatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Avatar.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.file != null && message.hasOwnProperty('file')) {
        let error = $root.proto.File.verify(message.file);
        if (error) {return 'file.' + error;}
      }
      return null;
    };

    return Avatar;
  })();

  proto.RoomMessage = (function() {

    /**
         * Properties of a RoomMessage.
         * @memberof proto
         * @interface IRoomMessage
         * @property {Long|null} [messageId] RoomMessage messageId
         * @property {Long|null} [messageVersion] RoomMessage messageVersion
         * @property {proto.RoomMessageStatus|null} [status] RoomMessage status
         * @property {Long|null} [statusVersion] RoomMessage statusVersion
         * @property {proto.RoomMessageType|null} [messageType] RoomMessage messageType
         * @property {string|null} [message] RoomMessage message
         * @property {proto.File|null} [attachment] RoomMessage attachment
         * @property {proto.RoomMessage.Author|null} [author] RoomMessage author
         * @property {proto.RoomMessageLocation|null} [location] RoomMessage location
         * @property {proto.RoomMessageLog|null} [log] RoomMessage log
         * @property {proto.RoomMessageContact|null} [contact] RoomMessage contact
         * @property {boolean|null} [edited] RoomMessage edited
         * @property {number|null} [createTime] RoomMessage createTime
         * @property {number|null} [updateTime] RoomMessage updateTime
         * @property {boolean|null} [deleted] RoomMessage deleted
         * @property {proto.RoomMessage|null} [forwardFrom] RoomMessage forwardFrom
         * @property {proto.RoomMessage|null} [replyTo] RoomMessage replyTo
         * @property {Long|null} [previousMessageId] RoomMessage previousMessageId
         * @property {Long|null} [randomId] RoomMessage randomId
         * @property {proto.RoomMessage.ExtraType|null} [extraType] RoomMessage extraType
         * @property {proto.RoomMessage.ChannelExtra|null} [channelExtra] RoomMessage channelExtra
         */

    /**
         * Constructs a new RoomMessage.
         * @memberof proto
         * @classdesc Represents a RoomMessage.
         * @implements IRoomMessage
         * @constructor
         * @param {proto.IRoomMessage=} [properties] Properties to set
         */
    function RoomMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomMessage messageId.
         * @member {Long} messageId
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessage messageVersion.
         * @member {Long} messageVersion
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.messageVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessage status.
         * @member {proto.RoomMessageStatus} status
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.status = 0;

    /**
         * RoomMessage statusVersion.
         * @member {Long} statusVersion
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.statusVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessage messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.messageType = 0;

    /**
         * RoomMessage message.
         * @member {string} message
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.message = '';

    /**
         * RoomMessage attachment.
         * @member {proto.File|null|undefined} attachment
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.attachment = null;

    /**
         * RoomMessage author.
         * @member {proto.RoomMessage.Author|null|undefined} author
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.author = null;

    /**
         * RoomMessage location.
         * @member {proto.RoomMessageLocation|null|undefined} location
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.location = null;

    /**
         * RoomMessage log.
         * @member {proto.RoomMessageLog|null|undefined} log
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.log = null;

    /**
         * RoomMessage contact.
         * @member {proto.RoomMessageContact|null|undefined} contact
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.contact = null;

    /**
         * RoomMessage edited.
         * @member {boolean} edited
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.edited = false;

    /**
         * RoomMessage createTime.
         * @member {number} createTime
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.createTime = 0;

    /**
         * RoomMessage updateTime.
         * @member {number} updateTime
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.updateTime = 0;

    /**
         * RoomMessage deleted.
         * @member {boolean} deleted
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.deleted = false;

    /**
         * RoomMessage forwardFrom.
         * @member {proto.RoomMessage|null|undefined} forwardFrom
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.forwardFrom = null;

    /**
         * RoomMessage replyTo.
         * @member {proto.RoomMessage|null|undefined} replyTo
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.replyTo = null;

    /**
         * RoomMessage previousMessageId.
         * @member {Long} previousMessageId
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.previousMessageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessage randomId.
         * @member {Long} randomId
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.randomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * RoomMessage extraType.
         * @member {proto.RoomMessage.ExtraType} extraType
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.extraType = 0;

    /**
         * RoomMessage channelExtra.
         * @member {proto.RoomMessage.ChannelExtra|null|undefined} channelExtra
         * @memberof proto.RoomMessage
         * @instance
         */
    RoomMessage.prototype.channelExtra = null;

    /**
         * Creates a new RoomMessage instance using the specified properties.
         * @function create
         * @memberof proto.RoomMessage
         * @static
         * @param {proto.IRoomMessage=} [properties] Properties to set
         * @returns {proto.RoomMessage} RoomMessage instance
         */
    RoomMessage.create = function create(properties) {
      return new RoomMessage(properties);
    };

    /**
         * Encodes the specified RoomMessage message. Does not implicitly {@link proto.RoomMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomMessage
         * @static
         * @param {proto.RoomMessage} message RoomMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);}
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageVersion);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);}
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.statusVersion);}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 5, wireType 0 =*/40).int32(message.messageType);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.message);}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {$root.proto.File.encode(message.attachment, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.author != null && message.hasOwnProperty('author')) {$root.proto.RoomMessage.Author.encode(message.author, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();}
      if (message.location != null && message.hasOwnProperty('location')) {$root.proto.RoomMessageLocation.encode(message.location, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.log != null && message.hasOwnProperty('log')) {$root.proto.RoomMessageLog.encode(message.log, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();}
      if (message.contact != null && message.hasOwnProperty('contact')) {$root.proto.RoomMessageContact.encode(message.contact, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();}
      if (message.edited != null && message.hasOwnProperty('edited')) {writer.uint32(/* id 12, wireType 0 =*/96).bool(message.edited);}
      if (message.createTime != null && message.hasOwnProperty('createTime')) {writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.createTime);}
      if (message.updateTime != null && message.hasOwnProperty('updateTime')) {writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.updateTime);}
      if (message.deleted != null && message.hasOwnProperty('deleted')) {writer.uint32(/* id 15, wireType 0 =*/120).bool(message.deleted);}
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {$root.proto.RoomMessage.encode(message.forwardFrom, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();}
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {$root.proto.RoomMessage.encode(message.replyTo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();}
      if (message.previousMessageId != null && message.hasOwnProperty('previousMessageId')) {writer.uint32(/* id 18, wireType 0 =*/144).uint64(message.previousMessageId);}
      if (message.extraType != null && message.hasOwnProperty('extraType')) {writer.uint32(/* id 19, wireType 0 =*/152).int32(message.extraType);}
      if (message.channelExtra != null && message.hasOwnProperty('channelExtra')) {$root.proto.RoomMessage.ChannelExtra.encode(message.channelExtra, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();}
      if (message.randomId != null && message.hasOwnProperty('randomId')) {writer.uint32(/* id 21, wireType 0 =*/168).uint64(message.randomId);}
      return writer;
    };

    /**
         * Decodes a RoomMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomMessage} RoomMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.messageId = reader.uint64();
            break;
          case 2:
            message.messageVersion = reader.uint64();
            break;
          case 3:
            message.status = reader.int32();
            break;
          case 4:
            message.statusVersion = reader.uint64();
            break;
          case 5:
            message.messageType = reader.int32();
            break;
          case 6:
            message.message = reader.string();
            break;
          case 7:
            message.attachment = $root.proto.File.decode(reader, reader.uint32());
            break;
          case 8:
            message.author = $root.proto.RoomMessage.Author.decode(reader, reader.uint32());
            break;
          case 9:
            message.location = $root.proto.RoomMessageLocation.decode(reader, reader.uint32());
            break;
          case 10:
            message.log = $root.proto.RoomMessageLog.decode(reader, reader.uint32());
            break;
          case 11:
            message.contact = $root.proto.RoomMessageContact.decode(reader, reader.uint32());
            break;
          case 12:
            message.edited = reader.bool();
            break;
          case 13:
            message.createTime = reader.uint32();
            break;
          case 14:
            message.updateTime = reader.uint32();
            break;
          case 15:
            message.deleted = reader.bool();
            break;
          case 16:
            message.forwardFrom = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          case 17:
            message.replyTo = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          case 18:
            message.previousMessageId = reader.uint64();
            break;
          case 21:
            message.randomId = reader.uint64();
            break;
          case 19:
            message.extraType = reader.int32();
            break;
          case 20:
            message.channelExtra = $root.proto.RoomMessage.ChannelExtra.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomMessage message.
         * @function verify
         * @memberof proto.RoomMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {
        if (!$util.isInteger(message.messageVersion) && !(message.messageVersion && $util.isInteger(message.messageVersion.low) && $util.isInteger(message.messageVersion.high))) {return 'messageVersion: integer|Long expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {
        if (!$util.isInteger(message.statusVersion) && !(message.statusVersion && $util.isInteger(message.statusVersion.low) && $util.isInteger(message.statusVersion.high))) {return 'statusVersion: integer|Long expected';}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        let error = $root.proto.File.verify(message.attachment);
        if (error) {return 'attachment.' + error;}
      }
      if (message.author != null && message.hasOwnProperty('author')) {
        let error = $root.proto.RoomMessage.Author.verify(message.author);
        if (error) {return 'author.' + error;}
      }
      if (message.location != null && message.hasOwnProperty('location')) {
        let error = $root.proto.RoomMessageLocation.verify(message.location);
        if (error) {return 'location.' + error;}
      }
      if (message.log != null && message.hasOwnProperty('log')) {
        let error = $root.proto.RoomMessageLog.verify(message.log);
        if (error) {return 'log.' + error;}
      }
      if (message.contact != null && message.hasOwnProperty('contact')) {
        let error = $root.proto.RoomMessageContact.verify(message.contact);
        if (error) {return 'contact.' + error;}
      }
      if (message.edited != null && message.hasOwnProperty('edited')) {
        if (typeof message.edited !== 'boolean') {return 'edited: boolean expected';}
      }
      if (message.createTime != null && message.hasOwnProperty('createTime')) {
        if (!$util.isInteger(message.createTime)) {return 'createTime: integer expected';}
      }
      if (message.updateTime != null && message.hasOwnProperty('updateTime')) {
        if (!$util.isInteger(message.updateTime)) {return 'updateTime: integer expected';}
      }
      if (message.deleted != null && message.hasOwnProperty('deleted')) {
        if (typeof message.deleted !== 'boolean') {return 'deleted: boolean expected';}
      }
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {
        let error = $root.proto.RoomMessage.verify(message.forwardFrom);
        if (error) {return 'forwardFrom.' + error;}
      }
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {
        let error = $root.proto.RoomMessage.verify(message.replyTo);
        if (error) {return 'replyTo.' + error;}
      }
      if (message.previousMessageId != null && message.hasOwnProperty('previousMessageId')) {
        if (!$util.isInteger(message.previousMessageId) && !(message.previousMessageId && $util.isInteger(message.previousMessageId.low) && $util.isInteger(message.previousMessageId.high))) {return 'previousMessageId: integer|Long expected';}
      }
      if (message.randomId != null && message.hasOwnProperty('randomId')) {
        if (!$util.isInteger(message.randomId) && !(message.randomId && $util.isInteger(message.randomId.low) && $util.isInteger(message.randomId.high))) {return 'randomId: integer|Long expected';}
      }
      if (message.extraType != null && message.hasOwnProperty('extraType')) {
        switch (message.extraType) {
          default:
            return 'extraType: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.channelExtra != null && message.hasOwnProperty('channelExtra')) {
        let error = $root.proto.RoomMessage.ChannelExtra.verify(message.channelExtra);
        if (error) {return 'channelExtra.' + error;}
      }
      return null;
    };

    RoomMessage.Author = (function() {

      /**
             * Properties of an Author.
             * @memberof proto.RoomMessage
             * @interface IAuthor
             * @property {string|null} [hash] Author hash
             * @property {proto.RoomMessage.Author.User|null} [user] Author user
             * @property {proto.RoomMessage.Author.Room|null} [room] Author room
             */

      /**
             * Constructs a new Author.
             * @memberof proto.RoomMessage
             * @classdesc Represents an Author.
             * @implements IAuthor
             * @constructor
             * @param {proto.RoomMessage.IAuthor=} [properties] Properties to set
             */
      function Author(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Author hash.
             * @member {string} hash
             * @memberof proto.RoomMessage.Author
             * @instance
             */
      Author.prototype.hash = '';

      /**
             * Author user.
             * @member {proto.RoomMessage.Author.User|null|undefined} user
             * @memberof proto.RoomMessage.Author
             * @instance
             */
      Author.prototype.user = null;

      /**
             * Author room.
             * @member {proto.RoomMessage.Author.Room|null|undefined} room
             * @memberof proto.RoomMessage.Author
             * @instance
             */
      Author.prototype.room = null;

      /**
             * Creates a new Author instance using the specified properties.
             * @function create
             * @memberof proto.RoomMessage.Author
             * @static
             * @param {proto.RoomMessage.IAuthor=} [properties] Properties to set
             * @returns {proto.RoomMessage.Author} Author instance
             */
      Author.create = function create(properties) {
        return new Author(properties);
      };

      /**
             * Encodes the specified Author message. Does not implicitly {@link proto.RoomMessage.Author.verify|verify} messages.
             * @function encode
             * @memberof proto.RoomMessage.Author
             * @static
             * @param {proto.RoomMessage.Author} message Author message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Author.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.hash != null && message.hasOwnProperty('hash')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);}
        if (message.user != null && message.hasOwnProperty('user')) {$root.proto.RoomMessage.Author.User.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
        if (message.room != null && message.hasOwnProperty('room')) {$root.proto.RoomMessage.Author.Room.encode(message.room, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
        return writer;
      };

      /**
             * Decodes an Author message from the specified reader or buffer.
             * @function decode
             * @memberof proto.RoomMessage.Author
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.RoomMessage.Author} Author
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Author.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessage.Author();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            case 2:
              message.user = $root.proto.RoomMessage.Author.User.decode(reader, reader.uint32());
              break;
            case 3:
              message.room = $root.proto.RoomMessage.Author.Room.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies an Author message.
             * @function verify
             * @memberof proto.RoomMessage.Author
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Author.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.hash != null && message.hasOwnProperty('hash')) {
          if (!$util.isString(message.hash)) {return 'hash: string expected';}
        }
        if (message.user != null && message.hasOwnProperty('user')) {
          let error = $root.proto.RoomMessage.Author.User.verify(message.user);
          if (error) {return 'user.' + error;}
        }
        if (message.room != null && message.hasOwnProperty('room')) {
          let error = $root.proto.RoomMessage.Author.Room.verify(message.room);
          if (error) {return 'room.' + error;}
        }
        return null;
      };

      Author.User = (function() {

        /**
                 * Properties of a User.
                 * @memberof proto.RoomMessage.Author
                 * @interface IUser
                 * @property {Long|null} [userId] User userId
                 * @property {string|null} [cacheId] User cacheId
                 */

        /**
                 * Constructs a new User.
                 * @memberof proto.RoomMessage.Author
                 * @classdesc Represents a User.
                 * @implements IUser
                 * @constructor
                 * @param {proto.RoomMessage.Author.IUser=} [properties] Properties to set
                 */
        function User(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
              if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
            }
          }
        }

        /**
                 * User userId.
                 * @member {Long} userId
                 * @memberof proto.RoomMessage.Author.User
                 * @instance
                 */
        User.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
                 * User cacheId.
                 * @member {string} cacheId
                 * @memberof proto.RoomMessage.Author.User
                 * @instance
                 */
        User.prototype.cacheId = '';

        /**
                 * Creates a new User instance using the specified properties.
                 * @function create
                 * @memberof proto.RoomMessage.Author.User
                 * @static
                 * @param {proto.RoomMessage.Author.IUser=} [properties] Properties to set
                 * @returns {proto.RoomMessage.Author.User} User instance
                 */
        User.create = function create(properties) {
          return new User(properties);
        };

        /**
                 * Encodes the specified User message. Does not implicitly {@link proto.RoomMessage.Author.User.verify|verify} messages.
                 * @function encode
                 * @memberof proto.RoomMessage.Author.User
                 * @static
                 * @param {proto.RoomMessage.Author.User} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
        User.encode = function encode(message, writer) {
          if (!writer) {writer = $Writer.create();}
          if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
          if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.cacheId);}
          return writer;
        };

        /**
                 * Decodes a User message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.RoomMessage.Author.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.RoomMessage.Author.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
        User.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessage.Author.User();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.userId = reader.uint64();
                break;
              case 2:
                message.cacheId = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
                 * Verifies a User message.
                 * @function verify
                 * @memberof proto.RoomMessage.Author.User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
        User.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) {return 'object expected';}
          if (message.userId != null && message.hasOwnProperty('userId')) {
            if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
          }
          if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
            if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
          }
          return null;
        };

        return User;
      })();

      Author.Room = (function() {

        /**
                 * Properties of a Room.
                 * @memberof proto.RoomMessage.Author
                 * @interface IRoom
                 * @property {Long|null} [roomId] Room roomId
                 */

        /**
                 * Constructs a new Room.
                 * @memberof proto.RoomMessage.Author
                 * @classdesc Represents a Room.
                 * @implements IRoom
                 * @constructor
                 * @param {proto.RoomMessage.Author.IRoom=} [properties] Properties to set
                 */
        function Room(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
              if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
            }
          }
        }

        /**
                 * Room roomId.
                 * @member {Long} roomId
                 * @memberof proto.RoomMessage.Author.Room
                 * @instance
                 */
        Room.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
                 * Creates a new Room instance using the specified properties.
                 * @function create
                 * @memberof proto.RoomMessage.Author.Room
                 * @static
                 * @param {proto.RoomMessage.Author.IRoom=} [properties] Properties to set
                 * @returns {proto.RoomMessage.Author.Room} Room instance
                 */
        Room.create = function create(properties) {
          return new Room(properties);
        };

        /**
                 * Encodes the specified Room message. Does not implicitly {@link proto.RoomMessage.Author.Room.verify|verify} messages.
                 * @function encode
                 * @memberof proto.RoomMessage.Author.Room
                 * @static
                 * @param {proto.RoomMessage.Author.Room} message Room message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
        Room.encode = function encode(message, writer) {
          if (!writer) {writer = $Writer.create();}
          if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roomId);}
          return writer;
        };

        /**
                 * Decodes a Room message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.RoomMessage.Author.Room
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.RoomMessage.Author.Room} Room
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
        Room.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessage.Author.Room();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.roomId = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
                 * Verifies a Room message.
                 * @function verify
                 * @memberof proto.RoomMessage.Author.Room
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
        Room.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) {return 'object expected';}
          if (message.roomId != null && message.hasOwnProperty('roomId')) {
            if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
          }
          return null;
        };

        return Room;
      })();

      return Author;
    })();

    /**
         * ExtraType enum.
         * @name proto.RoomMessage.ExtraType
         * @enum {string}
         * @property {number} NO_EXTRA=0 NO_EXTRA value
         * @property {number} CHANNEL_EXTRA=1 CHANNEL_EXTRA value
         */
    RoomMessage.ExtraType = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'NO_EXTRA'] = 0;
      values[valuesById[1] = 'CHANNEL_EXTRA'] = 1;
      return values;
    })();

    RoomMessage.ChannelExtra = (function() {

      /**
             * Properties of a ChannelExtra.
             * @memberof proto.RoomMessage
             * @interface IChannelExtra
             * @property {string|null} [signature] ChannelExtra signature
             * @property {string|null} [viewsLabel] ChannelExtra viewsLabel
             * @property {string|null} [thumbsUpLabel] ChannelExtra thumbsUpLabel
             * @property {string|null} [thumbsDownLabel] ChannelExtra thumbsDownLabel
             */

      /**
             * Constructs a new ChannelExtra.
             * @memberof proto.RoomMessage
             * @classdesc Represents a ChannelExtra.
             * @implements IChannelExtra
             * @constructor
             * @param {proto.RoomMessage.IChannelExtra=} [properties] Properties to set
             */
      function ChannelExtra(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * ChannelExtra signature.
             * @member {string} signature
             * @memberof proto.RoomMessage.ChannelExtra
             * @instance
             */
      ChannelExtra.prototype.signature = '';

      /**
             * ChannelExtra viewsLabel.
             * @member {string} viewsLabel
             * @memberof proto.RoomMessage.ChannelExtra
             * @instance
             */
      ChannelExtra.prototype.viewsLabel = '';

      /**
             * ChannelExtra thumbsUpLabel.
             * @member {string} thumbsUpLabel
             * @memberof proto.RoomMessage.ChannelExtra
             * @instance
             */
      ChannelExtra.prototype.thumbsUpLabel = '';

      /**
             * ChannelExtra thumbsDownLabel.
             * @member {string} thumbsDownLabel
             * @memberof proto.RoomMessage.ChannelExtra
             * @instance
             */
      ChannelExtra.prototype.thumbsDownLabel = '';

      /**
             * Creates a new ChannelExtra instance using the specified properties.
             * @function create
             * @memberof proto.RoomMessage.ChannelExtra
             * @static
             * @param {proto.RoomMessage.IChannelExtra=} [properties] Properties to set
             * @returns {proto.RoomMessage.ChannelExtra} ChannelExtra instance
             */
      ChannelExtra.create = function create(properties) {
        return new ChannelExtra(properties);
      };

      /**
             * Encodes the specified ChannelExtra message. Does not implicitly {@link proto.RoomMessage.ChannelExtra.verify|verify} messages.
             * @function encode
             * @memberof proto.RoomMessage.ChannelExtra
             * @static
             * @param {proto.RoomMessage.ChannelExtra} message ChannelExtra message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      ChannelExtra.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.signature != null && message.hasOwnProperty('signature')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);}
        if (message.viewsLabel != null && message.hasOwnProperty('viewsLabel')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.viewsLabel);}
        if (message.thumbsUpLabel != null && message.hasOwnProperty('thumbsUpLabel')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.thumbsUpLabel);}
        if (message.thumbsDownLabel != null && message.hasOwnProperty('thumbsDownLabel')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.thumbsDownLabel);}
        return writer;
      };

      /**
             * Decodes a ChannelExtra message from the specified reader or buffer.
             * @function decode
             * @memberof proto.RoomMessage.ChannelExtra
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.RoomMessage.ChannelExtra} ChannelExtra
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      ChannelExtra.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomMessage.ChannelExtra();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signature = reader.string();
              break;
            case 2:
              message.viewsLabel = reader.string();
              break;
            case 3:
              message.thumbsUpLabel = reader.string();
              break;
            case 4:
              message.thumbsDownLabel = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a ChannelExtra message.
             * @function verify
             * @memberof proto.RoomMessage.ChannelExtra
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      ChannelExtra.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.signature != null && message.hasOwnProperty('signature')) {
          if (!$util.isString(message.signature)) {return 'signature: string expected';}
        }
        if (message.viewsLabel != null && message.hasOwnProperty('viewsLabel')) {
          if (!$util.isString(message.viewsLabel)) {return 'viewsLabel: string expected';}
        }
        if (message.thumbsUpLabel != null && message.hasOwnProperty('thumbsUpLabel')) {
          if (!$util.isString(message.thumbsUpLabel)) {return 'thumbsUpLabel: string expected';}
        }
        if (message.thumbsDownLabel != null && message.hasOwnProperty('thumbsDownLabel')) {
          if (!$util.isString(message.thumbsDownLabel)) {return 'thumbsDownLabel: string expected';}
        }
        return null;
      };

      return ChannelExtra;
    })();

    return RoomMessage;
  })();

  proto.RoomDraft = (function() {

    /**
         * Properties of a RoomDraft.
         * @memberof proto
         * @interface IRoomDraft
         * @property {string|null} [message] RoomDraft message
         * @property {Long|null} [replyTo] RoomDraft replyTo
         */

    /**
         * Constructs a new RoomDraft.
         * @memberof proto
         * @classdesc Represents a RoomDraft.
         * @implements IRoomDraft
         * @constructor
         * @param {proto.IRoomDraft=} [properties] Properties to set
         */
    function RoomDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * RoomDraft message.
         * @member {string} message
         * @memberof proto.RoomDraft
         * @instance
         */
    RoomDraft.prototype.message = '';

    /**
         * RoomDraft replyTo.
         * @member {Long} replyTo
         * @memberof proto.RoomDraft
         * @instance
         */
    RoomDraft.prototype.replyTo = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new RoomDraft instance using the specified properties.
         * @function create
         * @memberof proto.RoomDraft
         * @static
         * @param {proto.IRoomDraft=} [properties] Properties to set
         * @returns {proto.RoomDraft} RoomDraft instance
         */
    RoomDraft.create = function create(properties) {
      return new RoomDraft(properties);
    };

    /**
         * Encodes the specified RoomDraft message. Does not implicitly {@link proto.RoomDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.RoomDraft
         * @static
         * @param {proto.RoomDraft} message RoomDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    RoomDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);}
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.replyTo);}
      return writer;
    };

    /**
         * Decodes a RoomDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RoomDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RoomDraft} RoomDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    RoomDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoomDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.message = reader.string();
            break;
          case 2:
            message.replyTo = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a RoomDraft message.
         * @function verify
         * @memberof proto.RoomDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    RoomDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {
        if (!$util.isInteger(message.replyTo) && !(message.replyTo && $util.isInteger(message.replyTo.low) && $util.isInteger(message.replyTo.high))) {return 'replyTo: integer|Long expected';}
      }
      return null;
    };

    return RoomDraft;
  })();

  /**
     * RoomMute enum.
     * @name proto.RoomMute
     * @enum {string}
     * @property {number} UNMUTE=0 UNMUTE value
     * @property {number} MUTE=1 MUTE value
     */
  proto.RoomMute = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'UNMUTE'] = 0;
    values[valuesById[1] = 'MUTE'] = 1;
    return values;
  })();

  proto.Room = (function() {

    /**
         * Properties of a Room.
         * @memberof proto
         * @interface IRoom
         * @property {Long|null} [id] Room id
         * @property {proto.Room.Type|null} [type] Room type
         * @property {string|null} [title] Room title
         * @property {string|null} [initials] Room initials
         * @property {string|null} [color] Room color
         * @property {number|null} [unreadCount] Room unreadCount
         * @property {proto.RoomMessage|null} [lastMessage] Room lastMessage
         * @property {boolean|null} [readOnly] Room readOnly
         * @property {boolean|null} [isParticipant] Room isParticipant
         * @property {proto.RoomDraft|null} [draft] Room draft
         * @property {proto.RoomMessage|null} [firstUnreadMessage] Room firstUnreadMessage
         * @property {proto.RoomMute|null} [roomMute] Room roomMute
         * @property {Long|null} [pinId] Room pinId
         * @property {proto.RoomMessage|null} [pinnedMessage] Room pinnedMessage
         * @property {proto.ChatRoom|null} [chatRoomExtra] Room chatRoomExtra
         * @property {proto.GroupRoom|null} [groupRoomExtra] Room groupRoomExtra
         * @property {proto.ChannelRoom|null} [channelRoomExtra] Room channelRoomExtra
         */

    /**
         * Constructs a new Room.
         * @memberof proto
         * @classdesc Represents a Room.
         * @implements IRoom
         * @constructor
         * @param {proto.IRoom=} [properties] Properties to set
         */
    function Room(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Room id.
         * @member {Long} id
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Room type.
         * @member {proto.Room.Type} type
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.type = 0;

    /**
         * Room title.
         * @member {string} title
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.title = '';

    /**
         * Room initials.
         * @member {string} initials
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.initials = '';

    /**
         * Room color.
         * @member {string} color
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.color = '';

    /**
         * Room unreadCount.
         * @member {number} unreadCount
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.unreadCount = 0;

    /**
         * Room lastMessage.
         * @member {proto.RoomMessage|null|undefined} lastMessage
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.lastMessage = null;

    /**
         * Room readOnly.
         * @member {boolean} readOnly
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.readOnly = false;

    /**
         * Room isParticipant.
         * @member {boolean} isParticipant
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.isParticipant = false;

    /**
         * Room draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.draft = null;

    /**
         * Room firstUnreadMessage.
         * @member {proto.RoomMessage|null|undefined} firstUnreadMessage
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.firstUnreadMessage = null;

    /**
         * Room roomMute.
         * @member {proto.RoomMute} roomMute
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.roomMute = 0;

    /**
         * Room pinId.
         * @member {Long} pinId
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.pinId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Room pinnedMessage.
         * @member {proto.RoomMessage|null|undefined} pinnedMessage
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.pinnedMessage = null;

    /**
         * Room chatRoomExtra.
         * @member {proto.ChatRoom|null|undefined} chatRoomExtra
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.chatRoomExtra = null;

    /**
         * Room groupRoomExtra.
         * @member {proto.GroupRoom|null|undefined} groupRoomExtra
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.groupRoomExtra = null;

    /**
         * Room channelRoomExtra.
         * @member {proto.ChannelRoom|null|undefined} channelRoomExtra
         * @memberof proto.Room
         * @instance
         */
    Room.prototype.channelRoomExtra = null;

    /**
         * Creates a new Room instance using the specified properties.
         * @function create
         * @memberof proto.Room
         * @static
         * @param {proto.IRoom=} [properties] Properties to set
         * @returns {proto.Room} Room instance
         */
    Room.create = function create(properties) {
      return new Room(properties);
    };

    /**
         * Encodes the specified Room message. Does not implicitly {@link proto.Room.verify|verify} messages.
         * @function encode
         * @memberof proto.Room
         * @static
         * @param {proto.Room} message Room message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Room.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      if (message.title != null && message.hasOwnProperty('title')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);}
      if (message.initials != null && message.hasOwnProperty('initials')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.initials);}
      if (message.color != null && message.hasOwnProperty('color')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);}
      if (message.unreadCount != null && message.hasOwnProperty('unreadCount')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.unreadCount);}
      if (message.lastMessage != null && message.hasOwnProperty('lastMessage')) {$root.proto.RoomMessage.encode(message.lastMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.readOnly != null && message.hasOwnProperty('readOnly')) {writer.uint32(/* id 8, wireType 0 =*/64).bool(message.readOnly);}
      if (message.isParticipant != null && message.hasOwnProperty('isParticipant')) {writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isParticipant);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();}
      if (message.chatRoomExtra != null && message.hasOwnProperty('chatRoomExtra')) {$root.proto.ChatRoom.encode(message.chatRoomExtra, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();}
      if (message.groupRoomExtra != null && message.hasOwnProperty('groupRoomExtra')) {$root.proto.GroupRoom.encode(message.groupRoomExtra, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();}
      if (message.channelRoomExtra != null && message.hasOwnProperty('channelRoomExtra')) {$root.proto.ChannelRoom.encode(message.channelRoomExtra, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();}
      if (message.firstUnreadMessage != null && message.hasOwnProperty('firstUnreadMessage')) {$root.proto.RoomMessage.encode(message.firstUnreadMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();}
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {writer.uint32(/* id 15, wireType 0 =*/120).int32(message.roomMute);}
      if (message.pinId != null && message.hasOwnProperty('pinId')) {writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.pinId);}
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {$root.proto.RoomMessage.encode(message.pinnedMessage, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a Room message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Room
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Room} Room
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Room.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Room();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader.uint64();
            break;
          case 2:
            message.type = reader.int32();
            break;
          case 3:
            message.title = reader.string();
            break;
          case 4:
            message.initials = reader.string();
            break;
          case 5:
            message.color = reader.string();
            break;
          case 6:
            message.unreadCount = reader.uint32();
            break;
          case 7:
            message.lastMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          case 8:
            message.readOnly = reader.bool();
            break;
          case 9:
            message.isParticipant = reader.bool();
            break;
          case 10:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          case 14:
            message.firstUnreadMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          case 15:
            message.roomMute = reader.int32();
            break;
          case 16:
            message.pinId = reader.uint64();
            break;
          case 17:
            message.pinnedMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          case 11:
            message.chatRoomExtra = $root.proto.ChatRoom.decode(reader, reader.uint32());
            break;
          case 12:
            message.groupRoomExtra = $root.proto.GroupRoom.decode(reader, reader.uint32());
            break;
          case 13:
            message.channelRoomExtra = $root.proto.ChannelRoom.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Room message.
         * @function verify
         * @memberof proto.Room
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Room.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      if (message.title != null && message.hasOwnProperty('title')) {
        if (!$util.isString(message.title)) {return 'title: string expected';}
      }
      if (message.initials != null && message.hasOwnProperty('initials')) {
        if (!$util.isString(message.initials)) {return 'initials: string expected';}
      }
      if (message.color != null && message.hasOwnProperty('color')) {
        if (!$util.isString(message.color)) {return 'color: string expected';}
      }
      if (message.unreadCount != null && message.hasOwnProperty('unreadCount')) {
        if (!$util.isInteger(message.unreadCount)) {return 'unreadCount: integer expected';}
      }
      if (message.lastMessage != null && message.hasOwnProperty('lastMessage')) {
        let error = $root.proto.RoomMessage.verify(message.lastMessage);
        if (error) {return 'lastMessage.' + error;}
      }
      if (message.readOnly != null && message.hasOwnProperty('readOnly')) {
        if (typeof message.readOnly !== 'boolean') {return 'readOnly: boolean expected';}
      }
      if (message.isParticipant != null && message.hasOwnProperty('isParticipant')) {
        if (typeof message.isParticipant !== 'boolean') {return 'isParticipant: boolean expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      if (message.firstUnreadMessage != null && message.hasOwnProperty('firstUnreadMessage')) {
        let error = $root.proto.RoomMessage.verify(message.firstUnreadMessage);
        if (error) {return 'firstUnreadMessage.' + error;}
      }
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {
        switch (message.roomMute) {
          default:
            return 'roomMute: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.pinId != null && message.hasOwnProperty('pinId')) {
        if (!$util.isInteger(message.pinId) && !(message.pinId && $util.isInteger(message.pinId.low) && $util.isInteger(message.pinId.high))) {return 'pinId: integer|Long expected';}
      }
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {
        let error = $root.proto.RoomMessage.verify(message.pinnedMessage);
        if (error) {return 'pinnedMessage.' + error;}
      }
      if (message.chatRoomExtra != null && message.hasOwnProperty('chatRoomExtra')) {
        let error = $root.proto.ChatRoom.verify(message.chatRoomExtra);
        if (error) {return 'chatRoomExtra.' + error;}
      }
      if (message.groupRoomExtra != null && message.hasOwnProperty('groupRoomExtra')) {
        let error = $root.proto.GroupRoom.verify(message.groupRoomExtra);
        if (error) {return 'groupRoomExtra.' + error;}
      }
      if (message.channelRoomExtra != null && message.hasOwnProperty('channelRoomExtra')) {
        let error = $root.proto.ChannelRoom.verify(message.channelRoomExtra);
        if (error) {return 'channelRoomExtra.' + error;}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.Room.Type
         * @enum {string}
         * @property {number} CHAT=0 CHAT value
         * @property {number} GROUP=1 GROUP value
         * @property {number} CHANNEL=2 CHANNEL value
         */
    Room.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'CHAT'] = 0;
      values[valuesById[1] = 'GROUP'] = 1;
      values[valuesById[2] = 'CHANNEL'] = 2;
      return values;
    })();

    return Room;
  })();

  proto.ChatRoom = (function() {

    /**
         * Properties of a ChatRoom.
         * @memberof proto
         * @interface IChatRoom
         * @property {proto.RegisteredUser|null} [peer] ChatRoom peer
         */

    /**
         * Constructs a new ChatRoom.
         * @memberof proto
         * @classdesc Represents a ChatRoom.
         * @implements IChatRoom
         * @constructor
         * @param {proto.IChatRoom=} [properties] Properties to set
         */
    function ChatRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatRoom peer.
         * @member {proto.RegisteredUser|null|undefined} peer
         * @memberof proto.ChatRoom
         * @instance
         */
    ChatRoom.prototype.peer = null;

    /**
         * Creates a new ChatRoom instance using the specified properties.
         * @function create
         * @memberof proto.ChatRoom
         * @static
         * @param {proto.IChatRoom=} [properties] Properties to set
         * @returns {proto.ChatRoom} ChatRoom instance
         */
    ChatRoom.create = function create(properties) {
      return new ChatRoom(properties);
    };

    /**
         * Encodes the specified ChatRoom message. Does not implicitly {@link proto.ChatRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatRoom
         * @static
         * @param {proto.ChatRoom} message ChatRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.peer != null && message.hasOwnProperty('peer')) {$root.proto.RegisteredUser.encode(message.peer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatRoom} ChatRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.peer = $root.proto.RegisteredUser.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatRoom message.
         * @function verify
         * @memberof proto.ChatRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.peer != null && message.hasOwnProperty('peer')) {
        let error = $root.proto.RegisteredUser.verify(message.peer);
        if (error) {return 'peer.' + error;}
      }
      return null;
    };

    return ChatRoom;
  })();

  proto.GroupRoom = (function() {

    /**
         * Properties of a GroupRoom.
         * @memberof proto
         * @interface IGroupRoom
         * @property {proto.GroupRoom.Type|null} [type] GroupRoom type
         * @property {proto.GroupRoom.Role|null} [role] GroupRoom role
         * @property {number|null} [participantsCount] GroupRoom participantsCount
         * @property {string|null} [participantsCountLabel] GroupRoom participantsCountLabel
         * @property {number|null} [participantsCountLimit] GroupRoom participantsCountLimit
         * @property {string|null} [participantsCountLimitLabel] GroupRoom participantsCountLimitLabel
         * @property {string|null} [description] GroupRoom description
         * @property {number|null} [avatarCount] GroupRoom avatarCount
         * @property {proto.Avatar|null} [avatar] GroupRoom avatar
         * @property {proto.GroupRoom.PrivateExtra|null} [privateExtra] GroupRoom privateExtra
         * @property {proto.GroupRoom.PublicExtra|null} [publicExtra] GroupRoom publicExtra
         */

    /**
         * Constructs a new GroupRoom.
         * @memberof proto
         * @classdesc Represents a GroupRoom.
         * @implements IGroupRoom
         * @constructor
         * @param {proto.IGroupRoom=} [properties] Properties to set
         */
    function GroupRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupRoom type.
         * @member {proto.GroupRoom.Type} type
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.type = 0;

    /**
         * GroupRoom role.
         * @member {proto.GroupRoom.Role} role
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.role = 0;

    /**
         * GroupRoom participantsCount.
         * @member {number} participantsCount
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.participantsCount = 0;

    /**
         * GroupRoom participantsCountLabel.
         * @member {string} participantsCountLabel
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.participantsCountLabel = '';

    /**
         * GroupRoom participantsCountLimit.
         * @member {number} participantsCountLimit
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.participantsCountLimit = 0;

    /**
         * GroupRoom participantsCountLimitLabel.
         * @member {string} participantsCountLimitLabel
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.participantsCountLimitLabel = '';

    /**
         * GroupRoom description.
         * @member {string} description
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.description = '';

    /**
         * GroupRoom avatarCount.
         * @member {number} avatarCount
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.avatarCount = 0;

    /**
         * GroupRoom avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.avatar = null;

    /**
         * GroupRoom privateExtra.
         * @member {proto.GroupRoom.PrivateExtra|null|undefined} privateExtra
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.privateExtra = null;

    /**
         * GroupRoom publicExtra.
         * @member {proto.GroupRoom.PublicExtra|null|undefined} publicExtra
         * @memberof proto.GroupRoom
         * @instance
         */
    GroupRoom.prototype.publicExtra = null;

    /**
         * Creates a new GroupRoom instance using the specified properties.
         * @function create
         * @memberof proto.GroupRoom
         * @static
         * @param {proto.IGroupRoom=} [properties] Properties to set
         * @returns {proto.GroupRoom} GroupRoom instance
         */
    GroupRoom.create = function create(properties) {
      return new GroupRoom(properties);
    };

    /**
         * Encodes the specified GroupRoom message. Does not implicitly {@link proto.GroupRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupRoom
         * @static
         * @param {proto.GroupRoom} message GroupRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);}
      if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);}
      if (message.participantsCount != null && message.hasOwnProperty('participantsCount')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.participantsCount);}
      if (message.participantsCountLabel != null && message.hasOwnProperty('participantsCountLabel')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.participantsCountLabel);}
      if (message.participantsCountLimit != null && message.hasOwnProperty('participantsCountLimit')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.participantsCountLimit);}
      if (message.participantsCountLimitLabel != null && message.hasOwnProperty('participantsCountLimitLabel')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.participantsCountLimitLabel);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);}
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.avatarCount);}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.privateExtra != null && message.hasOwnProperty('privateExtra')) {$root.proto.GroupRoom.PrivateExtra.encode(message.privateExtra, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();}
      if (message.publicExtra != null && message.hasOwnProperty('publicExtra')) {$root.proto.GroupRoom.PublicExtra.encode(message.publicExtra, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupRoom} GroupRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.type = reader.int32();
            break;
          case 2:
            message.role = reader.int32();
            break;
          case 3:
            message.participantsCount = reader.uint32();
            break;
          case 4:
            message.participantsCountLabel = reader.string();
            break;
          case 5:
            message.participantsCountLimit = reader.uint32();
            break;
          case 6:
            message.participantsCountLimitLabel = reader.string();
            break;
          case 7:
            message.description = reader.string();
            break;
          case 8:
            message.avatarCount = reader.uint32();
            break;
          case 9:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          case 10:
            message.privateExtra = $root.proto.GroupRoom.PrivateExtra.decode(reader, reader.uint32());
            break;
          case 11:
            message.publicExtra = $root.proto.GroupRoom.PublicExtra.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupRoom message.
         * @function verify
         * @memberof proto.GroupRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.role != null && message.hasOwnProperty('role')) {
        switch (message.role) {
          default:
            return 'role: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.participantsCount != null && message.hasOwnProperty('participantsCount')) {
        if (!$util.isInteger(message.participantsCount)) {return 'participantsCount: integer expected';}
      }
      if (message.participantsCountLabel != null && message.hasOwnProperty('participantsCountLabel')) {
        if (!$util.isString(message.participantsCountLabel)) {return 'participantsCountLabel: string expected';}
      }
      if (message.participantsCountLimit != null && message.hasOwnProperty('participantsCountLimit')) {
        if (!$util.isInteger(message.participantsCountLimit)) {return 'participantsCountLimit: integer expected';}
      }
      if (message.participantsCountLimitLabel != null && message.hasOwnProperty('participantsCountLimitLabel')) {
        if (!$util.isString(message.participantsCountLimitLabel)) {return 'participantsCountLimitLabel: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {
        if (!$util.isInteger(message.avatarCount)) {return 'avatarCount: integer expected';}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      if (message.privateExtra != null && message.hasOwnProperty('privateExtra')) {
        let error = $root.proto.GroupRoom.PrivateExtra.verify(message.privateExtra);
        if (error) {return 'privateExtra.' + error;}
      }
      if (message.publicExtra != null && message.hasOwnProperty('publicExtra')) {
        let error = $root.proto.GroupRoom.PublicExtra.verify(message.publicExtra);
        if (error) {return 'publicExtra.' + error;}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.GroupRoom.Type
         * @enum {string}
         * @property {number} PRIVATE_ROOM=0 PRIVATE_ROOM value
         * @property {number} PUBLIC_ROOM=1 PUBLIC_ROOM value
         */
    GroupRoom.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'PRIVATE_ROOM'] = 0;
      values[valuesById[1] = 'PUBLIC_ROOM'] = 1;
      return values;
    })();

    /**
         * Role enum.
         * @name proto.GroupRoom.Role
         * @enum {string}
         * @property {number} MEMBER=0 MEMBER value
         * @property {number} MODERATOR=1 MODERATOR value
         * @property {number} ADMIN=2 ADMIN value
         * @property {number} OWNER=3 OWNER value
         */
    GroupRoom.Role = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'MEMBER'] = 0;
      values[valuesById[1] = 'MODERATOR'] = 1;
      values[valuesById[2] = 'ADMIN'] = 2;
      values[valuesById[3] = 'OWNER'] = 3;
      return values;
    })();

    GroupRoom.PrivateExtra = (function() {

      /**
             * Properties of a PrivateExtra.
             * @memberof proto.GroupRoom
             * @interface IPrivateExtra
             * @property {string|null} [inviteLink] PrivateExtra inviteLink
             * @property {string|null} [inviteToken] PrivateExtra inviteToken
             */

      /**
             * Constructs a new PrivateExtra.
             * @memberof proto.GroupRoom
             * @classdesc Represents a PrivateExtra.
             * @implements IPrivateExtra
             * @constructor
             * @param {proto.GroupRoom.IPrivateExtra=} [properties] Properties to set
             */
      function PrivateExtra(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * PrivateExtra inviteLink.
             * @member {string} inviteLink
             * @memberof proto.GroupRoom.PrivateExtra
             * @instance
             */
      PrivateExtra.prototype.inviteLink = '';

      /**
             * PrivateExtra inviteToken.
             * @member {string} inviteToken
             * @memberof proto.GroupRoom.PrivateExtra
             * @instance
             */
      PrivateExtra.prototype.inviteToken = '';

      /**
             * Creates a new PrivateExtra instance using the specified properties.
             * @function create
             * @memberof proto.GroupRoom.PrivateExtra
             * @static
             * @param {proto.GroupRoom.IPrivateExtra=} [properties] Properties to set
             * @returns {proto.GroupRoom.PrivateExtra} PrivateExtra instance
             */
      PrivateExtra.create = function create(properties) {
        return new PrivateExtra(properties);
      };

      /**
             * Encodes the specified PrivateExtra message. Does not implicitly {@link proto.GroupRoom.PrivateExtra.verify|verify} messages.
             * @function encode
             * @memberof proto.GroupRoom.PrivateExtra
             * @static
             * @param {proto.GroupRoom.PrivateExtra} message PrivateExtra message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      PrivateExtra.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.inviteLink);}
        if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteToken);}
        return writer;
      };

      /**
             * Decodes a PrivateExtra message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GroupRoom.PrivateExtra
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GroupRoom.PrivateExtra} PrivateExtra
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      PrivateExtra.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRoom.PrivateExtra();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inviteLink = reader.string();
              break;
            case 2:
              message.inviteToken = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a PrivateExtra message.
             * @function verify
             * @memberof proto.GroupRoom.PrivateExtra
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      PrivateExtra.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
          if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
        }
        if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
          if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
        }
        return null;
      };

      return PrivateExtra;
    })();

    GroupRoom.PublicExtra = (function() {

      /**
             * Properties of a PublicExtra.
             * @memberof proto.GroupRoom
             * @interface IPublicExtra
             * @property {string|null} [username] PublicExtra username
             */

      /**
             * Constructs a new PublicExtra.
             * @memberof proto.GroupRoom
             * @classdesc Represents a PublicExtra.
             * @implements IPublicExtra
             * @constructor
             * @param {proto.GroupRoom.IPublicExtra=} [properties] Properties to set
             */
      function PublicExtra(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * PublicExtra username.
             * @member {string} username
             * @memberof proto.GroupRoom.PublicExtra
             * @instance
             */
      PublicExtra.prototype.username = '';

      /**
             * Creates a new PublicExtra instance using the specified properties.
             * @function create
             * @memberof proto.GroupRoom.PublicExtra
             * @static
             * @param {proto.GroupRoom.IPublicExtra=} [properties] Properties to set
             * @returns {proto.GroupRoom.PublicExtra} PublicExtra instance
             */
      PublicExtra.create = function create(properties) {
        return new PublicExtra(properties);
      };

      /**
             * Encodes the specified PublicExtra message. Does not implicitly {@link proto.GroupRoom.PublicExtra.verify|verify} messages.
             * @function encode
             * @memberof proto.GroupRoom.PublicExtra
             * @static
             * @param {proto.GroupRoom.PublicExtra} message PublicExtra message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      PublicExtra.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);}
        return writer;
      };

      /**
             * Decodes a PublicExtra message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GroupRoom.PublicExtra
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GroupRoom.PublicExtra} PublicExtra
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      PublicExtra.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRoom.PublicExtra();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.username = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a PublicExtra message.
             * @function verify
             * @memberof proto.GroupRoom.PublicExtra
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      PublicExtra.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.username != null && message.hasOwnProperty('username')) {
          if (!$util.isString(message.username)) {return 'username: string expected';}
        }
        return null;
      };

      return PublicExtra;
    })();

    return GroupRoom;
  })();

  proto.ChannelRoom = (function() {

    /**
         * Properties of a ChannelRoom.
         * @memberof proto
         * @interface IChannelRoom
         * @property {proto.ChannelRoom.Type|null} [type] ChannelRoom type
         * @property {proto.ChannelRoom.Role|null} [role] ChannelRoom role
         * @property {number|null} [participantsCount] ChannelRoom participantsCount
         * @property {string|null} [participantsCountLabel] ChannelRoom participantsCountLabel
         * @property {string|null} [description] ChannelRoom description
         * @property {number|null} [avatarCount] ChannelRoom avatarCount
         * @property {proto.Avatar|null} [avatar] ChannelRoom avatar
         * @property {proto.ChannelRoom.PrivateExtra|null} [privateExtra] ChannelRoom privateExtra
         * @property {proto.ChannelRoom.PublicExtra|null} [publicExtra] ChannelRoom publicExtra
         * @property {boolean|null} [signature] ChannelRoom signature
         * @property {Long|null} [seenId] ChannelRoom seenId
         * @property {boolean|null} [verified] ChannelRoom verified
         * @property {boolean|null} [reactionStatus] ChannelRoom reactionStatus
         */

    /**
         * Constructs a new ChannelRoom.
         * @memberof proto
         * @classdesc Represents a ChannelRoom.
         * @implements IChannelRoom
         * @constructor
         * @param {proto.IChannelRoom=} [properties] Properties to set
         */
    function ChannelRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelRoom type.
         * @member {proto.ChannelRoom.Type} type
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.type = 0;

    /**
         * ChannelRoom role.
         * @member {proto.ChannelRoom.Role} role
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.role = 0;

    /**
         * ChannelRoom participantsCount.
         * @member {number} participantsCount
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.participantsCount = 0;

    /**
         * ChannelRoom participantsCountLabel.
         * @member {string} participantsCountLabel
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.participantsCountLabel = '';

    /**
         * ChannelRoom description.
         * @member {string} description
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.description = '';

    /**
         * ChannelRoom avatarCount.
         * @member {number} avatarCount
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.avatarCount = 0;

    /**
         * ChannelRoom avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.avatar = null;

    /**
         * ChannelRoom privateExtra.
         * @member {proto.ChannelRoom.PrivateExtra|null|undefined} privateExtra
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.privateExtra = null;

    /**
         * ChannelRoom publicExtra.
         * @member {proto.ChannelRoom.PublicExtra|null|undefined} publicExtra
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.publicExtra = null;

    /**
         * ChannelRoom signature.
         * @member {boolean} signature
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.signature = false;

    /**
         * ChannelRoom seenId.
         * @member {Long} seenId
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.seenId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelRoom verified.
         * @member {boolean} verified
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.verified = false;

    /**
         * ChannelRoom reactionStatus.
         * @member {boolean} reactionStatus
         * @memberof proto.ChannelRoom
         * @instance
         */
    ChannelRoom.prototype.reactionStatus = false;

    /**
         * Creates a new ChannelRoom instance using the specified properties.
         * @function create
         * @memberof proto.ChannelRoom
         * @static
         * @param {proto.IChannelRoom=} [properties] Properties to set
         * @returns {proto.ChannelRoom} ChannelRoom instance
         */
    ChannelRoom.create = function create(properties) {
      return new ChannelRoom(properties);
    };

    /**
         * Encodes the specified ChannelRoom message. Does not implicitly {@link proto.ChannelRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelRoom
         * @static
         * @param {proto.ChannelRoom} message ChannelRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);}
      if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);}
      if (message.participantsCount != null && message.hasOwnProperty('participantsCount')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.participantsCount);}
      if (message.participantsCountLabel != null && message.hasOwnProperty('participantsCountLabel')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.participantsCountLabel);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);}
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.avatarCount);}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.privateExtra != null && message.hasOwnProperty('privateExtra')) {$root.proto.ChannelRoom.PrivateExtra.encode(message.privateExtra, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();}
      if (message.publicExtra != null && message.hasOwnProperty('publicExtra')) {$root.proto.ChannelRoom.PublicExtra.encode(message.publicExtra, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.signature != null && message.hasOwnProperty('signature')) {writer.uint32(/* id 10, wireType 0 =*/80).bool(message.signature);}
      if (message.seenId != null && message.hasOwnProperty('seenId')) {writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.seenId);}
      if (message.verified != null && message.hasOwnProperty('verified')) {writer.uint32(/* id 12, wireType 0 =*/96).bool(message.verified);}
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {writer.uint32(/* id 13, wireType 0 =*/104).bool(message.reactionStatus);}
      return writer;
    };

    /**
         * Decodes a ChannelRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelRoom} ChannelRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.type = reader.int32();
            break;
          case 2:
            message.role = reader.int32();
            break;
          case 3:
            message.participantsCount = reader.uint32();
            break;
          case 4:
            message.participantsCountLabel = reader.string();
            break;
          case 5:
            message.description = reader.string();
            break;
          case 6:
            message.avatarCount = reader.uint32();
            break;
          case 7:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          case 8:
            message.privateExtra = $root.proto.ChannelRoom.PrivateExtra.decode(reader, reader.uint32());
            break;
          case 9:
            message.publicExtra = $root.proto.ChannelRoom.PublicExtra.decode(reader, reader.uint32());
            break;
          case 10:
            message.signature = reader.bool();
            break;
          case 11:
            message.seenId = reader.uint64();
            break;
          case 12:
            message.verified = reader.bool();
            break;
          case 13:
            message.reactionStatus = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelRoom message.
         * @function verify
         * @memberof proto.ChannelRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.role != null && message.hasOwnProperty('role')) {
        switch (message.role) {
          default:
            return 'role: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.participantsCount != null && message.hasOwnProperty('participantsCount')) {
        if (!$util.isInteger(message.participantsCount)) {return 'participantsCount: integer expected';}
      }
      if (message.participantsCountLabel != null && message.hasOwnProperty('participantsCountLabel')) {
        if (!$util.isString(message.participantsCountLabel)) {return 'participantsCountLabel: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      if (message.avatarCount != null && message.hasOwnProperty('avatarCount')) {
        if (!$util.isInteger(message.avatarCount)) {return 'avatarCount: integer expected';}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      if (message.privateExtra != null && message.hasOwnProperty('privateExtra')) {
        let error = $root.proto.ChannelRoom.PrivateExtra.verify(message.privateExtra);
        if (error) {return 'privateExtra.' + error;}
      }
      if (message.publicExtra != null && message.hasOwnProperty('publicExtra')) {
        let error = $root.proto.ChannelRoom.PublicExtra.verify(message.publicExtra);
        if (error) {return 'publicExtra.' + error;}
      }
      if (message.signature != null && message.hasOwnProperty('signature')) {
        if (typeof message.signature !== 'boolean') {return 'signature: boolean expected';}
      }
      if (message.seenId != null && message.hasOwnProperty('seenId')) {
        if (!$util.isInteger(message.seenId) && !(message.seenId && $util.isInteger(message.seenId.low) && $util.isInteger(message.seenId.high))) {return 'seenId: integer|Long expected';}
      }
      if (message.verified != null && message.hasOwnProperty('verified')) {
        if (typeof message.verified !== 'boolean') {return 'verified: boolean expected';}
      }
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {
        if (typeof message.reactionStatus !== 'boolean') {return 'reactionStatus: boolean expected';}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.ChannelRoom.Type
         * @enum {string}
         * @property {number} PRIVATE_ROOM=0 PRIVATE_ROOM value
         * @property {number} PUBLIC_ROOM=1 PUBLIC_ROOM value
         */
    ChannelRoom.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'PRIVATE_ROOM'] = 0;
      values[valuesById[1] = 'PUBLIC_ROOM'] = 1;
      return values;
    })();

    /**
         * Role enum.
         * @name proto.ChannelRoom.Role
         * @enum {string}
         * @property {number} MEMBER=0 MEMBER value
         * @property {number} MODERATOR=1 MODERATOR value
         * @property {number} ADMIN=2 ADMIN value
         * @property {number} OWNER=3 OWNER value
         */
    ChannelRoom.Role = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'MEMBER'] = 0;
      values[valuesById[1] = 'MODERATOR'] = 1;
      values[valuesById[2] = 'ADMIN'] = 2;
      values[valuesById[3] = 'OWNER'] = 3;
      return values;
    })();

    ChannelRoom.PrivateExtra = (function() {

      /**
             * Properties of a PrivateExtra.
             * @memberof proto.ChannelRoom
             * @interface IPrivateExtra
             * @property {string|null} [inviteLink] PrivateExtra inviteLink
             * @property {string|null} [inviteToken] PrivateExtra inviteToken
             */

      /**
             * Constructs a new PrivateExtra.
             * @memberof proto.ChannelRoom
             * @classdesc Represents a PrivateExtra.
             * @implements IPrivateExtra
             * @constructor
             * @param {proto.ChannelRoom.IPrivateExtra=} [properties] Properties to set
             */
      function PrivateExtra(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * PrivateExtra inviteLink.
             * @member {string} inviteLink
             * @memberof proto.ChannelRoom.PrivateExtra
             * @instance
             */
      PrivateExtra.prototype.inviteLink = '';

      /**
             * PrivateExtra inviteToken.
             * @member {string} inviteToken
             * @memberof proto.ChannelRoom.PrivateExtra
             * @instance
             */
      PrivateExtra.prototype.inviteToken = '';

      /**
             * Creates a new PrivateExtra instance using the specified properties.
             * @function create
             * @memberof proto.ChannelRoom.PrivateExtra
             * @static
             * @param {proto.ChannelRoom.IPrivateExtra=} [properties] Properties to set
             * @returns {proto.ChannelRoom.PrivateExtra} PrivateExtra instance
             */
      PrivateExtra.create = function create(properties) {
        return new PrivateExtra(properties);
      };

      /**
             * Encodes the specified PrivateExtra message. Does not implicitly {@link proto.ChannelRoom.PrivateExtra.verify|verify} messages.
             * @function encode
             * @memberof proto.ChannelRoom.PrivateExtra
             * @static
             * @param {proto.ChannelRoom.PrivateExtra} message PrivateExtra message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      PrivateExtra.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.inviteLink);}
        if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteToken);}
        return writer;
      };

      /**
             * Decodes a PrivateExtra message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ChannelRoom.PrivateExtra
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ChannelRoom.PrivateExtra} PrivateExtra
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      PrivateExtra.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRoom.PrivateExtra();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inviteLink = reader.string();
              break;
            case 2:
              message.inviteToken = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a PrivateExtra message.
             * @function verify
             * @memberof proto.ChannelRoom.PrivateExtra
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      PrivateExtra.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
          if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
        }
        if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
          if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
        }
        return null;
      };

      return PrivateExtra;
    })();

    ChannelRoom.PublicExtra = (function() {

      /**
             * Properties of a PublicExtra.
             * @memberof proto.ChannelRoom
             * @interface IPublicExtra
             * @property {string|null} [username] PublicExtra username
             */

      /**
             * Constructs a new PublicExtra.
             * @memberof proto.ChannelRoom
             * @classdesc Represents a PublicExtra.
             * @implements IPublicExtra
             * @constructor
             * @param {proto.ChannelRoom.IPublicExtra=} [properties] Properties to set
             */
      function PublicExtra(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * PublicExtra username.
             * @member {string} username
             * @memberof proto.ChannelRoom.PublicExtra
             * @instance
             */
      PublicExtra.prototype.username = '';

      /**
             * Creates a new PublicExtra instance using the specified properties.
             * @function create
             * @memberof proto.ChannelRoom.PublicExtra
             * @static
             * @param {proto.ChannelRoom.IPublicExtra=} [properties] Properties to set
             * @returns {proto.ChannelRoom.PublicExtra} PublicExtra instance
             */
      PublicExtra.create = function create(properties) {
        return new PublicExtra(properties);
      };

      /**
             * Encodes the specified PublicExtra message. Does not implicitly {@link proto.ChannelRoom.PublicExtra.verify|verify} messages.
             * @function encode
             * @memberof proto.ChannelRoom.PublicExtra
             * @static
             * @param {proto.ChannelRoom.PublicExtra} message PublicExtra message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      PublicExtra.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);}
        return writer;
      };

      /**
             * Decodes a PublicExtra message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ChannelRoom.PublicExtra
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ChannelRoom.PublicExtra} PublicExtra
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      PublicExtra.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRoom.PublicExtra();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.username = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a PublicExtra message.
             * @function verify
             * @memberof proto.ChannelRoom.PublicExtra
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      PublicExtra.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.username != null && message.hasOwnProperty('username')) {
          if (!$util.isString(message.username)) {return 'username: string expected';}
        }
        return null;
      };

      return PublicExtra;
    })();

    return ChannelRoom;
  })();

  proto.Thumbnail = (function() {

    /**
         * Properties of a Thumbnail.
         * @memberof proto
         * @interface IThumbnail
         * @property {Long|null} [size] Thumbnail size
         * @property {number|null} [width] Thumbnail width
         * @property {number|null} [height] Thumbnail height
         * @property {string|null} [cacheId] Thumbnail cacheId
         * @property {string|null} [name] Thumbnail name
         * @property {string|null} [mime] Thumbnail mime
         */

    /**
         * Constructs a new Thumbnail.
         * @memberof proto
         * @classdesc Represents a Thumbnail.
         * @implements IThumbnail
         * @constructor
         * @param {proto.IThumbnail=} [properties] Properties to set
         */
    function Thumbnail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Thumbnail size.
         * @member {Long} size
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * Thumbnail width.
         * @member {number} width
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.width = 0;

    /**
         * Thumbnail height.
         * @member {number} height
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.height = 0;

    /**
         * Thumbnail cacheId.
         * @member {string} cacheId
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.cacheId = '';

    /**
         * Thumbnail name.
         * @member {string} name
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.name = '';

    /**
         * Thumbnail mime.
         * @member {string} mime
         * @memberof proto.Thumbnail
         * @instance
         */
    Thumbnail.prototype.mime = '';

    /**
         * Creates a new Thumbnail instance using the specified properties.
         * @function create
         * @memberof proto.Thumbnail
         * @static
         * @param {proto.IThumbnail=} [properties] Properties to set
         * @returns {proto.Thumbnail} Thumbnail instance
         */
    Thumbnail.create = function create(properties) {
      return new Thumbnail(properties);
    };

    /**
         * Encodes the specified Thumbnail message. Does not implicitly {@link proto.Thumbnail.verify|verify} messages.
         * @function encode
         * @memberof proto.Thumbnail
         * @static
         * @param {proto.Thumbnail} message Thumbnail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Thumbnail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.size != null && message.hasOwnProperty('size')) {writer.uint32(/* id 1, wireType 0 =*/8).int64(message.size);}
      if (message.width != null && message.hasOwnProperty('width')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.width);}
      if (message.height != null && message.hasOwnProperty('height')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.height);}
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.cacheId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);}
      if (message.mime != null && message.hasOwnProperty('mime')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.mime);}
      return writer;
    };

    /**
         * Decodes a Thumbnail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Thumbnail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Thumbnail} Thumbnail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Thumbnail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Thumbnail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.size = reader.int64();
            break;
          case 2:
            message.width = reader.int32();
            break;
          case 3:
            message.height = reader.int32();
            break;
          case 4:
            message.cacheId = reader.string();
            break;
          case 5:
            message.name = reader.string();
            break;
          case 6:
            message.mime = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Thumbnail message.
         * @function verify
         * @memberof proto.Thumbnail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Thumbnail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.size != null && message.hasOwnProperty('size')) {
        if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high))) {return 'size: integer|Long expected';}
      }
      if (message.width != null && message.hasOwnProperty('width')) {
        if (!$util.isInteger(message.width)) {return 'width: integer expected';}
      }
      if (message.height != null && message.hasOwnProperty('height')) {
        if (!$util.isInteger(message.height)) {return 'height: integer expected';}
      }
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
        if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.mime != null && message.hasOwnProperty('mime')) {
        if (!$util.isString(message.mime)) {return 'mime: string expected';}
      }
      return null;
    };

    return Thumbnail;
  })();

  proto.File = (function() {

    /**
         * Properties of a File.
         * @memberof proto
         * @interface IFile
         * @property {string|null} [token] File token
         * @property {string|null} [name] File name
         * @property {Long|null} [size] File size
         * @property {proto.Thumbnail|null} [largeThumbnail] File largeThumbnail
         * @property {proto.Thumbnail|null} [smallThumbnail] File smallThumbnail
         * @property {proto.Thumbnail|null} [waveformThumbnail] File waveformThumbnail
         * @property {number|null} [width] File width
         * @property {number|null} [height] File height
         * @property {number|null} [duration] File duration
         * @property {string|null} [cacheId] File cacheId
         * @property {string|null} [mime] File mime
         * @property {string|null} [publicUrl] File publicUrl
         */

    /**
         * Constructs a new File.
         * @memberof proto
         * @classdesc Represents a File.
         * @implements IFile
         * @constructor
         * @param {proto.IFile=} [properties] Properties to set
         */
    function File(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * File token.
         * @member {string} token
         * @memberof proto.File
         * @instance
         */
    File.prototype.token = '';

    /**
         * File name.
         * @member {string} name
         * @memberof proto.File
         * @instance
         */
    File.prototype.name = '';

    /**
         * File size.
         * @member {Long} size
         * @memberof proto.File
         * @instance
         */
    File.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * File largeThumbnail.
         * @member {proto.Thumbnail|null|undefined} largeThumbnail
         * @memberof proto.File
         * @instance
         */
    File.prototype.largeThumbnail = null;

    /**
         * File smallThumbnail.
         * @member {proto.Thumbnail|null|undefined} smallThumbnail
         * @memberof proto.File
         * @instance
         */
    File.prototype.smallThumbnail = null;

    /**
         * File waveformThumbnail.
         * @member {proto.Thumbnail|null|undefined} waveformThumbnail
         * @memberof proto.File
         * @instance
         */
    File.prototype.waveformThumbnail = null;

    /**
         * File width.
         * @member {number} width
         * @memberof proto.File
         * @instance
         */
    File.prototype.width = 0;

    /**
         * File height.
         * @member {number} height
         * @memberof proto.File
         * @instance
         */
    File.prototype.height = 0;

    /**
         * File duration.
         * @member {number} duration
         * @memberof proto.File
         * @instance
         */
    File.prototype.duration = 0;

    /**
         * File cacheId.
         * @member {string} cacheId
         * @memberof proto.File
         * @instance
         */
    File.prototype.cacheId = '';

    /**
         * File mime.
         * @member {string} mime
         * @memberof proto.File
         * @instance
         */
    File.prototype.mime = '';

    /**
         * File publicUrl.
         * @member {string} publicUrl
         * @memberof proto.File
         * @instance
         */
    File.prototype.publicUrl = '';

    /**
         * Creates a new File instance using the specified properties.
         * @function create
         * @memberof proto.File
         * @static
         * @param {proto.IFile=} [properties] Properties to set
         * @returns {proto.File} File instance
         */
    File.create = function create(properties) {
      return new File(properties);
    };

    /**
         * Encodes the specified File message. Does not implicitly {@link proto.File.verify|verify} messages.
         * @function encode
         * @memberof proto.File
         * @static
         * @param {proto.File} message File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    File.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);}
      if (message.size != null && message.hasOwnProperty('size')) {writer.uint32(/* id 3, wireType 0 =*/24).int64(message.size);}
      if (message.largeThumbnail != null && message.hasOwnProperty('largeThumbnail')) {$root.proto.Thumbnail.encode(message.largeThumbnail, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
      if (message.smallThumbnail != null && message.hasOwnProperty('smallThumbnail')) {$root.proto.Thumbnail.encode(message.smallThumbnail, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();}
      if (message.waveformThumbnail != null && message.hasOwnProperty('waveformThumbnail')) {$root.proto.Thumbnail.encode(message.waveformThumbnail, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();}
      if (message.width != null && message.hasOwnProperty('width')) {writer.uint32(/* id 7, wireType 0 =*/56).int32(message.width);}
      if (message.height != null && message.hasOwnProperty('height')) {writer.uint32(/* id 8, wireType 0 =*/64).int32(message.height);}
      if (message.duration != null && message.hasOwnProperty('duration')) {writer.uint32(/* id 9, wireType 1 =*/73).double(message.duration);}
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 10, wireType 2 =*/82).string(message.cacheId);}
      if (message.mime != null && message.hasOwnProperty('mime')) {writer.uint32(/* id 11, wireType 2 =*/90).string(message.mime);}
      if (message.publicUrl != null && message.hasOwnProperty('publicUrl')) {writer.uint32(/* id 12, wireType 2 =*/98).string(message.publicUrl);}
      return writer;
    };

    /**
         * Decodes a File message from the specified reader or buffer.
         * @function decode
         * @memberof proto.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    File.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.File();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.token = reader.string();
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.size = reader.int64();
            break;
          case 4:
            message.largeThumbnail = $root.proto.Thumbnail.decode(reader, reader.uint32());
            break;
          case 5:
            message.smallThumbnail = $root.proto.Thumbnail.decode(reader, reader.uint32());
            break;
          case 6:
            message.waveformThumbnail = $root.proto.Thumbnail.decode(reader, reader.uint32());
            break;
          case 7:
            message.width = reader.int32();
            break;
          case 8:
            message.height = reader.int32();
            break;
          case 9:
            message.duration = reader.double();
            break;
          case 10:
            message.cacheId = reader.string();
            break;
          case 11:
            message.mime = reader.string();
            break;
          case 12:
            message.publicUrl = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a File message.
         * @function verify
         * @memberof proto.File
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    File.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.size != null && message.hasOwnProperty('size')) {
        if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high))) {return 'size: integer|Long expected';}
      }
      if (message.largeThumbnail != null && message.hasOwnProperty('largeThumbnail')) {
        let error = $root.proto.Thumbnail.verify(message.largeThumbnail);
        if (error) {return 'largeThumbnail.' + error;}
      }
      if (message.smallThumbnail != null && message.hasOwnProperty('smallThumbnail')) {
        let error = $root.proto.Thumbnail.verify(message.smallThumbnail);
        if (error) {return 'smallThumbnail.' + error;}
      }
      if (message.waveformThumbnail != null && message.hasOwnProperty('waveformThumbnail')) {
        let error = $root.proto.Thumbnail.verify(message.waveformThumbnail);
        if (error) {return 'waveformThumbnail.' + error;}
      }
      if (message.width != null && message.hasOwnProperty('width')) {
        if (!$util.isInteger(message.width)) {return 'width: integer expected';}
      }
      if (message.height != null && message.hasOwnProperty('height')) {
        if (!$util.isInteger(message.height)) {return 'height: integer expected';}
      }
      if (message.duration != null && message.hasOwnProperty('duration')) {
        if (typeof message.duration !== 'number') {return 'duration: number expected';}
      }
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
        if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
      }
      if (message.mime != null && message.hasOwnProperty('mime')) {
        if (!$util.isString(message.mime)) {return 'mime: string expected';}
      }
      if (message.publicUrl != null && message.hasOwnProperty('publicUrl')) {
        if (!$util.isString(message.publicUrl)) {return 'publicUrl: string expected';}
      }
      return null;
    };

    return File;
  })();

  /**
     * PrivacyType enum.
     * @name proto.PrivacyType
     * @enum {string}
     * @property {number} USER_STATUS=0 USER_STATUS value
     * @property {number} AVATAR=1 AVATAR value
     * @property {number} GROUP_INVITE=2 GROUP_INVITE value
     * @property {number} CHANNEL_INVITE=3 CHANNEL_INVITE value
     * @property {number} VOICE_CALLING=4 VOICE_CALLING value
     * @property {number} VIDEO_CALLING=5 VIDEO_CALLING value
     * @property {number} SCREEN_SHARING=6 SCREEN_SHARING value
     * @property {number} SECRET_CHAT=7 SECRET_CHAT value
     */
  proto.PrivacyType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'USER_STATUS'] = 0;
    values[valuesById[1] = 'AVATAR'] = 1;
    values[valuesById[2] = 'GROUP_INVITE'] = 2;
    values[valuesById[3] = 'CHANNEL_INVITE'] = 3;
    values[valuesById[4] = 'VOICE_CALLING'] = 4;
    values[valuesById[5] = 'VIDEO_CALLING'] = 5;
    values[valuesById[6] = 'SCREEN_SHARING'] = 6;
    values[valuesById[7] = 'SECRET_CHAT'] = 7;
    return values;
  })();

  /**
     * PrivacyLevel enum.
     * @name proto.PrivacyLevel
     * @enum {string}
     * @property {number} ALLOW_ALL=0 ALLOW_ALL value
     * @property {number} DENY_ALL=1 DENY_ALL value
     * @property {number} ALLOW_CONTACTS=2 ALLOW_CONTACTS value
     */
  proto.PrivacyLevel = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'ALLOW_ALL'] = 0;
    values[valuesById[1] = 'DENY_ALL'] = 1;
    values[valuesById[2] = 'ALLOW_CONTACTS'] = 2;
    return values;
  })();

  proto.Wallpaper = (function() {

    /**
         * Properties of a Wallpaper.
         * @memberof proto
         * @interface IWallpaper
         * @property {proto.File|null} [file] Wallpaper file
         * @property {string|null} [color] Wallpaper color
         */

    /**
         * Constructs a new Wallpaper.
         * @memberof proto
         * @classdesc Represents a Wallpaper.
         * @implements IWallpaper
         * @constructor
         * @param {proto.IWallpaper=} [properties] Properties to set
         */
    function Wallpaper(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Wallpaper file.
         * @member {proto.File|null|undefined} file
         * @memberof proto.Wallpaper
         * @instance
         */
    Wallpaper.prototype.file = null;

    /**
         * Wallpaper color.
         * @member {string} color
         * @memberof proto.Wallpaper
         * @instance
         */
    Wallpaper.prototype.color = '';

    /**
         * Creates a new Wallpaper instance using the specified properties.
         * @function create
         * @memberof proto.Wallpaper
         * @static
         * @param {proto.IWallpaper=} [properties] Properties to set
         * @returns {proto.Wallpaper} Wallpaper instance
         */
    Wallpaper.create = function create(properties) {
      return new Wallpaper(properties);
    };

    /**
         * Encodes the specified Wallpaper message. Does not implicitly {@link proto.Wallpaper.verify|verify} messages.
         * @function encode
         * @memberof proto.Wallpaper
         * @static
         * @param {proto.Wallpaper} message Wallpaper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Wallpaper.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.file != null && message.hasOwnProperty('file')) {$root.proto.File.encode(message.file, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.color != null && message.hasOwnProperty('color')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.color);}
      return writer;
    };

    /**
         * Decodes a Wallpaper message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Wallpaper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Wallpaper} Wallpaper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Wallpaper.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Wallpaper();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.file = $root.proto.File.decode(reader, reader.uint32());
            break;
          case 2:
            message.color = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Wallpaper message.
         * @function verify
         * @memberof proto.Wallpaper
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Wallpaper.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.file != null && message.hasOwnProperty('file')) {
        let error = $root.proto.File.verify(message.file);
        if (error) {return 'file.' + error;}
      }
      if (message.color != null && message.hasOwnProperty('color')) {
        if (!$util.isString(message.color)) {return 'color: string expected';}
      }
      return null;
    };

    return Wallpaper;
  })();

  proto.Pagination = (function() {

    /**
         * Properties of a Pagination.
         * @memberof proto
         * @interface IPagination
         * @property {number|null} [offset] Pagination offset
         * @property {number|null} [limit] Pagination limit
         */

    /**
         * Constructs a new Pagination.
         * @memberof proto
         * @classdesc Represents a Pagination.
         * @implements IPagination
         * @constructor
         * @param {proto.IPagination=} [properties] Properties to set
         */
    function Pagination(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Pagination offset.
         * @member {number} offset
         * @memberof proto.Pagination
         * @instance
         */
    Pagination.prototype.offset = 0;

    /**
         * Pagination limit.
         * @member {number} limit
         * @memberof proto.Pagination
         * @instance
         */
    Pagination.prototype.limit = 0;

    /**
         * Creates a new Pagination instance using the specified properties.
         * @function create
         * @memberof proto.Pagination
         * @static
         * @param {proto.IPagination=} [properties] Properties to set
         * @returns {proto.Pagination} Pagination instance
         */
    Pagination.create = function create(properties) {
      return new Pagination(properties);
    };

    /**
         * Encodes the specified Pagination message. Does not implicitly {@link proto.Pagination.verify|verify} messages.
         * @function encode
         * @memberof proto.Pagination
         * @static
         * @param {proto.Pagination} message Pagination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Pagination.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.offset != null && message.hasOwnProperty('offset')) {writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.offset);}
      if (message.limit != null && message.hasOwnProperty('limit')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);}
      return writer;
    };

    /**
         * Decodes a Pagination message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Pagination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Pagination} Pagination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Pagination.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Pagination();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.offset = reader.uint32();
            break;
          case 2:
            message.limit = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Pagination message.
         * @function verify
         * @memberof proto.Pagination
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Pagination.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.offset != null && message.hasOwnProperty('offset')) {
        if (!$util.isInteger(message.offset)) {return 'offset: integer expected';}
      }
      if (message.limit != null && message.hasOwnProperty('limit')) {
        if (!$util.isInteger(message.limit)) {return 'limit: integer expected';}
      }
      return null;
    };

    return Pagination;
  })();

  proto.ChannelAddMessageReaction = (function() {

    /**
         * Properties of a ChannelAddMessageReaction.
         * @memberof proto
         * @interface IChannelAddMessageReaction
         * @property {proto.Request|null} [request] ChannelAddMessageReaction request
         * @property {Long|null} [roomId] ChannelAddMessageReaction roomId
         * @property {Long|null} [messageId] ChannelAddMessageReaction messageId
         * @property {proto.RoomMessageReaction|null} [reaction] ChannelAddMessageReaction reaction
         */

    /**
         * Constructs a new ChannelAddMessageReaction.
         * @memberof proto
         * @classdesc Represents a ChannelAddMessageReaction.
         * @implements IChannelAddMessageReaction
         * @constructor
         * @param {proto.IChannelAddMessageReaction=} [properties] Properties to set
         */
    function ChannelAddMessageReaction(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddMessageReaction request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAddMessageReaction
         * @instance
         */
    ChannelAddMessageReaction.prototype.request = null;

    /**
         * ChannelAddMessageReaction roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddMessageReaction
         * @instance
         */
    ChannelAddMessageReaction.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddMessageReaction messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelAddMessageReaction
         * @instance
         */
    ChannelAddMessageReaction.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddMessageReaction reaction.
         * @member {proto.RoomMessageReaction} reaction
         * @memberof proto.ChannelAddMessageReaction
         * @instance
         */
    ChannelAddMessageReaction.prototype.reaction = 0;

    /**
         * Creates a new ChannelAddMessageReaction instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddMessageReaction
         * @static
         * @param {proto.IChannelAddMessageReaction=} [properties] Properties to set
         * @returns {proto.ChannelAddMessageReaction} ChannelAddMessageReaction instance
         */
    ChannelAddMessageReaction.create = function create(properties) {
      return new ChannelAddMessageReaction(properties);
    };

    /**
         * Encodes the specified ChannelAddMessageReaction message. Does not implicitly {@link proto.ChannelAddMessageReaction.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddMessageReaction
         * @static
         * @param {proto.ChannelAddMessageReaction} message ChannelAddMessageReaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddMessageReaction.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.reaction != null && message.hasOwnProperty('reaction')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reaction);}
      return writer;
    };

    /**
         * Decodes a ChannelAddMessageReaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddMessageReaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddMessageReaction} ChannelAddMessageReaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddMessageReaction.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddMessageReaction();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.reaction = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddMessageReaction message.
         * @function verify
         * @memberof proto.ChannelAddMessageReaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddMessageReaction.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.reaction != null && message.hasOwnProperty('reaction')) {
        switch (message.reaction) {
          default:
            return 'reaction: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      return null;
    };

    return ChannelAddMessageReaction;
  })();

  proto.ChannelAddMessageReactionResponse = (function() {

    /**
         * Properties of a ChannelAddMessageReactionResponse.
         * @memberof proto
         * @interface IChannelAddMessageReactionResponse
         * @property {proto.Response|null} [response] ChannelAddMessageReactionResponse response
         * @property {string|null} [reactionCounterLabel] ChannelAddMessageReactionResponse reactionCounterLabel
         */

    /**
         * Constructs a new ChannelAddMessageReactionResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAddMessageReactionResponse.
         * @implements IChannelAddMessageReactionResponse
         * @constructor
         * @param {proto.IChannelAddMessageReactionResponse=} [properties] Properties to set
         */
    function ChannelAddMessageReactionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddMessageReactionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAddMessageReactionResponse
         * @instance
         */
    ChannelAddMessageReactionResponse.prototype.response = null;

    /**
         * ChannelAddMessageReactionResponse reactionCounterLabel.
         * @member {string} reactionCounterLabel
         * @memberof proto.ChannelAddMessageReactionResponse
         * @instance
         */
    ChannelAddMessageReactionResponse.prototype.reactionCounterLabel = '';

    /**
         * Creates a new ChannelAddMessageReactionResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddMessageReactionResponse
         * @static
         * @param {proto.IChannelAddMessageReactionResponse=} [properties] Properties to set
         * @returns {proto.ChannelAddMessageReactionResponse} ChannelAddMessageReactionResponse instance
         */
    ChannelAddMessageReactionResponse.create = function create(properties) {
      return new ChannelAddMessageReactionResponse(properties);
    };

    /**
         * Encodes the specified ChannelAddMessageReactionResponse message. Does not implicitly {@link proto.ChannelAddMessageReactionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddMessageReactionResponse
         * @static
         * @param {proto.ChannelAddMessageReactionResponse} message ChannelAddMessageReactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddMessageReactionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.reactionCounterLabel != null && message.hasOwnProperty('reactionCounterLabel')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.reactionCounterLabel);}
      return writer;
    };

    /**
         * Decodes a ChannelAddMessageReactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddMessageReactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddMessageReactionResponse} ChannelAddMessageReactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddMessageReactionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddMessageReactionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.reactionCounterLabel = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddMessageReactionResponse message.
         * @function verify
         * @memberof proto.ChannelAddMessageReactionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddMessageReactionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.reactionCounterLabel != null && message.hasOwnProperty('reactionCounterLabel')) {
        if (!$util.isString(message.reactionCounterLabel)) {return 'reactionCounterLabel: string expected';}
      }
      return null;
    };

    return ChannelAddMessageReactionResponse;
  })();

  proto.ChannelAddModerator = (function() {

    /**
         * Properties of a ChannelAddModerator.
         * @memberof proto
         * @interface IChannelAddModerator
         * @property {proto.Request|null} [request] ChannelAddModerator request
         * @property {Long|null} [roomId] ChannelAddModerator roomId
         * @property {Long|null} [memberId] ChannelAddModerator memberId
         */

    /**
         * Constructs a new ChannelAddModerator.
         * @memberof proto
         * @classdesc Represents a ChannelAddModerator.
         * @implements IChannelAddModerator
         * @constructor
         * @param {proto.IChannelAddModerator=} [properties] Properties to set
         */
    function ChannelAddModerator(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddModerator request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAddModerator
         * @instance
         */
    ChannelAddModerator.prototype.request = null;

    /**
         * ChannelAddModerator roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddModerator
         * @instance
         */
    ChannelAddModerator.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddModerator memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelAddModerator
         * @instance
         */
    ChannelAddModerator.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAddModerator instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddModerator
         * @static
         * @param {proto.IChannelAddModerator=} [properties] Properties to set
         * @returns {proto.ChannelAddModerator} ChannelAddModerator instance
         */
    ChannelAddModerator.create = function create(properties) {
      return new ChannelAddModerator(properties);
    };

    /**
         * Encodes the specified ChannelAddModerator message. Does not implicitly {@link proto.ChannelAddModerator.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddModerator
         * @static
         * @param {proto.ChannelAddModerator} message ChannelAddModerator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddModerator.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelAddModerator message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddModerator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddModerator} ChannelAddModerator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddModerator.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddModerator();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddModerator message.
         * @function verify
         * @memberof proto.ChannelAddModerator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddModerator.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAddModerator;
  })();

  proto.ChannelAddModeratorResponse = (function() {

    /**
         * Properties of a ChannelAddModeratorResponse.
         * @memberof proto
         * @interface IChannelAddModeratorResponse
         * @property {proto.Response|null} [response] ChannelAddModeratorResponse response
         * @property {Long|null} [roomId] ChannelAddModeratorResponse roomId
         * @property {Long|null} [memberId] ChannelAddModeratorResponse memberId
         */

    /**
         * Constructs a new ChannelAddModeratorResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAddModeratorResponse.
         * @implements IChannelAddModeratorResponse
         * @constructor
         * @param {proto.IChannelAddModeratorResponse=} [properties] Properties to set
         */
    function ChannelAddModeratorResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAddModeratorResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAddModeratorResponse
         * @instance
         */
    ChannelAddModeratorResponse.prototype.response = null;

    /**
         * ChannelAddModeratorResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAddModeratorResponse
         * @instance
         */
    ChannelAddModeratorResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAddModeratorResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelAddModeratorResponse
         * @instance
         */
    ChannelAddModeratorResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAddModeratorResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAddModeratorResponse
         * @static
         * @param {proto.IChannelAddModeratorResponse=} [properties] Properties to set
         * @returns {proto.ChannelAddModeratorResponse} ChannelAddModeratorResponse instance
         */
    ChannelAddModeratorResponse.create = function create(properties) {
      return new ChannelAddModeratorResponse(properties);
    };

    /**
         * Encodes the specified ChannelAddModeratorResponse message. Does not implicitly {@link proto.ChannelAddModeratorResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAddModeratorResponse
         * @static
         * @param {proto.ChannelAddModeratorResponse} message ChannelAddModeratorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAddModeratorResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelAddModeratorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAddModeratorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAddModeratorResponse} ChannelAddModeratorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAddModeratorResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAddModeratorResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAddModeratorResponse message.
         * @function verify
         * @memberof proto.ChannelAddModeratorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAddModeratorResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAddModeratorResponse;
  })();

  proto.ChannelAvatarAdd = (function() {

    /**
         * Properties of a ChannelAvatarAdd.
         * @memberof proto
         * @interface IChannelAvatarAdd
         * @property {proto.Request|null} [request] ChannelAvatarAdd request
         * @property {string|null} [attachment] ChannelAvatarAdd attachment
         * @property {Long|null} [roomId] ChannelAvatarAdd roomId
         */

    /**
         * Constructs a new ChannelAvatarAdd.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarAdd.
         * @implements IChannelAvatarAdd
         * @constructor
         * @param {proto.IChannelAvatarAdd=} [properties] Properties to set
         */
    function ChannelAvatarAdd(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarAdd request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAvatarAdd
         * @instance
         */
    ChannelAvatarAdd.prototype.request = null;

    /**
         * ChannelAvatarAdd attachment.
         * @member {string} attachment
         * @memberof proto.ChannelAvatarAdd
         * @instance
         */
    ChannelAvatarAdd.prototype.attachment = '';

    /**
         * ChannelAvatarAdd roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAvatarAdd
         * @instance
         */
    ChannelAvatarAdd.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAvatarAdd instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarAdd
         * @static
         * @param {proto.IChannelAvatarAdd=} [properties] Properties to set
         * @returns {proto.ChannelAvatarAdd} ChannelAvatarAdd instance
         */
    ChannelAvatarAdd.create = function create(properties) {
      return new ChannelAvatarAdd(properties);
    };

    /**
         * Encodes the specified ChannelAvatarAdd message. Does not implicitly {@link proto.ChannelAvatarAdd.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarAdd
         * @static
         * @param {proto.ChannelAvatarAdd} message ChannelAvatarAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarAdd.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.attachment);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelAvatarAdd message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarAdd} ChannelAvatarAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarAdd.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarAdd();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.attachment = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarAdd message.
         * @function verify
         * @memberof proto.ChannelAvatarAdd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarAdd.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAvatarAdd;
  })();

  proto.ChannelAvatarAddResponse = (function() {

    /**
         * Properties of a ChannelAvatarAddResponse.
         * @memberof proto
         * @interface IChannelAvatarAddResponse
         * @property {proto.Response|null} [response] ChannelAvatarAddResponse response
         * @property {proto.Avatar|null} [avatar] ChannelAvatarAddResponse avatar
         * @property {Long|null} [roomId] ChannelAvatarAddResponse roomId
         */

    /**
         * Constructs a new ChannelAvatarAddResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarAddResponse.
         * @implements IChannelAvatarAddResponse
         * @constructor
         * @param {proto.IChannelAvatarAddResponse=} [properties] Properties to set
         */
    function ChannelAvatarAddResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarAddResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAvatarAddResponse
         * @instance
         */
    ChannelAvatarAddResponse.prototype.response = null;

    /**
         * ChannelAvatarAddResponse avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.ChannelAvatarAddResponse
         * @instance
         */
    ChannelAvatarAddResponse.prototype.avatar = null;

    /**
         * ChannelAvatarAddResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAvatarAddResponse
         * @instance
         */
    ChannelAvatarAddResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAvatarAddResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarAddResponse
         * @static
         * @param {proto.IChannelAvatarAddResponse=} [properties] Properties to set
         * @returns {proto.ChannelAvatarAddResponse} ChannelAvatarAddResponse instance
         */
    ChannelAvatarAddResponse.create = function create(properties) {
      return new ChannelAvatarAddResponse(properties);
    };

    /**
         * Encodes the specified ChannelAvatarAddResponse message. Does not implicitly {@link proto.ChannelAvatarAddResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarAddResponse
         * @static
         * @param {proto.ChannelAvatarAddResponse} message ChannelAvatarAddResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarAddResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelAvatarAddResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarAddResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarAddResponse} ChannelAvatarAddResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarAddResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarAddResponse message.
         * @function verify
         * @memberof proto.ChannelAvatarAddResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarAddResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAvatarAddResponse;
  })();

  proto.ChannelAvatarDelete = (function() {

    /**
         * Properties of a ChannelAvatarDelete.
         * @memberof proto
         * @interface IChannelAvatarDelete
         * @property {proto.Request|null} [request] ChannelAvatarDelete request
         * @property {Long|null} [id] ChannelAvatarDelete id
         * @property {Long|null} [roomId] ChannelAvatarDelete roomId
         */

    /**
         * Constructs a new ChannelAvatarDelete.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarDelete.
         * @implements IChannelAvatarDelete
         * @constructor
         * @param {proto.IChannelAvatarDelete=} [properties] Properties to set
         */
    function ChannelAvatarDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAvatarDelete
         * @instance
         */
    ChannelAvatarDelete.prototype.request = null;

    /**
         * ChannelAvatarDelete id.
         * @member {Long} id
         * @memberof proto.ChannelAvatarDelete
         * @instance
         */
    ChannelAvatarDelete.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAvatarDelete roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAvatarDelete
         * @instance
         */
    ChannelAvatarDelete.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAvatarDelete instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarDelete
         * @static
         * @param {proto.IChannelAvatarDelete=} [properties] Properties to set
         * @returns {proto.ChannelAvatarDelete} ChannelAvatarDelete instance
         */
    ChannelAvatarDelete.create = function create(properties) {
      return new ChannelAvatarDelete(properties);
    };

    /**
         * Encodes the specified ChannelAvatarDelete message. Does not implicitly {@link proto.ChannelAvatarDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarDelete
         * @static
         * @param {proto.ChannelAvatarDelete} message ChannelAvatarDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelAvatarDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarDelete} ChannelAvatarDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarDelete message.
         * @function verify
         * @memberof proto.ChannelAvatarDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAvatarDelete;
  })();

  proto.ChannelAvatarDeleteResponse = (function() {

    /**
         * Properties of a ChannelAvatarDeleteResponse.
         * @memberof proto
         * @interface IChannelAvatarDeleteResponse
         * @property {proto.Response|null} [response] ChannelAvatarDeleteResponse response
         * @property {Long|null} [id] ChannelAvatarDeleteResponse id
         * @property {Long|null} [roomId] ChannelAvatarDeleteResponse roomId
         */

    /**
         * Constructs a new ChannelAvatarDeleteResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarDeleteResponse.
         * @implements IChannelAvatarDeleteResponse
         * @constructor
         * @param {proto.IChannelAvatarDeleteResponse=} [properties] Properties to set
         */
    function ChannelAvatarDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAvatarDeleteResponse
         * @instance
         */
    ChannelAvatarDeleteResponse.prototype.response = null;

    /**
         * ChannelAvatarDeleteResponse id.
         * @member {Long} id
         * @memberof proto.ChannelAvatarDeleteResponse
         * @instance
         */
    ChannelAvatarDeleteResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelAvatarDeleteResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAvatarDeleteResponse
         * @instance
         */
    ChannelAvatarDeleteResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAvatarDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarDeleteResponse
         * @static
         * @param {proto.IChannelAvatarDeleteResponse=} [properties] Properties to set
         * @returns {proto.ChannelAvatarDeleteResponse} ChannelAvatarDeleteResponse instance
         */
    ChannelAvatarDeleteResponse.create = function create(properties) {
      return new ChannelAvatarDeleteResponse(properties);
    };

    /**
         * Encodes the specified ChannelAvatarDeleteResponse message. Does not implicitly {@link proto.ChannelAvatarDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarDeleteResponse
         * @static
         * @param {proto.ChannelAvatarDeleteResponse} message ChannelAvatarDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelAvatarDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarDeleteResponse} ChannelAvatarDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarDeleteResponse message.
         * @function verify
         * @memberof proto.ChannelAvatarDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAvatarDeleteResponse;
  })();

  proto.ChannelAvatarGetList = (function() {

    /**
         * Properties of a ChannelAvatarGetList.
         * @memberof proto
         * @interface IChannelAvatarGetList
         * @property {proto.Request|null} [request] ChannelAvatarGetList request
         * @property {Long|null} [roomId] ChannelAvatarGetList roomId
         */

    /**
         * Constructs a new ChannelAvatarGetList.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarGetList.
         * @implements IChannelAvatarGetList
         * @constructor
         * @param {proto.IChannelAvatarGetList=} [properties] Properties to set
         */
    function ChannelAvatarGetList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarGetList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelAvatarGetList
         * @instance
         */
    ChannelAvatarGetList.prototype.request = null;

    /**
         * ChannelAvatarGetList roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelAvatarGetList
         * @instance
         */
    ChannelAvatarGetList.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelAvatarGetList instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarGetList
         * @static
         * @param {proto.IChannelAvatarGetList=} [properties] Properties to set
         * @returns {proto.ChannelAvatarGetList} ChannelAvatarGetList instance
         */
    ChannelAvatarGetList.create = function create(properties) {
      return new ChannelAvatarGetList(properties);
    };

    /**
         * Encodes the specified ChannelAvatarGetList message. Does not implicitly {@link proto.ChannelAvatarGetList.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarGetList
         * @static
         * @param {proto.ChannelAvatarGetList} message ChannelAvatarGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarGetList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelAvatarGetList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarGetList} ChannelAvatarGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarGetList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarGetList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarGetList message.
         * @function verify
         * @memberof proto.ChannelAvatarGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarGetList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelAvatarGetList;
  })();

  proto.ChannelAvatarGetListResponse = (function() {

    /**
         * Properties of a ChannelAvatarGetListResponse.
         * @memberof proto
         * @interface IChannelAvatarGetListResponse
         * @property {proto.Response|null} [response] ChannelAvatarGetListResponse response
         * @property {Array.<proto.Avatar>|null} [avatar] ChannelAvatarGetListResponse avatar
         */

    /**
         * Constructs a new ChannelAvatarGetListResponse.
         * @memberof proto
         * @classdesc Represents a ChannelAvatarGetListResponse.
         * @implements IChannelAvatarGetListResponse
         * @constructor
         * @param {proto.IChannelAvatarGetListResponse=} [properties] Properties to set
         */
    function ChannelAvatarGetListResponse(properties) {
      this.avatar = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelAvatarGetListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelAvatarGetListResponse
         * @instance
         */
    ChannelAvatarGetListResponse.prototype.response = null;

    /**
         * ChannelAvatarGetListResponse avatar.
         * @member {Array.<proto.Avatar>} avatar
         * @memberof proto.ChannelAvatarGetListResponse
         * @instance
         */
    ChannelAvatarGetListResponse.prototype.avatar = $util.emptyArray;

    /**
         * Creates a new ChannelAvatarGetListResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelAvatarGetListResponse
         * @static
         * @param {proto.IChannelAvatarGetListResponse=} [properties] Properties to set
         * @returns {proto.ChannelAvatarGetListResponse} ChannelAvatarGetListResponse instance
         */
    ChannelAvatarGetListResponse.create = function create(properties) {
      return new ChannelAvatarGetListResponse(properties);
    };

    /**
         * Encodes the specified ChannelAvatarGetListResponse message. Does not implicitly {@link proto.ChannelAvatarGetListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelAvatarGetListResponse
         * @static
         * @param {proto.ChannelAvatarGetListResponse} message ChannelAvatarGetListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelAvatarGetListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.avatar.length) {
        for (let i = 0; i < message.avatar.length; ++i) {$root.proto.Avatar.encode(message.avatar[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ChannelAvatarGetListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelAvatarGetListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelAvatarGetListResponse} ChannelAvatarGetListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelAvatarGetListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelAvatarGetListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.avatar && message.avatar.length)) {message.avatar = [];}
            message.avatar.push($root.proto.Avatar.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelAvatarGetListResponse message.
         * @function verify
         * @memberof proto.ChannelAvatarGetListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelAvatarGetListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        if (!Array.isArray(message.avatar)) {return 'avatar: array expected';}
        for (let i = 0; i < message.avatar.length; ++i) {
          let error = $root.proto.Avatar.verify(message.avatar[i]);
          if (error) {return 'avatar.' + error;}
        }
      }
      return null;
    };

    return ChannelAvatarGetListResponse;
  })();

  proto.ChannelCheckUsername = (function() {

    /**
         * Properties of a ChannelCheckUsername.
         * @memberof proto
         * @interface IChannelCheckUsername
         * @property {proto.Request|null} [request] ChannelCheckUsername request
         * @property {string|null} [username] ChannelCheckUsername username
         * @property {Long|null} [roomId] ChannelCheckUsername roomId
         */

    /**
         * Constructs a new ChannelCheckUsername.
         * @memberof proto
         * @classdesc Represents a ChannelCheckUsername.
         * @implements IChannelCheckUsername
         * @constructor
         * @param {proto.IChannelCheckUsername=} [properties] Properties to set
         */
    function ChannelCheckUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelCheckUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelCheckUsername
         * @instance
         */
    ChannelCheckUsername.prototype.request = null;

    /**
         * ChannelCheckUsername username.
         * @member {string} username
         * @memberof proto.ChannelCheckUsername
         * @instance
         */
    ChannelCheckUsername.prototype.username = '';

    /**
         * ChannelCheckUsername roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelCheckUsername
         * @instance
         */
    ChannelCheckUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelCheckUsername instance using the specified properties.
         * @function create
         * @memberof proto.ChannelCheckUsername
         * @static
         * @param {proto.IChannelCheckUsername=} [properties] Properties to set
         * @returns {proto.ChannelCheckUsername} ChannelCheckUsername instance
         */
    ChannelCheckUsername.create = function create(properties) {
      return new ChannelCheckUsername(properties);
    };

    /**
         * Encodes the specified ChannelCheckUsername message. Does not implicitly {@link proto.ChannelCheckUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelCheckUsername
         * @static
         * @param {proto.ChannelCheckUsername} message ChannelCheckUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelCheckUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelCheckUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelCheckUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelCheckUsername} ChannelCheckUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelCheckUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelCheckUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelCheckUsername message.
         * @function verify
         * @memberof proto.ChannelCheckUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelCheckUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelCheckUsername;
  })();

  proto.ChannelCheckUsernameResponse = (function() {

    /**
         * Properties of a ChannelCheckUsernameResponse.
         * @memberof proto
         * @interface IChannelCheckUsernameResponse
         * @property {proto.Response|null} [response] ChannelCheckUsernameResponse response
         * @property {proto.ChannelCheckUsernameResponse.Status|null} [status] ChannelCheckUsernameResponse status
         */

    /**
         * Constructs a new ChannelCheckUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ChannelCheckUsernameResponse.
         * @implements IChannelCheckUsernameResponse
         * @constructor
         * @param {proto.IChannelCheckUsernameResponse=} [properties] Properties to set
         */
    function ChannelCheckUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelCheckUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelCheckUsernameResponse
         * @instance
         */
    ChannelCheckUsernameResponse.prototype.response = null;

    /**
         * ChannelCheckUsernameResponse status.
         * @member {proto.ChannelCheckUsernameResponse.Status} status
         * @memberof proto.ChannelCheckUsernameResponse
         * @instance
         */
    ChannelCheckUsernameResponse.prototype.status = 0;

    /**
         * Creates a new ChannelCheckUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelCheckUsernameResponse
         * @static
         * @param {proto.IChannelCheckUsernameResponse=} [properties] Properties to set
         * @returns {proto.ChannelCheckUsernameResponse} ChannelCheckUsernameResponse instance
         */
    ChannelCheckUsernameResponse.create = function create(properties) {
      return new ChannelCheckUsernameResponse(properties);
    };

    /**
         * Encodes the specified ChannelCheckUsernameResponse message. Does not implicitly {@link proto.ChannelCheckUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelCheckUsernameResponse
         * @static
         * @param {proto.ChannelCheckUsernameResponse} message ChannelCheckUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelCheckUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a ChannelCheckUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelCheckUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelCheckUsernameResponse} ChannelCheckUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelCheckUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelCheckUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelCheckUsernameResponse message.
         * @function verify
         * @memberof proto.ChannelCheckUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelCheckUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.ChannelCheckUsernameResponse.Status
         * @enum {string}
         * @property {number} INVALID=0 INVALID value
         * @property {number} TAKEN=1 TAKEN value
         * @property {number} AVAILABLE=2 AVAILABLE value
         * @property {number} OCCUPYING_LIMIT_EXCEEDED=3 OCCUPYING_LIMIT_EXCEEDED value
         */
    ChannelCheckUsernameResponse.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'INVALID'] = 0;
      values[valuesById[1] = 'TAKEN'] = 1;
      values[valuesById[2] = 'AVAILABLE'] = 2;
      values[valuesById[3] = 'OCCUPYING_LIMIT_EXCEEDED'] = 3;
      return values;
    })();

    return ChannelCheckUsernameResponse;
  })();

  proto.ChannelCreate = (function() {

    /**
         * Properties of a ChannelCreate.
         * @memberof proto
         * @interface IChannelCreate
         * @property {proto.Request|null} [request] ChannelCreate request
         * @property {string|null} [name] ChannelCreate name
         * @property {string|null} [description] ChannelCreate description
         */

    /**
         * Constructs a new ChannelCreate.
         * @memberof proto
         * @classdesc Represents a ChannelCreate.
         * @implements IChannelCreate
         * @constructor
         * @param {proto.IChannelCreate=} [properties] Properties to set
         */
    function ChannelCreate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelCreate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelCreate
         * @instance
         */
    ChannelCreate.prototype.request = null;

    /**
         * ChannelCreate name.
         * @member {string} name
         * @memberof proto.ChannelCreate
         * @instance
         */
    ChannelCreate.prototype.name = '';

    /**
         * ChannelCreate description.
         * @member {string} description
         * @memberof proto.ChannelCreate
         * @instance
         */
    ChannelCreate.prototype.description = '';

    /**
         * Creates a new ChannelCreate instance using the specified properties.
         * @function create
         * @memberof proto.ChannelCreate
         * @static
         * @param {proto.IChannelCreate=} [properties] Properties to set
         * @returns {proto.ChannelCreate} ChannelCreate instance
         */
    ChannelCreate.create = function create(properties) {
      return new ChannelCreate(properties);
    };

    /**
         * Encodes the specified ChannelCreate message. Does not implicitly {@link proto.ChannelCreate.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelCreate
         * @static
         * @param {proto.ChannelCreate} message ChannelCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelCreate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);}
      return writer;
    };

    /**
         * Decodes a ChannelCreate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelCreate} ChannelCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelCreate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelCreate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelCreate message.
         * @function verify
         * @memberof proto.ChannelCreate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelCreate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return ChannelCreate;
  })();

  proto.ChannelCreateResponse = (function() {

    /**
         * Properties of a ChannelCreateResponse.
         * @memberof proto
         * @interface IChannelCreateResponse
         * @property {proto.Response|null} [response] ChannelCreateResponse response
         * @property {Long|null} [roomId] ChannelCreateResponse roomId
         * @property {string|null} [inviteLink] ChannelCreateResponse inviteLink
         */

    /**
         * Constructs a new ChannelCreateResponse.
         * @memberof proto
         * @classdesc Represents a ChannelCreateResponse.
         * @implements IChannelCreateResponse
         * @constructor
         * @param {proto.IChannelCreateResponse=} [properties] Properties to set
         */
    function ChannelCreateResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelCreateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelCreateResponse
         * @instance
         */
    ChannelCreateResponse.prototype.response = null;

    /**
         * ChannelCreateResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelCreateResponse
         * @instance
         */
    ChannelCreateResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelCreateResponse inviteLink.
         * @member {string} inviteLink
         * @memberof proto.ChannelCreateResponse
         * @instance
         */
    ChannelCreateResponse.prototype.inviteLink = '';

    /**
         * Creates a new ChannelCreateResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelCreateResponse
         * @static
         * @param {proto.IChannelCreateResponse=} [properties] Properties to set
         * @returns {proto.ChannelCreateResponse} ChannelCreateResponse instance
         */
    ChannelCreateResponse.create = function create(properties) {
      return new ChannelCreateResponse(properties);
    };

    /**
         * Encodes the specified ChannelCreateResponse message. Does not implicitly {@link proto.ChannelCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelCreateResponse
         * @static
         * @param {proto.ChannelCreateResponse} message ChannelCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelCreateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.inviteLink);}
      return writer;
    };

    /**
         * Decodes a ChannelCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelCreateResponse} ChannelCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelCreateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelCreateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.inviteLink = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelCreateResponse message.
         * @function verify
         * @memberof proto.ChannelCreateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelCreateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
        if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
      }
      return null;
    };

    return ChannelCreateResponse;
  })();

  proto.ChannelDelete = (function() {

    /**
         * Properties of a ChannelDelete.
         * @memberof proto
         * @interface IChannelDelete
         * @property {proto.Request|null} [request] ChannelDelete request
         * @property {Long|null} [roomId] ChannelDelete roomId
         */

    /**
         * Constructs a new ChannelDelete.
         * @memberof proto
         * @classdesc Represents a ChannelDelete.
         * @implements IChannelDelete
         * @constructor
         * @param {proto.IChannelDelete=} [properties] Properties to set
         */
    function ChannelDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelDelete
         * @instance
         */
    ChannelDelete.prototype.request = null;

    /**
         * ChannelDelete roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelDelete
         * @instance
         */
    ChannelDelete.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelDelete instance using the specified properties.
         * @function create
         * @memberof proto.ChannelDelete
         * @static
         * @param {proto.IChannelDelete=} [properties] Properties to set
         * @returns {proto.ChannelDelete} ChannelDelete instance
         */
    ChannelDelete.create = function create(properties) {
      return new ChannelDelete(properties);
    };

    /**
         * Encodes the specified ChannelDelete message. Does not implicitly {@link proto.ChannelDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelDelete
         * @static
         * @param {proto.ChannelDelete} message ChannelDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelDelete} ChannelDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelDelete message.
         * @function verify
         * @memberof proto.ChannelDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelDelete;
  })();

  proto.ChannelDeleteResponse = (function() {

    /**
         * Properties of a ChannelDeleteResponse.
         * @memberof proto
         * @interface IChannelDeleteResponse
         * @property {proto.Response|null} [response] ChannelDeleteResponse response
         * @property {Long|null} [roomId] ChannelDeleteResponse roomId
         */

    /**
         * Constructs a new ChannelDeleteResponse.
         * @memberof proto
         * @classdesc Represents a ChannelDeleteResponse.
         * @implements IChannelDeleteResponse
         * @constructor
         * @param {proto.IChannelDeleteResponse=} [properties] Properties to set
         */
    function ChannelDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelDeleteResponse
         * @instance
         */
    ChannelDeleteResponse.prototype.response = null;

    /**
         * ChannelDeleteResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelDeleteResponse
         * @instance
         */
    ChannelDeleteResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelDeleteResponse
         * @static
         * @param {proto.IChannelDeleteResponse=} [properties] Properties to set
         * @returns {proto.ChannelDeleteResponse} ChannelDeleteResponse instance
         */
    ChannelDeleteResponse.create = function create(properties) {
      return new ChannelDeleteResponse(properties);
    };

    /**
         * Encodes the specified ChannelDeleteResponse message. Does not implicitly {@link proto.ChannelDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelDeleteResponse
         * @static
         * @param {proto.ChannelDeleteResponse} message ChannelDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelDeleteResponse} ChannelDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelDeleteResponse message.
         * @function verify
         * @memberof proto.ChannelDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelDeleteResponse;
  })();

  proto.ChannelDeleteMessage = (function() {

    /**
         * Properties of a ChannelDeleteMessage.
         * @memberof proto
         * @interface IChannelDeleteMessage
         * @property {proto.Request|null} [request] ChannelDeleteMessage request
         * @property {Long|null} [roomId] ChannelDeleteMessage roomId
         * @property {Long|null} [messageId] ChannelDeleteMessage messageId
         */

    /**
         * Constructs a new ChannelDeleteMessage.
         * @memberof proto
         * @classdesc Represents a ChannelDeleteMessage.
         * @implements IChannelDeleteMessage
         * @constructor
         * @param {proto.IChannelDeleteMessage=} [properties] Properties to set
         */
    function ChannelDeleteMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelDeleteMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelDeleteMessage
         * @instance
         */
    ChannelDeleteMessage.prototype.request = null;

    /**
         * ChannelDeleteMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelDeleteMessage
         * @instance
         */
    ChannelDeleteMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelDeleteMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelDeleteMessage
         * @instance
         */
    ChannelDeleteMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelDeleteMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChannelDeleteMessage
         * @static
         * @param {proto.IChannelDeleteMessage=} [properties] Properties to set
         * @returns {proto.ChannelDeleteMessage} ChannelDeleteMessage instance
         */
    ChannelDeleteMessage.create = function create(properties) {
      return new ChannelDeleteMessage(properties);
    };

    /**
         * Encodes the specified ChannelDeleteMessage message. Does not implicitly {@link proto.ChannelDeleteMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelDeleteMessage
         * @static
         * @param {proto.ChannelDeleteMessage} message ChannelDeleteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelDeleteMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a ChannelDeleteMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelDeleteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelDeleteMessage} ChannelDeleteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelDeleteMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelDeleteMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelDeleteMessage message.
         * @function verify
         * @memberof proto.ChannelDeleteMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelDeleteMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return ChannelDeleteMessage;
  })();

  proto.ChannelDeleteMessageResponse = (function() {

    /**
         * Properties of a ChannelDeleteMessageResponse.
         * @memberof proto
         * @interface IChannelDeleteMessageResponse
         * @property {proto.Response|null} [response] ChannelDeleteMessageResponse response
         * @property {Long|null} [roomId] ChannelDeleteMessageResponse roomId
         * @property {Long|null} [messageId] ChannelDeleteMessageResponse messageId
         * @property {Long|null} [deleteVersion] ChannelDeleteMessageResponse deleteVersion
         */

    /**
         * Constructs a new ChannelDeleteMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChannelDeleteMessageResponse.
         * @implements IChannelDeleteMessageResponse
         * @constructor
         * @param {proto.IChannelDeleteMessageResponse=} [properties] Properties to set
         */
    function ChannelDeleteMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelDeleteMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelDeleteMessageResponse
         * @instance
         */
    ChannelDeleteMessageResponse.prototype.response = null;

    /**
         * ChannelDeleteMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelDeleteMessageResponse
         * @instance
         */
    ChannelDeleteMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelDeleteMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelDeleteMessageResponse
         * @instance
         */
    ChannelDeleteMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelDeleteMessageResponse deleteVersion.
         * @member {Long} deleteVersion
         * @memberof proto.ChannelDeleteMessageResponse
         * @instance
         */
    ChannelDeleteMessageResponse.prototype.deleteVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelDeleteMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelDeleteMessageResponse
         * @static
         * @param {proto.IChannelDeleteMessageResponse=} [properties] Properties to set
         * @returns {proto.ChannelDeleteMessageResponse} ChannelDeleteMessageResponse instance
         */
    ChannelDeleteMessageResponse.create = function create(properties) {
      return new ChannelDeleteMessageResponse(properties);
    };

    /**
         * Encodes the specified ChannelDeleteMessageResponse message. Does not implicitly {@link proto.ChannelDeleteMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelDeleteMessageResponse
         * @static
         * @param {proto.ChannelDeleteMessageResponse} message ChannelDeleteMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelDeleteMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.deleteVersion);}
      return writer;
    };

    /**
         * Decodes a ChannelDeleteMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelDeleteMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelDeleteMessageResponse} ChannelDeleteMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelDeleteMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelDeleteMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.deleteVersion = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelDeleteMessageResponse message.
         * @function verify
         * @memberof proto.ChannelDeleteMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelDeleteMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {
        if (!$util.isInteger(message.deleteVersion) && !(message.deleteVersion && $util.isInteger(message.deleteVersion.low) && $util.isInteger(message.deleteVersion.high))) {return 'deleteVersion: integer|Long expected';}
      }
      return null;
    };

    return ChannelDeleteMessageResponse;
  })();

  proto.ChannelEdit = (function() {

    /**
         * Properties of a ChannelEdit.
         * @memberof proto
         * @interface IChannelEdit
         * @property {proto.Request|null} [request] ChannelEdit request
         * @property {Long|null} [roomId] ChannelEdit roomId
         * @property {string|null} [name] ChannelEdit name
         * @property {string|null} [description] ChannelEdit description
         */

    /**
         * Constructs a new ChannelEdit.
         * @memberof proto
         * @classdesc Represents a ChannelEdit.
         * @implements IChannelEdit
         * @constructor
         * @param {proto.IChannelEdit=} [properties] Properties to set
         */
    function ChannelEdit(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelEdit request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelEdit
         * @instance
         */
    ChannelEdit.prototype.request = null;

    /**
         * ChannelEdit roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelEdit
         * @instance
         */
    ChannelEdit.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEdit name.
         * @member {string} name
         * @memberof proto.ChannelEdit
         * @instance
         */
    ChannelEdit.prototype.name = '';

    /**
         * ChannelEdit description.
         * @member {string} description
         * @memberof proto.ChannelEdit
         * @instance
         */
    ChannelEdit.prototype.description = '';

    /**
         * Creates a new ChannelEdit instance using the specified properties.
         * @function create
         * @memberof proto.ChannelEdit
         * @static
         * @param {proto.IChannelEdit=} [properties] Properties to set
         * @returns {proto.ChannelEdit} ChannelEdit instance
         */
    ChannelEdit.create = function create(properties) {
      return new ChannelEdit(properties);
    };

    /**
         * Encodes the specified ChannelEdit message. Does not implicitly {@link proto.ChannelEdit.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelEdit
         * @static
         * @param {proto.ChannelEdit} message ChannelEdit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelEdit.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a ChannelEdit message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelEdit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelEdit} ChannelEdit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelEdit.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelEdit();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelEdit message.
         * @function verify
         * @memberof proto.ChannelEdit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelEdit.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return ChannelEdit;
  })();

  proto.ChannelEditResponse = (function() {

    /**
         * Properties of a ChannelEditResponse.
         * @memberof proto
         * @interface IChannelEditResponse
         * @property {proto.Response|null} [response] ChannelEditResponse response
         * @property {Long|null} [roomId] ChannelEditResponse roomId
         * @property {string|null} [name] ChannelEditResponse name
         * @property {string|null} [description] ChannelEditResponse description
         */

    /**
         * Constructs a new ChannelEditResponse.
         * @memberof proto
         * @classdesc Represents a ChannelEditResponse.
         * @implements IChannelEditResponse
         * @constructor
         * @param {proto.IChannelEditResponse=} [properties] Properties to set
         */
    function ChannelEditResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelEditResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelEditResponse
         * @instance
         */
    ChannelEditResponse.prototype.response = null;

    /**
         * ChannelEditResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelEditResponse
         * @instance
         */
    ChannelEditResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditResponse name.
         * @member {string} name
         * @memberof proto.ChannelEditResponse
         * @instance
         */
    ChannelEditResponse.prototype.name = '';

    /**
         * ChannelEditResponse description.
         * @member {string} description
         * @memberof proto.ChannelEditResponse
         * @instance
         */
    ChannelEditResponse.prototype.description = '';

    /**
         * Creates a new ChannelEditResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelEditResponse
         * @static
         * @param {proto.IChannelEditResponse=} [properties] Properties to set
         * @returns {proto.ChannelEditResponse} ChannelEditResponse instance
         */
    ChannelEditResponse.create = function create(properties) {
      return new ChannelEditResponse(properties);
    };

    /**
         * Encodes the specified ChannelEditResponse message. Does not implicitly {@link proto.ChannelEditResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelEditResponse
         * @static
         * @param {proto.ChannelEditResponse} message ChannelEditResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelEditResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a ChannelEditResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelEditResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelEditResponse} ChannelEditResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelEditResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelEditResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelEditResponse message.
         * @function verify
         * @memberof proto.ChannelEditResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelEditResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return ChannelEditResponse;
  })();

  proto.ChannelEditMessage = (function() {

    /**
         * Properties of a ChannelEditMessage.
         * @memberof proto
         * @interface IChannelEditMessage
         * @property {proto.Request|null} [request] ChannelEditMessage request
         * @property {Long|null} [roomId] ChannelEditMessage roomId
         * @property {Long|null} [messageId] ChannelEditMessage messageId
         * @property {string|null} [message] ChannelEditMessage message
         */

    /**
         * Constructs a new ChannelEditMessage.
         * @memberof proto
         * @classdesc Represents a ChannelEditMessage.
         * @implements IChannelEditMessage
         * @constructor
         * @param {proto.IChannelEditMessage=} [properties] Properties to set
         */
    function ChannelEditMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelEditMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelEditMessage
         * @instance
         */
    ChannelEditMessage.prototype.request = null;

    /**
         * ChannelEditMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelEditMessage
         * @instance
         */
    ChannelEditMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelEditMessage
         * @instance
         */
    ChannelEditMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditMessage message.
         * @member {string} message
         * @memberof proto.ChannelEditMessage
         * @instance
         */
    ChannelEditMessage.prototype.message = '';

    /**
         * Creates a new ChannelEditMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChannelEditMessage
         * @static
         * @param {proto.IChannelEditMessage=} [properties] Properties to set
         * @returns {proto.ChannelEditMessage} ChannelEditMessage instance
         */
    ChannelEditMessage.create = function create(properties) {
      return new ChannelEditMessage(properties);
    };

    /**
         * Encodes the specified ChannelEditMessage message. Does not implicitly {@link proto.ChannelEditMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelEditMessage
         * @static
         * @param {proto.ChannelEditMessage} message ChannelEditMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelEditMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      return writer;
    };

    /**
         * Decodes a ChannelEditMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelEditMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelEditMessage} ChannelEditMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelEditMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelEditMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelEditMessage message.
         * @function verify
         * @memberof proto.ChannelEditMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelEditMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      return null;
    };

    return ChannelEditMessage;
  })();

  proto.ChannelEditMessageResponse = (function() {

    /**
         * Properties of a ChannelEditMessageResponse.
         * @memberof proto
         * @interface IChannelEditMessageResponse
         * @property {proto.Response|null} [response] ChannelEditMessageResponse response
         * @property {Long|null} [roomId] ChannelEditMessageResponse roomId
         * @property {Long|null} [messageId] ChannelEditMessageResponse messageId
         * @property {Long|null} [messageVersion] ChannelEditMessageResponse messageVersion
         * @property {string|null} [message] ChannelEditMessageResponse message
         * @property {proto.RoomMessageType|null} [messageType] ChannelEditMessageResponse messageType
         */

    /**
         * Constructs a new ChannelEditMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChannelEditMessageResponse.
         * @implements IChannelEditMessageResponse
         * @constructor
         * @param {proto.IChannelEditMessageResponse=} [properties] Properties to set
         */
    function ChannelEditMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelEditMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.response = null;

    /**
         * ChannelEditMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditMessageResponse messageVersion.
         * @member {Long} messageVersion
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.messageVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelEditMessageResponse message.
         * @member {string} message
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.message = '';

    /**
         * ChannelEditMessageResponse messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.ChannelEditMessageResponse
         * @instance
         */
    ChannelEditMessageResponse.prototype.messageType = 0;

    /**
         * Creates a new ChannelEditMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelEditMessageResponse
         * @static
         * @param {proto.IChannelEditMessageResponse=} [properties] Properties to set
         * @returns {proto.ChannelEditMessageResponse} ChannelEditMessageResponse instance
         */
    ChannelEditMessageResponse.create = function create(properties) {
      return new ChannelEditMessageResponse(properties);
    };

    /**
         * Encodes the specified ChannelEditMessageResponse message. Does not implicitly {@link proto.ChannelEditMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelEditMessageResponse
         * @static
         * @param {proto.ChannelEditMessageResponse} message ChannelEditMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelEditMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageVersion);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.messageType);}
      return writer;
    };

    /**
         * Decodes a ChannelEditMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelEditMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelEditMessageResponse} ChannelEditMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelEditMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelEditMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.messageVersion = reader.uint64();
            break;
          case 5:
            message.message = reader.string();
            break;
          case 6:
            message.messageType = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelEditMessageResponse message.
         * @function verify
         * @memberof proto.ChannelEditMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelEditMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {
        if (!$util.isInteger(message.messageVersion) && !(message.messageVersion && $util.isInteger(message.messageVersion.low) && $util.isInteger(message.messageVersion.high))) {return 'messageVersion: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      return null;
    };

    return ChannelEditMessageResponse;
  })();

  proto.ChannelGetDraft = (function() {

    /**
         * Properties of a ChannelGetDraft.
         * @memberof proto
         * @interface IChannelGetDraft
         * @property {proto.Request|null} [request] ChannelGetDraft request
         * @property {Long|null} [roomId] ChannelGetDraft roomId
         */

    /**
         * Constructs a new ChannelGetDraft.
         * @memberof proto
         * @classdesc Represents a ChannelGetDraft.
         * @implements IChannelGetDraft
         * @constructor
         * @param {proto.IChannelGetDraft=} [properties] Properties to set
         */
    function ChannelGetDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelGetDraft
         * @instance
         */
    ChannelGetDraft.prototype.request = null;

    /**
         * ChannelGetDraft roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelGetDraft
         * @instance
         */
    ChannelGetDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelGetDraft instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetDraft
         * @static
         * @param {proto.IChannelGetDraft=} [properties] Properties to set
         * @returns {proto.ChannelGetDraft} ChannelGetDraft instance
         */
    ChannelGetDraft.create = function create(properties) {
      return new ChannelGetDraft(properties);
    };

    /**
         * Encodes the specified ChannelGetDraft message. Does not implicitly {@link proto.ChannelGetDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetDraft
         * @static
         * @param {proto.ChannelGetDraft} message ChannelGetDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelGetDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetDraft} ChannelGetDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetDraft message.
         * @function verify
         * @memberof proto.ChannelGetDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelGetDraft;
  })();

  proto.ChannelGetDraftResponse = (function() {

    /**
         * Properties of a ChannelGetDraftResponse.
         * @memberof proto
         * @interface IChannelGetDraftResponse
         * @property {proto.Response|null} [response] ChannelGetDraftResponse response
         * @property {proto.RoomDraft|null} [draft] ChannelGetDraftResponse draft
         */

    /**
         * Constructs a new ChannelGetDraftResponse.
         * @memberof proto
         * @classdesc Represents a ChannelGetDraftResponse.
         * @implements IChannelGetDraftResponse
         * @constructor
         * @param {proto.IChannelGetDraftResponse=} [properties] Properties to set
         */
    function ChannelGetDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelGetDraftResponse
         * @instance
         */
    ChannelGetDraftResponse.prototype.response = null;

    /**
         * ChannelGetDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChannelGetDraftResponse
         * @instance
         */
    ChannelGetDraftResponse.prototype.draft = null;

    /**
         * Creates a new ChannelGetDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetDraftResponse
         * @static
         * @param {proto.IChannelGetDraftResponse=} [properties] Properties to set
         * @returns {proto.ChannelGetDraftResponse} ChannelGetDraftResponse instance
         */
    ChannelGetDraftResponse.create = function create(properties) {
      return new ChannelGetDraftResponse(properties);
    };

    /**
         * Encodes the specified ChannelGetDraftResponse message. Does not implicitly {@link proto.ChannelGetDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetDraftResponse
         * @static
         * @param {proto.ChannelGetDraftResponse} message ChannelGetDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelGetDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetDraftResponse} ChannelGetDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetDraftResponse message.
         * @function verify
         * @memberof proto.ChannelGetDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChannelGetDraftResponse;
  })();

  proto.ChannelGetMemberList = (function() {

    /**
         * Properties of a ChannelGetMemberList.
         * @memberof proto
         * @interface IChannelGetMemberList
         * @property {proto.Request|null} [request] ChannelGetMemberList request
         * @property {Long|null} [roomId] ChannelGetMemberList roomId
         * @property {proto.ChannelGetMemberList.FilterRole|null} [filterRole] ChannelGetMemberList filterRole
         * @property {proto.Pagination|null} [pagination] ChannelGetMemberList pagination
         */

    /**
         * Constructs a new ChannelGetMemberList.
         * @memberof proto
         * @classdesc Represents a ChannelGetMemberList.
         * @implements IChannelGetMemberList
         * @constructor
         * @param {proto.IChannelGetMemberList=} [properties] Properties to set
         */
    function ChannelGetMemberList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetMemberList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelGetMemberList
         * @instance
         */
    ChannelGetMemberList.prototype.request = null;

    /**
         * ChannelGetMemberList roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelGetMemberList
         * @instance
         */
    ChannelGetMemberList.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelGetMemberList filterRole.
         * @member {proto.ChannelGetMemberList.FilterRole} filterRole
         * @memberof proto.ChannelGetMemberList
         * @instance
         */
    ChannelGetMemberList.prototype.filterRole = 0;

    /**
         * ChannelGetMemberList pagination.
         * @member {proto.Pagination|null|undefined} pagination
         * @memberof proto.ChannelGetMemberList
         * @instance
         */
    ChannelGetMemberList.prototype.pagination = null;

    /**
         * Creates a new ChannelGetMemberList instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetMemberList
         * @static
         * @param {proto.IChannelGetMemberList=} [properties] Properties to set
         * @returns {proto.ChannelGetMemberList} ChannelGetMemberList instance
         */
    ChannelGetMemberList.create = function create(properties) {
      return new ChannelGetMemberList(properties);
    };

    /**
         * Encodes the specified ChannelGetMemberList message. Does not implicitly {@link proto.ChannelGetMemberList.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetMemberList
         * @static
         * @param {proto.ChannelGetMemberList} message ChannelGetMemberList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetMemberList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.filterRole != null && message.hasOwnProperty('filterRole')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterRole);}
      if (message.pagination != null && message.hasOwnProperty('pagination')) {$root.proto.Pagination.encode(message.pagination, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelGetMemberList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetMemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetMemberList} ChannelGetMemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetMemberList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMemberList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.filterRole = reader.int32();
            break;
          case 4:
            message.pagination = $root.proto.Pagination.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetMemberList message.
         * @function verify
         * @memberof proto.ChannelGetMemberList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetMemberList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.filterRole != null && message.hasOwnProperty('filterRole')) {
        switch (message.filterRole) {
          default:
            return 'filterRole: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.pagination != null && message.hasOwnProperty('pagination')) {
        let error = $root.proto.Pagination.verify(message.pagination);
        if (error) {return 'pagination.' + error;}
      }
      return null;
    };

    /**
         * FilterRole enum.
         * @name proto.ChannelGetMemberList.FilterRole
         * @enum {string}
         * @property {number} ALL=0 ALL value
         * @property {number} MEMBER=1 MEMBER value
         * @property {number} MODERATOR=2 MODERATOR value
         * @property {number} ADMIN=3 ADMIN value
         */
    ChannelGetMemberList.FilterRole = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'ALL'] = 0;
      values[valuesById[1] = 'MEMBER'] = 1;
      values[valuesById[2] = 'MODERATOR'] = 2;
      values[valuesById[3] = 'ADMIN'] = 3;
      return values;
    })();

    return ChannelGetMemberList;
  })();

  proto.ChannelGetMemberListResponse = (function() {

    /**
         * Properties of a ChannelGetMemberListResponse.
         * @memberof proto
         * @interface IChannelGetMemberListResponse
         * @property {proto.Response|null} [response] ChannelGetMemberListResponse response
         * @property {Array.<proto.ChannelGetMemberListResponse.Member>|null} [member] ChannelGetMemberListResponse member
         */

    /**
         * Constructs a new ChannelGetMemberListResponse.
         * @memberof proto
         * @classdesc Represents a ChannelGetMemberListResponse.
         * @implements IChannelGetMemberListResponse
         * @constructor
         * @param {proto.IChannelGetMemberListResponse=} [properties] Properties to set
         */
    function ChannelGetMemberListResponse(properties) {
      this.member = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetMemberListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelGetMemberListResponse
         * @instance
         */
    ChannelGetMemberListResponse.prototype.response = null;

    /**
         * ChannelGetMemberListResponse member.
         * @member {Array.<proto.ChannelGetMemberListResponse.Member>} member
         * @memberof proto.ChannelGetMemberListResponse
         * @instance
         */
    ChannelGetMemberListResponse.prototype.member = $util.emptyArray;

    /**
         * Creates a new ChannelGetMemberListResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetMemberListResponse
         * @static
         * @param {proto.IChannelGetMemberListResponse=} [properties] Properties to set
         * @returns {proto.ChannelGetMemberListResponse} ChannelGetMemberListResponse instance
         */
    ChannelGetMemberListResponse.create = function create(properties) {
      return new ChannelGetMemberListResponse(properties);
    };

    /**
         * Encodes the specified ChannelGetMemberListResponse message. Does not implicitly {@link proto.ChannelGetMemberListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetMemberListResponse
         * @static
         * @param {proto.ChannelGetMemberListResponse} message ChannelGetMemberListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetMemberListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.member != null && message.member.length) {
        for (let i = 0; i < message.member.length; ++i) {$root.proto.ChannelGetMemberListResponse.Member.encode(message.member[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ChannelGetMemberListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetMemberListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetMemberListResponse} ChannelGetMemberListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetMemberListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMemberListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.member && message.member.length)) {message.member = [];}
            message.member.push($root.proto.ChannelGetMemberListResponse.Member.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetMemberListResponse message.
         * @function verify
         * @memberof proto.ChannelGetMemberListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetMemberListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.member != null && message.hasOwnProperty('member')) {
        if (!Array.isArray(message.member)) {return 'member: array expected';}
        for (let i = 0; i < message.member.length; ++i) {
          let error = $root.proto.ChannelGetMemberListResponse.Member.verify(message.member[i]);
          if (error) {return 'member.' + error;}
        }
      }
      return null;
    };

    ChannelGetMemberListResponse.Member = (function() {

      /**
             * Properties of a Member.
             * @memberof proto.ChannelGetMemberListResponse
             * @interface IMember
             * @property {Long|null} [userId] Member userId
             * @property {proto.ChannelRoom.Role|null} [role] Member role
             */

      /**
             * Constructs a new Member.
             * @memberof proto.ChannelGetMemberListResponse
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {proto.ChannelGetMemberListResponse.IMember=} [properties] Properties to set
             */
      function Member(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Member userId.
             * @member {Long} userId
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @instance
             */
      Member.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Member role.
             * @member {proto.ChannelRoom.Role} role
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @instance
             */
      Member.prototype.role = 0;

      /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @static
             * @param {proto.ChannelGetMemberListResponse.IMember=} [properties] Properties to set
             * @returns {proto.ChannelGetMemberListResponse.Member} Member instance
             */
      Member.create = function create(properties) {
        return new Member(properties);
      };

      /**
             * Encodes the specified Member message. Does not implicitly {@link proto.ChannelGetMemberListResponse.Member.verify|verify} messages.
             * @function encode
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @static
             * @param {proto.ChannelGetMemberListResponse.Member} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Member.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);}
        return writer;
      };

      /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ChannelGetMemberListResponse.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Member.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMemberListResponse.Member();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.role = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Member message.
             * @function verify
             * @memberof proto.ChannelGetMemberListResponse.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Member.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.role != null && message.hasOwnProperty('role')) {
          switch (message.role) {
            default:
              return 'role: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        }
        return null;
      };

      return Member;
    })();

    return ChannelGetMemberListResponse;
  })();

  proto.ChannelGetMessagesStats = (function() {

    /**
         * Properties of a ChannelGetMessagesStats.
         * @memberof proto
         * @interface IChannelGetMessagesStats
         * @property {proto.Request|null} [request] ChannelGetMessagesStats request
         * @property {Long|null} [roomId] ChannelGetMessagesStats roomId
         * @property {Array.<Long>|null} [messageId] ChannelGetMessagesStats messageId
         */

    /**
         * Constructs a new ChannelGetMessagesStats.
         * @memberof proto
         * @classdesc Represents a ChannelGetMessagesStats.
         * @implements IChannelGetMessagesStats
         * @constructor
         * @param {proto.IChannelGetMessagesStats=} [properties] Properties to set
         */
    function ChannelGetMessagesStats(properties) {
      this.messageId = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetMessagesStats request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelGetMessagesStats
         * @instance
         */
    ChannelGetMessagesStats.prototype.request = null;

    /**
         * ChannelGetMessagesStats roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelGetMessagesStats
         * @instance
         */
    ChannelGetMessagesStats.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelGetMessagesStats messageId.
         * @member {Array.<Long>} messageId
         * @memberof proto.ChannelGetMessagesStats
         * @instance
         */
    ChannelGetMessagesStats.prototype.messageId = $util.emptyArray;

    /**
         * Creates a new ChannelGetMessagesStats instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetMessagesStats
         * @static
         * @param {proto.IChannelGetMessagesStats=} [properties] Properties to set
         * @returns {proto.ChannelGetMessagesStats} ChannelGetMessagesStats instance
         */
    ChannelGetMessagesStats.create = function create(properties) {
      return new ChannelGetMessagesStats(properties);
    };

    /**
         * Encodes the specified ChannelGetMessagesStats message. Does not implicitly {@link proto.ChannelGetMessagesStats.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetMessagesStats
         * @static
         * @param {proto.ChannelGetMessagesStats} message ChannelGetMessagesStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetMessagesStats.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.messageId.length) {
        writer.uint32(/* id 3, wireType 2 =*/26).fork();
        for (let i = 0; i < message.messageId.length; ++i) {writer.uint64(message.messageId[i]);}
        writer.ldelim();
      }
      return writer;
    };

    /**
         * Decodes a ChannelGetMessagesStats message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetMessagesStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetMessagesStats} ChannelGetMessagesStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetMessagesStats.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMessagesStats();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            if (!(message.messageId && message.messageId.length)) {message.messageId = [];}
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {message.messageId.push(reader.uint64());}
            } else {message.messageId.push(reader.uint64());}
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetMessagesStats message.
         * @function verify
         * @memberof proto.ChannelGetMessagesStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetMessagesStats.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!Array.isArray(message.messageId)) {return 'messageId: array expected';}
        for (let i = 0; i < message.messageId.length; ++i) {
          if (!$util.isInteger(message.messageId[i]) && !(message.messageId[i] && $util.isInteger(message.messageId[i].low) && $util.isInteger(message.messageId[i].high))) {return 'messageId: integer|Long[] expected';}
        }
      }
      return null;
    };

    return ChannelGetMessagesStats;
  })();

  proto.ChannelGetMessagesStatsResponse = (function() {

    /**
         * Properties of a ChannelGetMessagesStatsResponse.
         * @memberof proto
         * @interface IChannelGetMessagesStatsResponse
         * @property {proto.Response|null} [response] ChannelGetMessagesStatsResponse response
         * @property {Array.<proto.ChannelGetMessagesStatsResponse.Stats>|null} [stats] ChannelGetMessagesStatsResponse stats
         */

    /**
         * Constructs a new ChannelGetMessagesStatsResponse.
         * @memberof proto
         * @classdesc Represents a ChannelGetMessagesStatsResponse.
         * @implements IChannelGetMessagesStatsResponse
         * @constructor
         * @param {proto.IChannelGetMessagesStatsResponse=} [properties] Properties to set
         */
    function ChannelGetMessagesStatsResponse(properties) {
      this.stats = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelGetMessagesStatsResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @instance
         */
    ChannelGetMessagesStatsResponse.prototype.response = null;

    /**
         * ChannelGetMessagesStatsResponse stats.
         * @member {Array.<proto.ChannelGetMessagesStatsResponse.Stats>} stats
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @instance
         */
    ChannelGetMessagesStatsResponse.prototype.stats = $util.emptyArray;

    /**
         * Creates a new ChannelGetMessagesStatsResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @static
         * @param {proto.IChannelGetMessagesStatsResponse=} [properties] Properties to set
         * @returns {proto.ChannelGetMessagesStatsResponse} ChannelGetMessagesStatsResponse instance
         */
    ChannelGetMessagesStatsResponse.create = function create(properties) {
      return new ChannelGetMessagesStatsResponse(properties);
    };

    /**
         * Encodes the specified ChannelGetMessagesStatsResponse message. Does not implicitly {@link proto.ChannelGetMessagesStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @static
         * @param {proto.ChannelGetMessagesStatsResponse} message ChannelGetMessagesStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelGetMessagesStatsResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.stats != null && message.stats.length) {
        for (let i = 0; i < message.stats.length; ++i) {$root.proto.ChannelGetMessagesStatsResponse.Stats.encode(message.stats[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ChannelGetMessagesStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelGetMessagesStatsResponse} ChannelGetMessagesStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelGetMessagesStatsResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMessagesStatsResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.stats && message.stats.length)) {message.stats = [];}
            message.stats.push($root.proto.ChannelGetMessagesStatsResponse.Stats.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelGetMessagesStatsResponse message.
         * @function verify
         * @memberof proto.ChannelGetMessagesStatsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelGetMessagesStatsResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.stats != null && message.hasOwnProperty('stats')) {
        if (!Array.isArray(message.stats)) {return 'stats: array expected';}
        for (let i = 0; i < message.stats.length; ++i) {
          let error = $root.proto.ChannelGetMessagesStatsResponse.Stats.verify(message.stats[i]);
          if (error) {return 'stats.' + error;}
        }
      }
      return null;
    };

    ChannelGetMessagesStatsResponse.Stats = (function() {

      /**
             * Properties of a Stats.
             * @memberof proto.ChannelGetMessagesStatsResponse
             * @interface IStats
             * @property {Long|null} [messageId] Stats messageId
             * @property {string|null} [viewsLabel] Stats viewsLabel
             * @property {string|null} [thumbsUpLabel] Stats thumbsUpLabel
             * @property {string|null} [thumbsDownLabel] Stats thumbsDownLabel
             */

      /**
             * Constructs a new Stats.
             * @memberof proto.ChannelGetMessagesStatsResponse
             * @classdesc Represents a Stats.
             * @implements IStats
             * @constructor
             * @param {proto.ChannelGetMessagesStatsResponse.IStats=} [properties] Properties to set
             */
      function Stats(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Stats messageId.
             * @member {Long} messageId
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @instance
             */
      Stats.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Stats viewsLabel.
             * @member {string} viewsLabel
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @instance
             */
      Stats.prototype.viewsLabel = '';

      /**
             * Stats thumbsUpLabel.
             * @member {string} thumbsUpLabel
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @instance
             */
      Stats.prototype.thumbsUpLabel = '';

      /**
             * Stats thumbsDownLabel.
             * @member {string} thumbsDownLabel
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @instance
             */
      Stats.prototype.thumbsDownLabel = '';

      /**
             * Creates a new Stats instance using the specified properties.
             * @function create
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @static
             * @param {proto.ChannelGetMessagesStatsResponse.IStats=} [properties] Properties to set
             * @returns {proto.ChannelGetMessagesStatsResponse.Stats} Stats instance
             */
      Stats.create = function create(properties) {
        return new Stats(properties);
      };

      /**
             * Encodes the specified Stats message. Does not implicitly {@link proto.ChannelGetMessagesStatsResponse.Stats.verify|verify} messages.
             * @function encode
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @static
             * @param {proto.ChannelGetMessagesStatsResponse.Stats} message Stats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Stats.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);}
        if (message.viewsLabel != null && message.hasOwnProperty('viewsLabel')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.viewsLabel);}
        if (message.thumbsUpLabel != null && message.hasOwnProperty('thumbsUpLabel')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.thumbsUpLabel);}
        if (message.thumbsDownLabel != null && message.hasOwnProperty('thumbsDownLabel')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.thumbsDownLabel);}
        return writer;
      };

      /**
             * Decodes a Stats message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ChannelGetMessagesStatsResponse.Stats} Stats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Stats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelGetMessagesStatsResponse.Stats();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messageId = reader.uint64();
              break;
            case 2:
              message.viewsLabel = reader.string();
              break;
            case 3:
              message.thumbsUpLabel = reader.string();
              break;
            case 4:
              message.thumbsDownLabel = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Stats message.
             * @function verify
             * @memberof proto.ChannelGetMessagesStatsResponse.Stats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Stats.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.messageId != null && message.hasOwnProperty('messageId')) {
          if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
        }
        if (message.viewsLabel != null && message.hasOwnProperty('viewsLabel')) {
          if (!$util.isString(message.viewsLabel)) {return 'viewsLabel: string expected';}
        }
        if (message.thumbsUpLabel != null && message.hasOwnProperty('thumbsUpLabel')) {
          if (!$util.isString(message.thumbsUpLabel)) {return 'thumbsUpLabel: string expected';}
        }
        if (message.thumbsDownLabel != null && message.hasOwnProperty('thumbsDownLabel')) {
          if (!$util.isString(message.thumbsDownLabel)) {return 'thumbsDownLabel: string expected';}
        }
        return null;
      };

      return Stats;
    })();

    return ChannelGetMessagesStatsResponse;
  })();

  proto.ChannelKickAdmin = (function() {

    /**
         * Properties of a ChannelKickAdmin.
         * @memberof proto
         * @interface IChannelKickAdmin
         * @property {proto.Request|null} [request] ChannelKickAdmin request
         * @property {Long|null} [roomId] ChannelKickAdmin roomId
         * @property {Long|null} [memberId] ChannelKickAdmin memberId
         */

    /**
         * Constructs a new ChannelKickAdmin.
         * @memberof proto
         * @classdesc Represents a ChannelKickAdmin.
         * @implements IChannelKickAdmin
         * @constructor
         * @param {proto.IChannelKickAdmin=} [properties] Properties to set
         */
    function ChannelKickAdmin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickAdmin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelKickAdmin
         * @instance
         */
    ChannelKickAdmin.prototype.request = null;

    /**
         * ChannelKickAdmin roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickAdmin
         * @instance
         */
    ChannelKickAdmin.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickAdmin memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickAdmin
         * @instance
         */
    ChannelKickAdmin.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickAdmin instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickAdmin
         * @static
         * @param {proto.IChannelKickAdmin=} [properties] Properties to set
         * @returns {proto.ChannelKickAdmin} ChannelKickAdmin instance
         */
    ChannelKickAdmin.create = function create(properties) {
      return new ChannelKickAdmin(properties);
    };

    /**
         * Encodes the specified ChannelKickAdmin message. Does not implicitly {@link proto.ChannelKickAdmin.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickAdmin
         * @static
         * @param {proto.ChannelKickAdmin} message ChannelKickAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickAdmin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickAdmin} ChannelKickAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickAdmin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickAdmin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickAdmin message.
         * @function verify
         * @memberof proto.ChannelKickAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickAdmin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickAdmin;
  })();

  proto.ChannelKickAdminResponse = (function() {

    /**
         * Properties of a ChannelKickAdminResponse.
         * @memberof proto
         * @interface IChannelKickAdminResponse
         * @property {proto.Response|null} [response] ChannelKickAdminResponse response
         * @property {Long|null} [roomId] ChannelKickAdminResponse roomId
         * @property {Long|null} [memberId] ChannelKickAdminResponse memberId
         */

    /**
         * Constructs a new ChannelKickAdminResponse.
         * @memberof proto
         * @classdesc Represents a ChannelKickAdminResponse.
         * @implements IChannelKickAdminResponse
         * @constructor
         * @param {proto.IChannelKickAdminResponse=} [properties] Properties to set
         */
    function ChannelKickAdminResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickAdminResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelKickAdminResponse
         * @instance
         */
    ChannelKickAdminResponse.prototype.response = null;

    /**
         * ChannelKickAdminResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickAdminResponse
         * @instance
         */
    ChannelKickAdminResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickAdminResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickAdminResponse
         * @instance
         */
    ChannelKickAdminResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickAdminResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickAdminResponse
         * @static
         * @param {proto.IChannelKickAdminResponse=} [properties] Properties to set
         * @returns {proto.ChannelKickAdminResponse} ChannelKickAdminResponse instance
         */
    ChannelKickAdminResponse.create = function create(properties) {
      return new ChannelKickAdminResponse(properties);
    };

    /**
         * Encodes the specified ChannelKickAdminResponse message. Does not implicitly {@link proto.ChannelKickAdminResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickAdminResponse
         * @static
         * @param {proto.ChannelKickAdminResponse} message ChannelKickAdminResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickAdminResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickAdminResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickAdminResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickAdminResponse} ChannelKickAdminResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickAdminResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickAdminResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickAdminResponse message.
         * @function verify
         * @memberof proto.ChannelKickAdminResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickAdminResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickAdminResponse;
  })();

  proto.ChannelKickMember = (function() {

    /**
         * Properties of a ChannelKickMember.
         * @memberof proto
         * @interface IChannelKickMember
         * @property {proto.Request|null} [request] ChannelKickMember request
         * @property {Long|null} [roomId] ChannelKickMember roomId
         * @property {Long|null} [memberId] ChannelKickMember memberId
         */

    /**
         * Constructs a new ChannelKickMember.
         * @memberof proto
         * @classdesc Represents a ChannelKickMember.
         * @implements IChannelKickMember
         * @constructor
         * @param {proto.IChannelKickMember=} [properties] Properties to set
         */
    function ChannelKickMember(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickMember request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelKickMember
         * @instance
         */
    ChannelKickMember.prototype.request = null;

    /**
         * ChannelKickMember roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickMember
         * @instance
         */
    ChannelKickMember.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickMember memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickMember
         * @instance
         */
    ChannelKickMember.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickMember instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickMember
         * @static
         * @param {proto.IChannelKickMember=} [properties] Properties to set
         * @returns {proto.ChannelKickMember} ChannelKickMember instance
         */
    ChannelKickMember.create = function create(properties) {
      return new ChannelKickMember(properties);
    };

    /**
         * Encodes the specified ChannelKickMember message. Does not implicitly {@link proto.ChannelKickMember.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickMember
         * @static
         * @param {proto.ChannelKickMember} message ChannelKickMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickMember.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickMember message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickMember} ChannelKickMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickMember.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickMember();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickMember message.
         * @function verify
         * @memberof proto.ChannelKickMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickMember.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickMember;
  })();

  proto.ChannelKickMemberResponse = (function() {

    /**
         * Properties of a ChannelKickMemberResponse.
         * @memberof proto
         * @interface IChannelKickMemberResponse
         * @property {proto.Response|null} [response] ChannelKickMemberResponse response
         * @property {Long|null} [roomId] ChannelKickMemberResponse roomId
         * @property {Long|null} [memberId] ChannelKickMemberResponse memberId
         */

    /**
         * Constructs a new ChannelKickMemberResponse.
         * @memberof proto
         * @classdesc Represents a ChannelKickMemberResponse.
         * @implements IChannelKickMemberResponse
         * @constructor
         * @param {proto.IChannelKickMemberResponse=} [properties] Properties to set
         */
    function ChannelKickMemberResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickMemberResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelKickMemberResponse
         * @instance
         */
    ChannelKickMemberResponse.prototype.response = null;

    /**
         * ChannelKickMemberResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickMemberResponse
         * @instance
         */
    ChannelKickMemberResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickMemberResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickMemberResponse
         * @instance
         */
    ChannelKickMemberResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickMemberResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickMemberResponse
         * @static
         * @param {proto.IChannelKickMemberResponse=} [properties] Properties to set
         * @returns {proto.ChannelKickMemberResponse} ChannelKickMemberResponse instance
         */
    ChannelKickMemberResponse.create = function create(properties) {
      return new ChannelKickMemberResponse(properties);
    };

    /**
         * Encodes the specified ChannelKickMemberResponse message. Does not implicitly {@link proto.ChannelKickMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickMemberResponse
         * @static
         * @param {proto.ChannelKickMemberResponse} message ChannelKickMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickMemberResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickMemberResponse} ChannelKickMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickMemberResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickMemberResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickMemberResponse message.
         * @function verify
         * @memberof proto.ChannelKickMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickMemberResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickMemberResponse;
  })();

  proto.ChannelKickModerator = (function() {

    /**
         * Properties of a ChannelKickModerator.
         * @memberof proto
         * @interface IChannelKickModerator
         * @property {proto.Request|null} [request] ChannelKickModerator request
         * @property {Long|null} [roomId] ChannelKickModerator roomId
         * @property {Long|null} [memberId] ChannelKickModerator memberId
         */

    /**
         * Constructs a new ChannelKickModerator.
         * @memberof proto
         * @classdesc Represents a ChannelKickModerator.
         * @implements IChannelKickModerator
         * @constructor
         * @param {proto.IChannelKickModerator=} [properties] Properties to set
         */
    function ChannelKickModerator(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickModerator request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelKickModerator
         * @instance
         */
    ChannelKickModerator.prototype.request = null;

    /**
         * ChannelKickModerator roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickModerator
         * @instance
         */
    ChannelKickModerator.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickModerator memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickModerator
         * @instance
         */
    ChannelKickModerator.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickModerator instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickModerator
         * @static
         * @param {proto.IChannelKickModerator=} [properties] Properties to set
         * @returns {proto.ChannelKickModerator} ChannelKickModerator instance
         */
    ChannelKickModerator.create = function create(properties) {
      return new ChannelKickModerator(properties);
    };

    /**
         * Encodes the specified ChannelKickModerator message. Does not implicitly {@link proto.ChannelKickModerator.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickModerator
         * @static
         * @param {proto.ChannelKickModerator} message ChannelKickModerator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickModerator.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickModerator message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickModerator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickModerator} ChannelKickModerator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickModerator.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickModerator();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickModerator message.
         * @function verify
         * @memberof proto.ChannelKickModerator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickModerator.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickModerator;
  })();

  proto.ChannelKickModeratorResponse = (function() {

    /**
         * Properties of a ChannelKickModeratorResponse.
         * @memberof proto
         * @interface IChannelKickModeratorResponse
         * @property {proto.Response|null} [response] ChannelKickModeratorResponse response
         * @property {Long|null} [roomId] ChannelKickModeratorResponse roomId
         * @property {Long|null} [memberId] ChannelKickModeratorResponse memberId
         */

    /**
         * Constructs a new ChannelKickModeratorResponse.
         * @memberof proto
         * @classdesc Represents a ChannelKickModeratorResponse.
         * @implements IChannelKickModeratorResponse
         * @constructor
         * @param {proto.IChannelKickModeratorResponse=} [properties] Properties to set
         */
    function ChannelKickModeratorResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelKickModeratorResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelKickModeratorResponse
         * @instance
         */
    ChannelKickModeratorResponse.prototype.response = null;

    /**
         * ChannelKickModeratorResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelKickModeratorResponse
         * @instance
         */
    ChannelKickModeratorResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelKickModeratorResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelKickModeratorResponse
         * @instance
         */
    ChannelKickModeratorResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelKickModeratorResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelKickModeratorResponse
         * @static
         * @param {proto.IChannelKickModeratorResponse=} [properties] Properties to set
         * @returns {proto.ChannelKickModeratorResponse} ChannelKickModeratorResponse instance
         */
    ChannelKickModeratorResponse.create = function create(properties) {
      return new ChannelKickModeratorResponse(properties);
    };

    /**
         * Encodes the specified ChannelKickModeratorResponse message. Does not implicitly {@link proto.ChannelKickModeratorResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelKickModeratorResponse
         * @static
         * @param {proto.ChannelKickModeratorResponse} message ChannelKickModeratorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelKickModeratorResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelKickModeratorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelKickModeratorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelKickModeratorResponse} ChannelKickModeratorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelKickModeratorResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelKickModeratorResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelKickModeratorResponse message.
         * @function verify
         * @memberof proto.ChannelKickModeratorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelKickModeratorResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelKickModeratorResponse;
  })();

  proto.ChannelLeft = (function() {

    /**
         * Properties of a ChannelLeft.
         * @memberof proto
         * @interface IChannelLeft
         * @property {proto.Request|null} [request] ChannelLeft request
         * @property {Long|null} [roomId] ChannelLeft roomId
         */

    /**
         * Constructs a new ChannelLeft.
         * @memberof proto
         * @classdesc Represents a ChannelLeft.
         * @implements IChannelLeft
         * @constructor
         * @param {proto.IChannelLeft=} [properties] Properties to set
         */
    function ChannelLeft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelLeft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelLeft
         * @instance
         */
    ChannelLeft.prototype.request = null;

    /**
         * ChannelLeft roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelLeft
         * @instance
         */
    ChannelLeft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelLeft instance using the specified properties.
         * @function create
         * @memberof proto.ChannelLeft
         * @static
         * @param {proto.IChannelLeft=} [properties] Properties to set
         * @returns {proto.ChannelLeft} ChannelLeft instance
         */
    ChannelLeft.create = function create(properties) {
      return new ChannelLeft(properties);
    };

    /**
         * Encodes the specified ChannelLeft message. Does not implicitly {@link proto.ChannelLeft.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelLeft
         * @static
         * @param {proto.ChannelLeft} message ChannelLeft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelLeft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelLeft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelLeft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelLeft} ChannelLeft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelLeft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelLeft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelLeft message.
         * @function verify
         * @memberof proto.ChannelLeft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelLeft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelLeft;
  })();

  proto.ChannelLeftResponse = (function() {

    /**
         * Properties of a ChannelLeftResponse.
         * @memberof proto
         * @interface IChannelLeftResponse
         * @property {proto.Response|null} [response] ChannelLeftResponse response
         * @property {Long|null} [roomId] ChannelLeftResponse roomId
         * @property {Long|null} [memberId] ChannelLeftResponse memberId
         */

    /**
         * Constructs a new ChannelLeftResponse.
         * @memberof proto
         * @classdesc Represents a ChannelLeftResponse.
         * @implements IChannelLeftResponse
         * @constructor
         * @param {proto.IChannelLeftResponse=} [properties] Properties to set
         */
    function ChannelLeftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelLeftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelLeftResponse
         * @instance
         */
    ChannelLeftResponse.prototype.response = null;

    /**
         * ChannelLeftResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelLeftResponse
         * @instance
         */
    ChannelLeftResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelLeftResponse memberId.
         * @member {Long} memberId
         * @memberof proto.ChannelLeftResponse
         * @instance
         */
    ChannelLeftResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelLeftResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelLeftResponse
         * @static
         * @param {proto.IChannelLeftResponse=} [properties] Properties to set
         * @returns {proto.ChannelLeftResponse} ChannelLeftResponse instance
         */
    ChannelLeftResponse.create = function create(properties) {
      return new ChannelLeftResponse(properties);
    };

    /**
         * Encodes the specified ChannelLeftResponse message. Does not implicitly {@link proto.ChannelLeftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelLeftResponse
         * @static
         * @param {proto.ChannelLeftResponse} message ChannelLeftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelLeftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a ChannelLeftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelLeftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelLeftResponse} ChannelLeftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelLeftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelLeftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelLeftResponse message.
         * @function verify
         * @memberof proto.ChannelLeftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelLeftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return ChannelLeftResponse;
  })();

  proto.ChannelPinMessage = (function() {

    /**
         * Properties of a ChannelPinMessage.
         * @memberof proto
         * @interface IChannelPinMessage
         * @property {proto.Request|null} [request] ChannelPinMessage request
         * @property {Long|null} [roomId] ChannelPinMessage roomId
         * @property {Long|null} [messageId] ChannelPinMessage messageId
         */

    /**
         * Constructs a new ChannelPinMessage.
         * @memberof proto
         * @classdesc Represents a ChannelPinMessage.
         * @implements IChannelPinMessage
         * @constructor
         * @param {proto.IChannelPinMessage=} [properties] Properties to set
         */
    function ChannelPinMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelPinMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelPinMessage
         * @instance
         */
    ChannelPinMessage.prototype.request = null;

    /**
         * ChannelPinMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelPinMessage
         * @instance
         */
    ChannelPinMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelPinMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ChannelPinMessage
         * @instance
         */
    ChannelPinMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelPinMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChannelPinMessage
         * @static
         * @param {proto.IChannelPinMessage=} [properties] Properties to set
         * @returns {proto.ChannelPinMessage} ChannelPinMessage instance
         */
    ChannelPinMessage.create = function create(properties) {
      return new ChannelPinMessage(properties);
    };

    /**
         * Encodes the specified ChannelPinMessage message. Does not implicitly {@link proto.ChannelPinMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelPinMessage
         * @static
         * @param {proto.ChannelPinMessage} message ChannelPinMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelPinMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a ChannelPinMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelPinMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelPinMessage} ChannelPinMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelPinMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelPinMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelPinMessage message.
         * @function verify
         * @memberof proto.ChannelPinMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelPinMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return ChannelPinMessage;
  })();

  proto.ChannelPinMessageResponse = (function() {

    /**
         * Properties of a ChannelPinMessageResponse.
         * @memberof proto
         * @interface IChannelPinMessageResponse
         * @property {proto.Response|null} [response] ChannelPinMessageResponse response
         * @property {Long|null} [roomId] ChannelPinMessageResponse roomId
         * @property {proto.RoomMessage|null} [pinnedMessage] ChannelPinMessageResponse pinnedMessage
         */

    /**
         * Constructs a new ChannelPinMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChannelPinMessageResponse.
         * @implements IChannelPinMessageResponse
         * @constructor
         * @param {proto.IChannelPinMessageResponse=} [properties] Properties to set
         */
    function ChannelPinMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelPinMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelPinMessageResponse
         * @instance
         */
    ChannelPinMessageResponse.prototype.response = null;

    /**
         * ChannelPinMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelPinMessageResponse
         * @instance
         */
    ChannelPinMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelPinMessageResponse pinnedMessage.
         * @member {proto.RoomMessage|null|undefined} pinnedMessage
         * @memberof proto.ChannelPinMessageResponse
         * @instance
         */
    ChannelPinMessageResponse.prototype.pinnedMessage = null;

    /**
         * Creates a new ChannelPinMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelPinMessageResponse
         * @static
         * @param {proto.IChannelPinMessageResponse=} [properties] Properties to set
         * @returns {proto.ChannelPinMessageResponse} ChannelPinMessageResponse instance
         */
    ChannelPinMessageResponse.create = function create(properties) {
      return new ChannelPinMessageResponse(properties);
    };

    /**
         * Encodes the specified ChannelPinMessageResponse message. Does not implicitly {@link proto.ChannelPinMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelPinMessageResponse
         * @static
         * @param {proto.ChannelPinMessageResponse} message ChannelPinMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelPinMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {$root.proto.RoomMessage.encode(message.pinnedMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelPinMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelPinMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelPinMessageResponse} ChannelPinMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelPinMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelPinMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.pinnedMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelPinMessageResponse message.
         * @function verify
         * @memberof proto.ChannelPinMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelPinMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {
        let error = $root.proto.RoomMessage.verify(message.pinnedMessage);
        if (error) {return 'pinnedMessage.' + error;}
      }
      return null;
    };

    return ChannelPinMessageResponse;
  })();

  proto.ChannelRemoveUsername = (function() {

    /**
         * Properties of a ChannelRemoveUsername.
         * @memberof proto
         * @interface IChannelRemoveUsername
         * @property {proto.Request|null} [request] ChannelRemoveUsername request
         * @property {Long|null} [roomId] ChannelRemoveUsername roomId
         */

    /**
         * Constructs a new ChannelRemoveUsername.
         * @memberof proto
         * @classdesc Represents a ChannelRemoveUsername.
         * @implements IChannelRemoveUsername
         * @constructor
         * @param {proto.IChannelRemoveUsername=} [properties] Properties to set
         */
    function ChannelRemoveUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelRemoveUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelRemoveUsername
         * @instance
         */
    ChannelRemoveUsername.prototype.request = null;

    /**
         * ChannelRemoveUsername roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelRemoveUsername
         * @instance
         */
    ChannelRemoveUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelRemoveUsername instance using the specified properties.
         * @function create
         * @memberof proto.ChannelRemoveUsername
         * @static
         * @param {proto.IChannelRemoveUsername=} [properties] Properties to set
         * @returns {proto.ChannelRemoveUsername} ChannelRemoveUsername instance
         */
    ChannelRemoveUsername.create = function create(properties) {
      return new ChannelRemoveUsername(properties);
    };

    /**
         * Encodes the specified ChannelRemoveUsername message. Does not implicitly {@link proto.ChannelRemoveUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelRemoveUsername
         * @static
         * @param {proto.ChannelRemoveUsername} message ChannelRemoveUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelRemoveUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelRemoveUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelRemoveUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelRemoveUsername} ChannelRemoveUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelRemoveUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRemoveUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelRemoveUsername message.
         * @function verify
         * @memberof proto.ChannelRemoveUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelRemoveUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelRemoveUsername;
  })();

  proto.ChannelRemoveUsernameResponse = (function() {

    /**
         * Properties of a ChannelRemoveUsernameResponse.
         * @memberof proto
         * @interface IChannelRemoveUsernameResponse
         * @property {proto.Response|null} [response] ChannelRemoveUsernameResponse response
         * @property {Long|null} [roomId] ChannelRemoveUsernameResponse roomId
         */

    /**
         * Constructs a new ChannelRemoveUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ChannelRemoveUsernameResponse.
         * @implements IChannelRemoveUsernameResponse
         * @constructor
         * @param {proto.IChannelRemoveUsernameResponse=} [properties] Properties to set
         */
    function ChannelRemoveUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelRemoveUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelRemoveUsernameResponse
         * @instance
         */
    ChannelRemoveUsernameResponse.prototype.response = null;

    /**
         * ChannelRemoveUsernameResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelRemoveUsernameResponse
         * @instance
         */
    ChannelRemoveUsernameResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelRemoveUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelRemoveUsernameResponse
         * @static
         * @param {proto.IChannelRemoveUsernameResponse=} [properties] Properties to set
         * @returns {proto.ChannelRemoveUsernameResponse} ChannelRemoveUsernameResponse instance
         */
    ChannelRemoveUsernameResponse.create = function create(properties) {
      return new ChannelRemoveUsernameResponse(properties);
    };

    /**
         * Encodes the specified ChannelRemoveUsernameResponse message. Does not implicitly {@link proto.ChannelRemoveUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelRemoveUsernameResponse
         * @static
         * @param {proto.ChannelRemoveUsernameResponse} message ChannelRemoveUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelRemoveUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelRemoveUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelRemoveUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelRemoveUsernameResponse} ChannelRemoveUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelRemoveUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRemoveUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelRemoveUsernameResponse message.
         * @function verify
         * @memberof proto.ChannelRemoveUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelRemoveUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelRemoveUsernameResponse;
  })();

  proto.ChannelRevokeLink = (function() {

    /**
         * Properties of a ChannelRevokeLink.
         * @memberof proto
         * @interface IChannelRevokeLink
         * @property {proto.Request|null} [request] ChannelRevokeLink request
         * @property {Long|null} [roomId] ChannelRevokeLink roomId
         */

    /**
         * Constructs a new ChannelRevokeLink.
         * @memberof proto
         * @classdesc Represents a ChannelRevokeLink.
         * @implements IChannelRevokeLink
         * @constructor
         * @param {proto.IChannelRevokeLink=} [properties] Properties to set
         */
    function ChannelRevokeLink(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelRevokeLink request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelRevokeLink
         * @instance
         */
    ChannelRevokeLink.prototype.request = null;

    /**
         * ChannelRevokeLink roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelRevokeLink
         * @instance
         */
    ChannelRevokeLink.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelRevokeLink instance using the specified properties.
         * @function create
         * @memberof proto.ChannelRevokeLink
         * @static
         * @param {proto.IChannelRevokeLink=} [properties] Properties to set
         * @returns {proto.ChannelRevokeLink} ChannelRevokeLink instance
         */
    ChannelRevokeLink.create = function create(properties) {
      return new ChannelRevokeLink(properties);
    };

    /**
         * Encodes the specified ChannelRevokeLink message. Does not implicitly {@link proto.ChannelRevokeLink.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelRevokeLink
         * @static
         * @param {proto.ChannelRevokeLink} message ChannelRevokeLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelRevokeLink.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelRevokeLink message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelRevokeLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelRevokeLink} ChannelRevokeLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelRevokeLink.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRevokeLink();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelRevokeLink message.
         * @function verify
         * @memberof proto.ChannelRevokeLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelRevokeLink.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelRevokeLink;
  })();

  proto.ChannelRevokeLinkResponse = (function() {

    /**
         * Properties of a ChannelRevokeLinkResponse.
         * @memberof proto
         * @interface IChannelRevokeLinkResponse
         * @property {proto.Response|null} [response] ChannelRevokeLinkResponse response
         * @property {Long|null} [roomId] ChannelRevokeLinkResponse roomId
         * @property {string|null} [inviteLink] ChannelRevokeLinkResponse inviteLink
         * @property {string|null} [inviteToken] ChannelRevokeLinkResponse inviteToken
         */

    /**
         * Constructs a new ChannelRevokeLinkResponse.
         * @memberof proto
         * @classdesc Represents a ChannelRevokeLinkResponse.
         * @implements IChannelRevokeLinkResponse
         * @constructor
         * @param {proto.IChannelRevokeLinkResponse=} [properties] Properties to set
         */
    function ChannelRevokeLinkResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelRevokeLinkResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelRevokeLinkResponse
         * @instance
         */
    ChannelRevokeLinkResponse.prototype.response = null;

    /**
         * ChannelRevokeLinkResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelRevokeLinkResponse
         * @instance
         */
    ChannelRevokeLinkResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelRevokeLinkResponse inviteLink.
         * @member {string} inviteLink
         * @memberof proto.ChannelRevokeLinkResponse
         * @instance
         */
    ChannelRevokeLinkResponse.prototype.inviteLink = '';

    /**
         * ChannelRevokeLinkResponse inviteToken.
         * @member {string} inviteToken
         * @memberof proto.ChannelRevokeLinkResponse
         * @instance
         */
    ChannelRevokeLinkResponse.prototype.inviteToken = '';

    /**
         * Creates a new ChannelRevokeLinkResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelRevokeLinkResponse
         * @static
         * @param {proto.IChannelRevokeLinkResponse=} [properties] Properties to set
         * @returns {proto.ChannelRevokeLinkResponse} ChannelRevokeLinkResponse instance
         */
    ChannelRevokeLinkResponse.create = function create(properties) {
      return new ChannelRevokeLinkResponse(properties);
    };

    /**
         * Encodes the specified ChannelRevokeLinkResponse message. Does not implicitly {@link proto.ChannelRevokeLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelRevokeLinkResponse
         * @static
         * @param {proto.ChannelRevokeLinkResponse} message ChannelRevokeLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelRevokeLinkResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.inviteLink);}
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.inviteToken);}
      return writer;
    };

    /**
         * Decodes a ChannelRevokeLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelRevokeLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelRevokeLinkResponse} ChannelRevokeLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelRevokeLinkResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelRevokeLinkResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.inviteLink = reader.string();
            break;
          case 4:
            message.inviteToken = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelRevokeLinkResponse message.
         * @function verify
         * @memberof proto.ChannelRevokeLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelRevokeLinkResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
        if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
      }
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
        if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
      }
      return null;
    };

    return ChannelRevokeLinkResponse;
  })();

  proto.ChannelSendMessage = (function() {

    /**
         * Properties of a ChannelSendMessage.
         * @memberof proto
         * @interface IChannelSendMessage
         * @property {proto.Request|null} [request] ChannelSendMessage request
         * @property {proto.RoomMessageType|null} [messageType] ChannelSendMessage messageType
         * @property {Long|null} [roomId] ChannelSendMessage roomId
         * @property {string|null} [message] ChannelSendMessage message
         * @property {string|null} [attachment] ChannelSendMessage attachment
         * @property {proto.RoomMessageLocation|null} [location] ChannelSendMessage location
         * @property {proto.RoomMessageContact|null} [contact] ChannelSendMessage contact
         * @property {Long|null} [replyTo] ChannelSendMessage replyTo
         * @property {proto.RoomMessageForwardFrom|null} [forwardFrom] ChannelSendMessage forwardFrom
         * @property {Long|null} [randomId] ChannelSendMessage randomId
         */

    /**
         * Constructs a new ChannelSendMessage.
         * @memberof proto
         * @classdesc Represents a ChannelSendMessage.
         * @implements IChannelSendMessage
         * @constructor
         * @param {proto.IChannelSendMessage=} [properties] Properties to set
         */
    function ChannelSendMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelSendMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.request = null;

    /**
         * ChannelSendMessage messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.messageType = 0;

    /**
         * ChannelSendMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelSendMessage message.
         * @member {string} message
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.message = '';

    /**
         * ChannelSendMessage attachment.
         * @member {string} attachment
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.attachment = '';

    /**
         * ChannelSendMessage location.
         * @member {proto.RoomMessageLocation|null|undefined} location
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.location = null;

    /**
         * ChannelSendMessage contact.
         * @member {proto.RoomMessageContact|null|undefined} contact
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.contact = null;

    /**
         * ChannelSendMessage replyTo.
         * @member {Long} replyTo
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.replyTo = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelSendMessage forwardFrom.
         * @member {proto.RoomMessageForwardFrom|null|undefined} forwardFrom
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.forwardFrom = null;

    /**
         * ChannelSendMessage randomId.
         * @member {Long} randomId
         * @memberof proto.ChannelSendMessage
         * @instance
         */
    ChannelSendMessage.prototype.randomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelSendMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChannelSendMessage
         * @static
         * @param {proto.IChannelSendMessage=} [properties] Properties to set
         * @returns {proto.ChannelSendMessage} ChannelSendMessage instance
         */
    ChannelSendMessage.create = function create(properties) {
      return new ChannelSendMessage(properties);
    };

    /**
         * Encodes the specified ChannelSendMessage message. Does not implicitly {@link proto.ChannelSendMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelSendMessage
         * @static
         * @param {proto.ChannelSendMessage} message ChannelSendMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelSendMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messageType);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.attachment);}
      if (message.location != null && message.hasOwnProperty('location')) {$root.proto.RoomMessageLocation.encode(message.location, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();}
      if (message.contact != null && message.hasOwnProperty('contact')) {$root.proto.RoomMessageContact.encode(message.contact, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.replyTo);}
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {$root.proto.RoomMessageForwardFrom.encode(message.forwardFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.randomId != null && message.hasOwnProperty('randomId')) {writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.randomId);}
      return writer;
    };

    /**
         * Decodes a ChannelSendMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelSendMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelSendMessage} ChannelSendMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelSendMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelSendMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.messageType = reader.int32();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          case 5:
            message.attachment = reader.string();
            break;
          case 6:
            message.location = $root.proto.RoomMessageLocation.decode(reader, reader.uint32());
            break;
          case 7:
            message.contact = $root.proto.RoomMessageContact.decode(reader, reader.uint32());
            break;
          case 8:
            message.replyTo = reader.uint64();
            break;
          case 9:
            message.forwardFrom = $root.proto.RoomMessageForwardFrom.decode(reader, reader.uint32());
            break;
          case 10:
            message.randomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelSendMessage message.
         * @function verify
         * @memberof proto.ChannelSendMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelSendMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      if (message.location != null && message.hasOwnProperty('location')) {
        let error = $root.proto.RoomMessageLocation.verify(message.location);
        if (error) {return 'location.' + error;}
      }
      if (message.contact != null && message.hasOwnProperty('contact')) {
        let error = $root.proto.RoomMessageContact.verify(message.contact);
        if (error) {return 'contact.' + error;}
      }
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {
        if (!$util.isInteger(message.replyTo) && !(message.replyTo && $util.isInteger(message.replyTo.low) && $util.isInteger(message.replyTo.high))) {return 'replyTo: integer|Long expected';}
      }
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {
        let error = $root.proto.RoomMessageForwardFrom.verify(message.forwardFrom);
        if (error) {return 'forwardFrom.' + error;}
      }
      if (message.randomId != null && message.hasOwnProperty('randomId')) {
        if (!$util.isInteger(message.randomId) && !(message.randomId && $util.isInteger(message.randomId.low) && $util.isInteger(message.randomId.high))) {return 'randomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelSendMessage;
  })();

  proto.ChannelSendMessageResponse = (function() {

    /**
         * Properties of a ChannelSendMessageResponse.
         * @memberof proto
         * @interface IChannelSendMessageResponse
         * @property {proto.Response|null} [response] ChannelSendMessageResponse response
         * @property {Long|null} [roomId] ChannelSendMessageResponse roomId
         * @property {proto.RoomMessage|null} [roomMessage] ChannelSendMessageResponse roomMessage
         */

    /**
         * Constructs a new ChannelSendMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChannelSendMessageResponse.
         * @implements IChannelSendMessageResponse
         * @constructor
         * @param {proto.IChannelSendMessageResponse=} [properties] Properties to set
         */
    function ChannelSendMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelSendMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelSendMessageResponse
         * @instance
         */
    ChannelSendMessageResponse.prototype.response = null;

    /**
         * ChannelSendMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelSendMessageResponse
         * @instance
         */
    ChannelSendMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelSendMessageResponse roomMessage.
         * @member {proto.RoomMessage|null|undefined} roomMessage
         * @memberof proto.ChannelSendMessageResponse
         * @instance
         */
    ChannelSendMessageResponse.prototype.roomMessage = null;

    /**
         * Creates a new ChannelSendMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelSendMessageResponse
         * @static
         * @param {proto.IChannelSendMessageResponse=} [properties] Properties to set
         * @returns {proto.ChannelSendMessageResponse} ChannelSendMessageResponse instance
         */
    ChannelSendMessageResponse.create = function create(properties) {
      return new ChannelSendMessageResponse(properties);
    };

    /**
         * Encodes the specified ChannelSendMessageResponse message. Does not implicitly {@link proto.ChannelSendMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelSendMessageResponse
         * @static
         * @param {proto.ChannelSendMessageResponse} message ChannelSendMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelSendMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {$root.proto.RoomMessage.encode(message.roomMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelSendMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelSendMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelSendMessageResponse} ChannelSendMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelSendMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelSendMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.roomMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelSendMessageResponse message.
         * @function verify
         * @memberof proto.ChannelSendMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelSendMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {
        let error = $root.proto.RoomMessage.verify(message.roomMessage);
        if (error) {return 'roomMessage.' + error;}
      }
      return null;
    };

    return ChannelSendMessageResponse;
  })();

  proto.ChannelSetAction = (function() {

    /**
         * Properties of a ChannelSetAction.
         * @memberof proto
         * @interface IChannelSetAction
         * @property {proto.Request|null} [request] ChannelSetAction request
         * @property {Long|null} [roomId] ChannelSetAction roomId
         * @property {proto.ClientAction|null} [action] ChannelSetAction action
         * @property {number|null} [actionId] ChannelSetAction actionId
         */

    /**
         * Constructs a new ChannelSetAction.
         * @memberof proto
         * @classdesc Represents a ChannelSetAction.
         * @implements IChannelSetAction
         * @constructor
         * @param {proto.IChannelSetAction=} [properties] Properties to set
         */
    function ChannelSetAction(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelSetAction request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelSetAction
         * @instance
         */
    ChannelSetAction.prototype.request = null;

    /**
         * ChannelSetAction roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelSetAction
         * @instance
         */
    ChannelSetAction.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelSetAction action.
         * @member {proto.ClientAction} action
         * @memberof proto.ChannelSetAction
         * @instance
         */
    ChannelSetAction.prototype.action = 0;

    /**
         * ChannelSetAction actionId.
         * @member {number} actionId
         * @memberof proto.ChannelSetAction
         * @instance
         */
    ChannelSetAction.prototype.actionId = 0;

    /**
         * Creates a new ChannelSetAction instance using the specified properties.
         * @function create
         * @memberof proto.ChannelSetAction
         * @static
         * @param {proto.IChannelSetAction=} [properties] Properties to set
         * @returns {proto.ChannelSetAction} ChannelSetAction instance
         */
    ChannelSetAction.create = function create(properties) {
      return new ChannelSetAction(properties);
    };

    /**
         * Encodes the specified ChannelSetAction message. Does not implicitly {@link proto.ChannelSetAction.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelSetAction
         * @static
         * @param {proto.ChannelSetAction} message ChannelSetAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelSetAction.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.actionId != null && message.hasOwnProperty('actionId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.actionId);}
      return writer;
    };

    /**
         * Decodes a ChannelSetAction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelSetAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelSetAction} ChannelSetAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelSetAction.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelSetAction();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.actionId = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelSetAction message.
         * @function verify
         * @memberof proto.ChannelSetAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelSetAction.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.actionId != null && message.hasOwnProperty('actionId')) {
        if (!$util.isInteger(message.actionId)) {return 'actionId: integer expected';}
      }
      return null;
    };

    return ChannelSetAction;
  })();

  proto.ChannelSetActionResponse = (function() {

    /**
         * Properties of a ChannelSetActionResponse.
         * @memberof proto
         * @interface IChannelSetActionResponse
         * @property {proto.Response|null} [response] ChannelSetActionResponse response
         * @property {Long|null} [roomId] ChannelSetActionResponse roomId
         * @property {proto.ClientAction|null} [action] ChannelSetActionResponse action
         * @property {Long|null} [userId] ChannelSetActionResponse userId
         */

    /**
         * Constructs a new ChannelSetActionResponse.
         * @memberof proto
         * @classdesc Represents a ChannelSetActionResponse.
         * @implements IChannelSetActionResponse
         * @constructor
         * @param {proto.IChannelSetActionResponse=} [properties] Properties to set
         */
    function ChannelSetActionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelSetActionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelSetActionResponse
         * @instance
         */
    ChannelSetActionResponse.prototype.response = null;

    /**
         * ChannelSetActionResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelSetActionResponse
         * @instance
         */
    ChannelSetActionResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelSetActionResponse action.
         * @member {proto.ClientAction} action
         * @memberof proto.ChannelSetActionResponse
         * @instance
         */
    ChannelSetActionResponse.prototype.action = 0;

    /**
         * ChannelSetActionResponse userId.
         * @member {Long} userId
         * @memberof proto.ChannelSetActionResponse
         * @instance
         */
    ChannelSetActionResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelSetActionResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelSetActionResponse
         * @static
         * @param {proto.IChannelSetActionResponse=} [properties] Properties to set
         * @returns {proto.ChannelSetActionResponse} ChannelSetActionResponse instance
         */
    ChannelSetActionResponse.create = function create(properties) {
      return new ChannelSetActionResponse(properties);
    };

    /**
         * Encodes the specified ChannelSetActionResponse message. Does not implicitly {@link proto.ChannelSetActionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelSetActionResponse
         * @static
         * @param {proto.ChannelSetActionResponse} message ChannelSetActionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelSetActionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a ChannelSetActionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelSetActionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelSetActionResponse} ChannelSetActionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelSetActionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelSetActionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelSetActionResponse message.
         * @function verify
         * @memberof proto.ChannelSetActionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelSetActionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return ChannelSetActionResponse;
  })();

  proto.ChannelUpdateDraft = (function() {

    /**
         * Properties of a ChannelUpdateDraft.
         * @memberof proto
         * @interface IChannelUpdateDraft
         * @property {proto.Request|null} [request] ChannelUpdateDraft request
         * @property {Long|null} [roomId] ChannelUpdateDraft roomId
         * @property {proto.RoomDraft|null} [draft] ChannelUpdateDraft draft
         */

    /**
         * Constructs a new ChannelUpdateDraft.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateDraft.
         * @implements IChannelUpdateDraft
         * @constructor
         * @param {proto.IChannelUpdateDraft=} [properties] Properties to set
         */
    function ChannelUpdateDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelUpdateDraft
         * @instance
         */
    ChannelUpdateDraft.prototype.request = null;

    /**
         * ChannelUpdateDraft roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateDraft
         * @instance
         */
    ChannelUpdateDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateDraft draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChannelUpdateDraft
         * @instance
         */
    ChannelUpdateDraft.prototype.draft = null;

    /**
         * Creates a new ChannelUpdateDraft instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateDraft
         * @static
         * @param {proto.IChannelUpdateDraft=} [properties] Properties to set
         * @returns {proto.ChannelUpdateDraft} ChannelUpdateDraft instance
         */
    ChannelUpdateDraft.create = function create(properties) {
      return new ChannelUpdateDraft(properties);
    };

    /**
         * Encodes the specified ChannelUpdateDraft message. Does not implicitly {@link proto.ChannelUpdateDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateDraft
         * @static
         * @param {proto.ChannelUpdateDraft} message ChannelUpdateDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateDraft} ChannelUpdateDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateDraft message.
         * @function verify
         * @memberof proto.ChannelUpdateDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChannelUpdateDraft;
  })();

  proto.ChannelUpdateDraftResponse = (function() {

    /**
         * Properties of a ChannelUpdateDraftResponse.
         * @memberof proto
         * @interface IChannelUpdateDraftResponse
         * @property {proto.Response|null} [response] ChannelUpdateDraftResponse response
         * @property {Long|null} [roomId] ChannelUpdateDraftResponse roomId
         * @property {proto.RoomDraft|null} [draft] ChannelUpdateDraftResponse draft
         */

    /**
         * Constructs a new ChannelUpdateDraftResponse.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateDraftResponse.
         * @implements IChannelUpdateDraftResponse
         * @constructor
         * @param {proto.IChannelUpdateDraftResponse=} [properties] Properties to set
         */
    function ChannelUpdateDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelUpdateDraftResponse
         * @instance
         */
    ChannelUpdateDraftResponse.prototype.response = null;

    /**
         * ChannelUpdateDraftResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateDraftResponse
         * @instance
         */
    ChannelUpdateDraftResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChannelUpdateDraftResponse
         * @instance
         */
    ChannelUpdateDraftResponse.prototype.draft = null;

    /**
         * Creates a new ChannelUpdateDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateDraftResponse
         * @static
         * @param {proto.IChannelUpdateDraftResponse=} [properties] Properties to set
         * @returns {proto.ChannelUpdateDraftResponse} ChannelUpdateDraftResponse instance
         */
    ChannelUpdateDraftResponse.create = function create(properties) {
      return new ChannelUpdateDraftResponse(properties);
    };

    /**
         * Encodes the specified ChannelUpdateDraftResponse message. Does not implicitly {@link proto.ChannelUpdateDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateDraftResponse
         * @static
         * @param {proto.ChannelUpdateDraftResponse} message ChannelUpdateDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateDraftResponse} ChannelUpdateDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateDraftResponse message.
         * @function verify
         * @memberof proto.ChannelUpdateDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChannelUpdateDraftResponse;
  })();

  proto.ChannelUpdateReactionStatus = (function() {

    /**
         * Properties of a ChannelUpdateReactionStatus.
         * @memberof proto
         * @interface IChannelUpdateReactionStatus
         * @property {proto.Request|null} [request] ChannelUpdateReactionStatus request
         * @property {Long|null} [roomId] ChannelUpdateReactionStatus roomId
         * @property {boolean|null} [reactionStatus] ChannelUpdateReactionStatus reactionStatus
         */

    /**
         * Constructs a new ChannelUpdateReactionStatus.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateReactionStatus.
         * @implements IChannelUpdateReactionStatus
         * @constructor
         * @param {proto.IChannelUpdateReactionStatus=} [properties] Properties to set
         */
    function ChannelUpdateReactionStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateReactionStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelUpdateReactionStatus
         * @instance
         */
    ChannelUpdateReactionStatus.prototype.request = null;

    /**
         * ChannelUpdateReactionStatus roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateReactionStatus
         * @instance
         */
    ChannelUpdateReactionStatus.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateReactionStatus reactionStatus.
         * @member {boolean} reactionStatus
         * @memberof proto.ChannelUpdateReactionStatus
         * @instance
         */
    ChannelUpdateReactionStatus.prototype.reactionStatus = false;

    /**
         * Creates a new ChannelUpdateReactionStatus instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateReactionStatus
         * @static
         * @param {proto.IChannelUpdateReactionStatus=} [properties] Properties to set
         * @returns {proto.ChannelUpdateReactionStatus} ChannelUpdateReactionStatus instance
         */
    ChannelUpdateReactionStatus.create = function create(properties) {
      return new ChannelUpdateReactionStatus(properties);
    };

    /**
         * Encodes the specified ChannelUpdateReactionStatus message. Does not implicitly {@link proto.ChannelUpdateReactionStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateReactionStatus
         * @static
         * @param {proto.ChannelUpdateReactionStatus} message ChannelUpdateReactionStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateReactionStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reactionStatus);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateReactionStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateReactionStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateReactionStatus} ChannelUpdateReactionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateReactionStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateReactionStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.reactionStatus = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateReactionStatus message.
         * @function verify
         * @memberof proto.ChannelUpdateReactionStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateReactionStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {
        if (typeof message.reactionStatus !== 'boolean') {return 'reactionStatus: boolean expected';}
      }
      return null;
    };

    return ChannelUpdateReactionStatus;
  })();

  proto.ChannelUpdateReactionStatusResponse = (function() {

    /**
         * Properties of a ChannelUpdateReactionStatusResponse.
         * @memberof proto
         * @interface IChannelUpdateReactionStatusResponse
         * @property {proto.Response|null} [response] ChannelUpdateReactionStatusResponse response
         * @property {Long|null} [roomId] ChannelUpdateReactionStatusResponse roomId
         * @property {boolean|null} [reactionStatus] ChannelUpdateReactionStatusResponse reactionStatus
         */

    /**
         * Constructs a new ChannelUpdateReactionStatusResponse.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateReactionStatusResponse.
         * @implements IChannelUpdateReactionStatusResponse
         * @constructor
         * @param {proto.IChannelUpdateReactionStatusResponse=} [properties] Properties to set
         */
    function ChannelUpdateReactionStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateReactionStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @instance
         */
    ChannelUpdateReactionStatusResponse.prototype.response = null;

    /**
         * ChannelUpdateReactionStatusResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @instance
         */
    ChannelUpdateReactionStatusResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateReactionStatusResponse reactionStatus.
         * @member {boolean} reactionStatus
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @instance
         */
    ChannelUpdateReactionStatusResponse.prototype.reactionStatus = false;

    /**
         * Creates a new ChannelUpdateReactionStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @static
         * @param {proto.IChannelUpdateReactionStatusResponse=} [properties] Properties to set
         * @returns {proto.ChannelUpdateReactionStatusResponse} ChannelUpdateReactionStatusResponse instance
         */
    ChannelUpdateReactionStatusResponse.create = function create(properties) {
      return new ChannelUpdateReactionStatusResponse(properties);
    };

    /**
         * Encodes the specified ChannelUpdateReactionStatusResponse message. Does not implicitly {@link proto.ChannelUpdateReactionStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @static
         * @param {proto.ChannelUpdateReactionStatusResponse} message ChannelUpdateReactionStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateReactionStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reactionStatus);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateReactionStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateReactionStatusResponse} ChannelUpdateReactionStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateReactionStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateReactionStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.reactionStatus = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateReactionStatusResponse message.
         * @function verify
         * @memberof proto.ChannelUpdateReactionStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateReactionStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.reactionStatus != null && message.hasOwnProperty('reactionStatus')) {
        if (typeof message.reactionStatus !== 'boolean') {return 'reactionStatus: boolean expected';}
      }
      return null;
    };

    return ChannelUpdateReactionStatusResponse;
  })();

  proto.ChannelUpdateSignature = (function() {

    /**
         * Properties of a ChannelUpdateSignature.
         * @memberof proto
         * @interface IChannelUpdateSignature
         * @property {proto.Request|null} [request] ChannelUpdateSignature request
         * @property {Long|null} [roomId] ChannelUpdateSignature roomId
         * @property {boolean|null} [signature] ChannelUpdateSignature signature
         */

    /**
         * Constructs a new ChannelUpdateSignature.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateSignature.
         * @implements IChannelUpdateSignature
         * @constructor
         * @param {proto.IChannelUpdateSignature=} [properties] Properties to set
         */
    function ChannelUpdateSignature(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateSignature request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelUpdateSignature
         * @instance
         */
    ChannelUpdateSignature.prototype.request = null;

    /**
         * ChannelUpdateSignature roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateSignature
         * @instance
         */
    ChannelUpdateSignature.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateSignature signature.
         * @member {boolean} signature
         * @memberof proto.ChannelUpdateSignature
         * @instance
         */
    ChannelUpdateSignature.prototype.signature = false;

    /**
         * Creates a new ChannelUpdateSignature instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateSignature
         * @static
         * @param {proto.IChannelUpdateSignature=} [properties] Properties to set
         * @returns {proto.ChannelUpdateSignature} ChannelUpdateSignature instance
         */
    ChannelUpdateSignature.create = function create(properties) {
      return new ChannelUpdateSignature(properties);
    };

    /**
         * Encodes the specified ChannelUpdateSignature message. Does not implicitly {@link proto.ChannelUpdateSignature.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateSignature
         * @static
         * @param {proto.ChannelUpdateSignature} message ChannelUpdateSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateSignature.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.signature != null && message.hasOwnProperty('signature')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.signature);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateSignature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateSignature} ChannelUpdateSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateSignature.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateSignature();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.signature = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateSignature message.
         * @function verify
         * @memberof proto.ChannelUpdateSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateSignature.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.signature != null && message.hasOwnProperty('signature')) {
        if (typeof message.signature !== 'boolean') {return 'signature: boolean expected';}
      }
      return null;
    };

    return ChannelUpdateSignature;
  })();

  proto.ChannelUpdateSignatureResponse = (function() {

    /**
         * Properties of a ChannelUpdateSignatureResponse.
         * @memberof proto
         * @interface IChannelUpdateSignatureResponse
         * @property {proto.Response|null} [response] ChannelUpdateSignatureResponse response
         * @property {Long|null} [roomId] ChannelUpdateSignatureResponse roomId
         * @property {boolean|null} [signature] ChannelUpdateSignatureResponse signature
         */

    /**
         * Constructs a new ChannelUpdateSignatureResponse.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateSignatureResponse.
         * @implements IChannelUpdateSignatureResponse
         * @constructor
         * @param {proto.IChannelUpdateSignatureResponse=} [properties] Properties to set
         */
    function ChannelUpdateSignatureResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateSignatureResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelUpdateSignatureResponse
         * @instance
         */
    ChannelUpdateSignatureResponse.prototype.response = null;

    /**
         * ChannelUpdateSignatureResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateSignatureResponse
         * @instance
         */
    ChannelUpdateSignatureResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChannelUpdateSignatureResponse signature.
         * @member {boolean} signature
         * @memberof proto.ChannelUpdateSignatureResponse
         * @instance
         */
    ChannelUpdateSignatureResponse.prototype.signature = false;

    /**
         * Creates a new ChannelUpdateSignatureResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateSignatureResponse
         * @static
         * @param {proto.IChannelUpdateSignatureResponse=} [properties] Properties to set
         * @returns {proto.ChannelUpdateSignatureResponse} ChannelUpdateSignatureResponse instance
         */
    ChannelUpdateSignatureResponse.create = function create(properties) {
      return new ChannelUpdateSignatureResponse(properties);
    };

    /**
         * Encodes the specified ChannelUpdateSignatureResponse message. Does not implicitly {@link proto.ChannelUpdateSignatureResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateSignatureResponse
         * @static
         * @param {proto.ChannelUpdateSignatureResponse} message ChannelUpdateSignatureResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateSignatureResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.signature != null && message.hasOwnProperty('signature')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.signature);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateSignatureResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateSignatureResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateSignatureResponse} ChannelUpdateSignatureResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateSignatureResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateSignatureResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.signature = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateSignatureResponse message.
         * @function verify
         * @memberof proto.ChannelUpdateSignatureResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateSignatureResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.signature != null && message.hasOwnProperty('signature')) {
        if (typeof message.signature !== 'boolean') {return 'signature: boolean expected';}
      }
      return null;
    };

    return ChannelUpdateSignatureResponse;
  })();

  proto.ChannelUpdateUsername = (function() {

    /**
         * Properties of a ChannelUpdateUsername.
         * @memberof proto
         * @interface IChannelUpdateUsername
         * @property {proto.Request|null} [request] ChannelUpdateUsername request
         * @property {string|null} [username] ChannelUpdateUsername username
         * @property {Long|null} [roomId] ChannelUpdateUsername roomId
         */

    /**
         * Constructs a new ChannelUpdateUsername.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateUsername.
         * @implements IChannelUpdateUsername
         * @constructor
         * @param {proto.IChannelUpdateUsername=} [properties] Properties to set
         */
    function ChannelUpdateUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChannelUpdateUsername
         * @instance
         */
    ChannelUpdateUsername.prototype.request = null;

    /**
         * ChannelUpdateUsername username.
         * @member {string} username
         * @memberof proto.ChannelUpdateUsername
         * @instance
         */
    ChannelUpdateUsername.prototype.username = '';

    /**
         * ChannelUpdateUsername roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateUsername
         * @instance
         */
    ChannelUpdateUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelUpdateUsername instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateUsername
         * @static
         * @param {proto.IChannelUpdateUsername=} [properties] Properties to set
         * @returns {proto.ChannelUpdateUsername} ChannelUpdateUsername instance
         */
    ChannelUpdateUsername.create = function create(properties) {
      return new ChannelUpdateUsername(properties);
    };

    /**
         * Encodes the specified ChannelUpdateUsername message. Does not implicitly {@link proto.ChannelUpdateUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateUsername
         * @static
         * @param {proto.ChannelUpdateUsername} message ChannelUpdateUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateUsername} ChannelUpdateUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateUsername message.
         * @function verify
         * @memberof proto.ChannelUpdateUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelUpdateUsername;
  })();

  proto.ChannelUpdateUsernameResponse = (function() {

    /**
         * Properties of a ChannelUpdateUsernameResponse.
         * @memberof proto
         * @interface IChannelUpdateUsernameResponse
         * @property {proto.Response|null} [response] ChannelUpdateUsernameResponse response
         * @property {string|null} [username] ChannelUpdateUsernameResponse username
         * @property {Long|null} [roomId] ChannelUpdateUsernameResponse roomId
         */

    /**
         * Constructs a new ChannelUpdateUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ChannelUpdateUsernameResponse.
         * @implements IChannelUpdateUsernameResponse
         * @constructor
         * @param {proto.IChannelUpdateUsernameResponse=} [properties] Properties to set
         */
    function ChannelUpdateUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChannelUpdateUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChannelUpdateUsernameResponse
         * @instance
         */
    ChannelUpdateUsernameResponse.prototype.response = null;

    /**
         * ChannelUpdateUsernameResponse username.
         * @member {string} username
         * @memberof proto.ChannelUpdateUsernameResponse
         * @instance
         */
    ChannelUpdateUsernameResponse.prototype.username = '';

    /**
         * ChannelUpdateUsernameResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChannelUpdateUsernameResponse
         * @instance
         */
    ChannelUpdateUsernameResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChannelUpdateUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChannelUpdateUsernameResponse
         * @static
         * @param {proto.IChannelUpdateUsernameResponse=} [properties] Properties to set
         * @returns {proto.ChannelUpdateUsernameResponse} ChannelUpdateUsernameResponse instance
         */
    ChannelUpdateUsernameResponse.create = function create(properties) {
      return new ChannelUpdateUsernameResponse(properties);
    };

    /**
         * Encodes the specified ChannelUpdateUsernameResponse message. Does not implicitly {@link proto.ChannelUpdateUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChannelUpdateUsernameResponse
         * @static
         * @param {proto.ChannelUpdateUsernameResponse} message ChannelUpdateUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChannelUpdateUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChannelUpdateUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChannelUpdateUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChannelUpdateUsernameResponse} ChannelUpdateUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChannelUpdateUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChannelUpdateUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChannelUpdateUsernameResponse message.
         * @function verify
         * @memberof proto.ChannelUpdateUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChannelUpdateUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChannelUpdateUsernameResponse;
  })();

  proto.ChatClearMessage = (function() {

    /**
         * Properties of a ChatClearMessage.
         * @memberof proto
         * @interface IChatClearMessage
         * @property {proto.Request|null} [request] ChatClearMessage request
         * @property {Long|null} [roomId] ChatClearMessage roomId
         * @property {Long|null} [clearId] ChatClearMessage clearId
         */

    /**
         * Constructs a new ChatClearMessage.
         * @memberof proto
         * @classdesc Represents a ChatClearMessage.
         * @implements IChatClearMessage
         * @constructor
         * @param {proto.IChatClearMessage=} [properties] Properties to set
         */
    function ChatClearMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatClearMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatClearMessage
         * @instance
         */
    ChatClearMessage.prototype.request = null;

    /**
         * ChatClearMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChatClearMessage
         * @instance
         */
    ChatClearMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatClearMessage clearId.
         * @member {Long} clearId
         * @memberof proto.ChatClearMessage
         * @instance
         */
    ChatClearMessage.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatClearMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChatClearMessage
         * @static
         * @param {proto.IChatClearMessage=} [properties] Properties to set
         * @returns {proto.ChatClearMessage} ChatClearMessage instance
         */
    ChatClearMessage.create = function create(properties) {
      return new ChatClearMessage(properties);
    };

    /**
         * Encodes the specified ChatClearMessage message. Does not implicitly {@link proto.ChatClearMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatClearMessage
         * @static
         * @param {proto.ChatClearMessage} message ChatClearMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatClearMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a ChatClearMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatClearMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatClearMessage} ChatClearMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatClearMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatClearMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatClearMessage message.
         * @function verify
         * @memberof proto.ChatClearMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatClearMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return ChatClearMessage;
  })();

  proto.ChatClearMessageResponse = (function() {

    /**
         * Properties of a ChatClearMessageResponse.
         * @memberof proto
         * @interface IChatClearMessageResponse
         * @property {proto.Response|null} [response] ChatClearMessageResponse response
         * @property {Long|null} [roomId] ChatClearMessageResponse roomId
         * @property {Long|null} [clearId] ChatClearMessageResponse clearId
         */

    /**
         * Constructs a new ChatClearMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChatClearMessageResponse.
         * @implements IChatClearMessageResponse
         * @constructor
         * @param {proto.IChatClearMessageResponse=} [properties] Properties to set
         */
    function ChatClearMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatClearMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatClearMessageResponse
         * @instance
         */
    ChatClearMessageResponse.prototype.response = null;

    /**
         * ChatClearMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatClearMessageResponse
         * @instance
         */
    ChatClearMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatClearMessageResponse clearId.
         * @member {Long} clearId
         * @memberof proto.ChatClearMessageResponse
         * @instance
         */
    ChatClearMessageResponse.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatClearMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatClearMessageResponse
         * @static
         * @param {proto.IChatClearMessageResponse=} [properties] Properties to set
         * @returns {proto.ChatClearMessageResponse} ChatClearMessageResponse instance
         */
    ChatClearMessageResponse.create = function create(properties) {
      return new ChatClearMessageResponse(properties);
    };

    /**
         * Encodes the specified ChatClearMessageResponse message. Does not implicitly {@link proto.ChatClearMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatClearMessageResponse
         * @static
         * @param {proto.ChatClearMessageResponse} message ChatClearMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatClearMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a ChatClearMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatClearMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatClearMessageResponse} ChatClearMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatClearMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatClearMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatClearMessageResponse message.
         * @function verify
         * @memberof proto.ChatClearMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatClearMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return ChatClearMessageResponse;
  })();

  proto.ChatConvertToGroup = (function() {

    /**
         * Properties of a ChatConvertToGroup.
         * @memberof proto
         * @interface IChatConvertToGroup
         * @property {proto.Request|null} [request] ChatConvertToGroup request
         * @property {Long|null} [roomId] ChatConvertToGroup roomId
         * @property {string|null} [name] ChatConvertToGroup name
         * @property {string|null} [description] ChatConvertToGroup description
         */

    /**
         * Constructs a new ChatConvertToGroup.
         * @memberof proto
         * @classdesc Represents a ChatConvertToGroup.
         * @implements IChatConvertToGroup
         * @constructor
         * @param {proto.IChatConvertToGroup=} [properties] Properties to set
         */
    function ChatConvertToGroup(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatConvertToGroup request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatConvertToGroup
         * @instance
         */
    ChatConvertToGroup.prototype.request = null;

    /**
         * ChatConvertToGroup roomId.
         * @member {Long} roomId
         * @memberof proto.ChatConvertToGroup
         * @instance
         */
    ChatConvertToGroup.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatConvertToGroup name.
         * @member {string} name
         * @memberof proto.ChatConvertToGroup
         * @instance
         */
    ChatConvertToGroup.prototype.name = '';

    /**
         * ChatConvertToGroup description.
         * @member {string} description
         * @memberof proto.ChatConvertToGroup
         * @instance
         */
    ChatConvertToGroup.prototype.description = '';

    /**
         * Creates a new ChatConvertToGroup instance using the specified properties.
         * @function create
         * @memberof proto.ChatConvertToGroup
         * @static
         * @param {proto.IChatConvertToGroup=} [properties] Properties to set
         * @returns {proto.ChatConvertToGroup} ChatConvertToGroup instance
         */
    ChatConvertToGroup.create = function create(properties) {
      return new ChatConvertToGroup(properties);
    };

    /**
         * Encodes the specified ChatConvertToGroup message. Does not implicitly {@link proto.ChatConvertToGroup.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatConvertToGroup
         * @static
         * @param {proto.ChatConvertToGroup} message ChatConvertToGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatConvertToGroup.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a ChatConvertToGroup message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatConvertToGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatConvertToGroup} ChatConvertToGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatConvertToGroup.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatConvertToGroup();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatConvertToGroup message.
         * @function verify
         * @memberof proto.ChatConvertToGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatConvertToGroup.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return ChatConvertToGroup;
  })();

  proto.ChatConvertToGroupResponse = (function() {

    /**
         * Properties of a ChatConvertToGroupResponse.
         * @memberof proto
         * @interface IChatConvertToGroupResponse
         * @property {proto.Response|null} [response] ChatConvertToGroupResponse response
         * @property {Long|null} [roomId] ChatConvertToGroupResponse roomId
         * @property {string|null} [name] ChatConvertToGroupResponse name
         * @property {string|null} [description] ChatConvertToGroupResponse description
         * @property {proto.GroupRoom.Role|null} [role] ChatConvertToGroupResponse role
         */

    /**
         * Constructs a new ChatConvertToGroupResponse.
         * @memberof proto
         * @classdesc Represents a ChatConvertToGroupResponse.
         * @implements IChatConvertToGroupResponse
         * @constructor
         * @param {proto.IChatConvertToGroupResponse=} [properties] Properties to set
         */
    function ChatConvertToGroupResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatConvertToGroupResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatConvertToGroupResponse
         * @instance
         */
    ChatConvertToGroupResponse.prototype.response = null;

    /**
         * ChatConvertToGroupResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatConvertToGroupResponse
         * @instance
         */
    ChatConvertToGroupResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatConvertToGroupResponse name.
         * @member {string} name
         * @memberof proto.ChatConvertToGroupResponse
         * @instance
         */
    ChatConvertToGroupResponse.prototype.name = '';

    /**
         * ChatConvertToGroupResponse description.
         * @member {string} description
         * @memberof proto.ChatConvertToGroupResponse
         * @instance
         */
    ChatConvertToGroupResponse.prototype.description = '';

    /**
         * ChatConvertToGroupResponse role.
         * @member {proto.GroupRoom.Role} role
         * @memberof proto.ChatConvertToGroupResponse
         * @instance
         */
    ChatConvertToGroupResponse.prototype.role = 0;

    /**
         * Creates a new ChatConvertToGroupResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatConvertToGroupResponse
         * @static
         * @param {proto.IChatConvertToGroupResponse=} [properties] Properties to set
         * @returns {proto.ChatConvertToGroupResponse} ChatConvertToGroupResponse instance
         */
    ChatConvertToGroupResponse.create = function create(properties) {
      return new ChatConvertToGroupResponse(properties);
    };

    /**
         * Encodes the specified ChatConvertToGroupResponse message. Does not implicitly {@link proto.ChatConvertToGroupResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatConvertToGroupResponse
         * @static
         * @param {proto.ChatConvertToGroupResponse} message ChatConvertToGroupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatConvertToGroupResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 5, wireType 0 =*/40).int32(message.role);}
      return writer;
    };

    /**
         * Decodes a ChatConvertToGroupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatConvertToGroupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatConvertToGroupResponse} ChatConvertToGroupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatConvertToGroupResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatConvertToGroupResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          case 5:
            message.role = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatConvertToGroupResponse message.
         * @function verify
         * @memberof proto.ChatConvertToGroupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatConvertToGroupResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      if (message.role != null && message.hasOwnProperty('role')) {
        switch (message.role) {
          default:
            return 'role: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    return ChatConvertToGroupResponse;
  })();

  proto.ChatDelete = (function() {

    /**
         * Properties of a ChatDelete.
         * @memberof proto
         * @interface IChatDelete
         * @property {proto.Request|null} [request] ChatDelete request
         * @property {Long|null} [roomId] ChatDelete roomId
         */

    /**
         * Constructs a new ChatDelete.
         * @memberof proto
         * @classdesc Represents a ChatDelete.
         * @implements IChatDelete
         * @constructor
         * @param {proto.IChatDelete=} [properties] Properties to set
         */
    function ChatDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatDelete
         * @instance
         */
    ChatDelete.prototype.request = null;

    /**
         * ChatDelete roomId.
         * @member {Long} roomId
         * @memberof proto.ChatDelete
         * @instance
         */
    ChatDelete.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatDelete instance using the specified properties.
         * @function create
         * @memberof proto.ChatDelete
         * @static
         * @param {proto.IChatDelete=} [properties] Properties to set
         * @returns {proto.ChatDelete} ChatDelete instance
         */
    ChatDelete.create = function create(properties) {
      return new ChatDelete(properties);
    };

    /**
         * Encodes the specified ChatDelete message. Does not implicitly {@link proto.ChatDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatDelete
         * @static
         * @param {proto.ChatDelete} message ChatDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChatDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatDelete} ChatDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatDelete message.
         * @function verify
         * @memberof proto.ChatDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChatDelete;
  })();

  proto.ChatDeleteResponse = (function() {

    /**
         * Properties of a ChatDeleteResponse.
         * @memberof proto
         * @interface IChatDeleteResponse
         * @property {proto.Response|null} [response] ChatDeleteResponse response
         * @property {Long|null} [roomId] ChatDeleteResponse roomId
         */

    /**
         * Constructs a new ChatDeleteResponse.
         * @memberof proto
         * @classdesc Represents a ChatDeleteResponse.
         * @implements IChatDeleteResponse
         * @constructor
         * @param {proto.IChatDeleteResponse=} [properties] Properties to set
         */
    function ChatDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatDeleteResponse
         * @instance
         */
    ChatDeleteResponse.prototype.response = null;

    /**
         * ChatDeleteResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatDeleteResponse
         * @instance
         */
    ChatDeleteResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatDeleteResponse
         * @static
         * @param {proto.IChatDeleteResponse=} [properties] Properties to set
         * @returns {proto.ChatDeleteResponse} ChatDeleteResponse instance
         */
    ChatDeleteResponse.create = function create(properties) {
      return new ChatDeleteResponse(properties);
    };

    /**
         * Encodes the specified ChatDeleteResponse message. Does not implicitly {@link proto.ChatDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatDeleteResponse
         * @static
         * @param {proto.ChatDeleteResponse} message ChatDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChatDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatDeleteResponse} ChatDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatDeleteResponse message.
         * @function verify
         * @memberof proto.ChatDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChatDeleteResponse;
  })();

  proto.ChatDeleteMessage = (function() {

    /**
         * Properties of a ChatDeleteMessage.
         * @memberof proto
         * @interface IChatDeleteMessage
         * @property {proto.Request|null} [request] ChatDeleteMessage request
         * @property {Long|null} [roomId] ChatDeleteMessage roomId
         * @property {Long|null} [messageId] ChatDeleteMessage messageId
         * @property {boolean|null} [both] ChatDeleteMessage both
         */

    /**
         * Constructs a new ChatDeleteMessage.
         * @memberof proto
         * @classdesc Represents a ChatDeleteMessage.
         * @implements IChatDeleteMessage
         * @constructor
         * @param {proto.IChatDeleteMessage=} [properties] Properties to set
         */
    function ChatDeleteMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatDeleteMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatDeleteMessage
         * @instance
         */
    ChatDeleteMessage.prototype.request = null;

    /**
         * ChatDeleteMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChatDeleteMessage
         * @instance
         */
    ChatDeleteMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatDeleteMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ChatDeleteMessage
         * @instance
         */
    ChatDeleteMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatDeleteMessage both.
         * @member {boolean} both
         * @memberof proto.ChatDeleteMessage
         * @instance
         */
    ChatDeleteMessage.prototype.both = false;

    /**
         * Creates a new ChatDeleteMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChatDeleteMessage
         * @static
         * @param {proto.IChatDeleteMessage=} [properties] Properties to set
         * @returns {proto.ChatDeleteMessage} ChatDeleteMessage instance
         */
    ChatDeleteMessage.create = function create(properties) {
      return new ChatDeleteMessage(properties);
    };

    /**
         * Encodes the specified ChatDeleteMessage message. Does not implicitly {@link proto.ChatDeleteMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatDeleteMessage
         * @static
         * @param {proto.ChatDeleteMessage} message ChatDeleteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatDeleteMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.both != null && message.hasOwnProperty('both')) {writer.uint32(/* id 4, wireType 0 =*/32).bool(message.both);}
      return writer;
    };

    /**
         * Decodes a ChatDeleteMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatDeleteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatDeleteMessage} ChatDeleteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatDeleteMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatDeleteMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.both = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatDeleteMessage message.
         * @function verify
         * @memberof proto.ChatDeleteMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatDeleteMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.both != null && message.hasOwnProperty('both')) {
        if (typeof message.both !== 'boolean') {return 'both: boolean expected';}
      }
      return null;
    };

    return ChatDeleteMessage;
  })();

  proto.ChatDeleteMessageResponse = (function() {

    /**
         * Properties of a ChatDeleteMessageResponse.
         * @memberof proto
         * @interface IChatDeleteMessageResponse
         * @property {proto.Response|null} [response] ChatDeleteMessageResponse response
         * @property {Long|null} [roomId] ChatDeleteMessageResponse roomId
         * @property {Long|null} [messageId] ChatDeleteMessageResponse messageId
         * @property {Long|null} [deleteVersion] ChatDeleteMessageResponse deleteVersion
         */

    /**
         * Constructs a new ChatDeleteMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChatDeleteMessageResponse.
         * @implements IChatDeleteMessageResponse
         * @constructor
         * @param {proto.IChatDeleteMessageResponse=} [properties] Properties to set
         */
    function ChatDeleteMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatDeleteMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatDeleteMessageResponse
         * @instance
         */
    ChatDeleteMessageResponse.prototype.response = null;

    /**
         * ChatDeleteMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatDeleteMessageResponse
         * @instance
         */
    ChatDeleteMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatDeleteMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.ChatDeleteMessageResponse
         * @instance
         */
    ChatDeleteMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatDeleteMessageResponse deleteVersion.
         * @member {Long} deleteVersion
         * @memberof proto.ChatDeleteMessageResponse
         * @instance
         */
    ChatDeleteMessageResponse.prototype.deleteVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatDeleteMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatDeleteMessageResponse
         * @static
         * @param {proto.IChatDeleteMessageResponse=} [properties] Properties to set
         * @returns {proto.ChatDeleteMessageResponse} ChatDeleteMessageResponse instance
         */
    ChatDeleteMessageResponse.create = function create(properties) {
      return new ChatDeleteMessageResponse(properties);
    };

    /**
         * Encodes the specified ChatDeleteMessageResponse message. Does not implicitly {@link proto.ChatDeleteMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatDeleteMessageResponse
         * @static
         * @param {proto.ChatDeleteMessageResponse} message ChatDeleteMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatDeleteMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.deleteVersion);}
      return writer;
    };

    /**
         * Decodes a ChatDeleteMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatDeleteMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatDeleteMessageResponse} ChatDeleteMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatDeleteMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatDeleteMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.deleteVersion = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatDeleteMessageResponse message.
         * @function verify
         * @memberof proto.ChatDeleteMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatDeleteMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {
        if (!$util.isInteger(message.deleteVersion) && !(message.deleteVersion && $util.isInteger(message.deleteVersion.low) && $util.isInteger(message.deleteVersion.high))) {return 'deleteVersion: integer|Long expected';}
      }
      return null;
    };

    return ChatDeleteMessageResponse;
  })();

  proto.ChatEditMessage = (function() {

    /**
         * Properties of a ChatEditMessage.
         * @memberof proto
         * @interface IChatEditMessage
         * @property {proto.Request|null} [request] ChatEditMessage request
         * @property {Long|null} [roomId] ChatEditMessage roomId
         * @property {Long|null} [messageId] ChatEditMessage messageId
         * @property {string|null} [message] ChatEditMessage message
         */

    /**
         * Constructs a new ChatEditMessage.
         * @memberof proto
         * @classdesc Represents a ChatEditMessage.
         * @implements IChatEditMessage
         * @constructor
         * @param {proto.IChatEditMessage=} [properties] Properties to set
         */
    function ChatEditMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatEditMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatEditMessage
         * @instance
         */
    ChatEditMessage.prototype.request = null;

    /**
         * ChatEditMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChatEditMessage
         * @instance
         */
    ChatEditMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatEditMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ChatEditMessage
         * @instance
         */
    ChatEditMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatEditMessage message.
         * @member {string} message
         * @memberof proto.ChatEditMessage
         * @instance
         */
    ChatEditMessage.prototype.message = '';

    /**
         * Creates a new ChatEditMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChatEditMessage
         * @static
         * @param {proto.IChatEditMessage=} [properties] Properties to set
         * @returns {proto.ChatEditMessage} ChatEditMessage instance
         */
    ChatEditMessage.create = function create(properties) {
      return new ChatEditMessage(properties);
    };

    /**
         * Encodes the specified ChatEditMessage message. Does not implicitly {@link proto.ChatEditMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatEditMessage
         * @static
         * @param {proto.ChatEditMessage} message ChatEditMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatEditMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      return writer;
    };

    /**
         * Decodes a ChatEditMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatEditMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatEditMessage} ChatEditMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatEditMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatEditMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatEditMessage message.
         * @function verify
         * @memberof proto.ChatEditMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatEditMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      return null;
    };

    return ChatEditMessage;
  })();

  proto.ChatEditMessageResponse = (function() {

    /**
         * Properties of a ChatEditMessageResponse.
         * @memberof proto
         * @interface IChatEditMessageResponse
         * @property {proto.Response|null} [response] ChatEditMessageResponse response
         * @property {Long|null} [roomId] ChatEditMessageResponse roomId
         * @property {Long|null} [messageId] ChatEditMessageResponse messageId
         * @property {Long|null} [messageVersion] ChatEditMessageResponse messageVersion
         * @property {string|null} [message] ChatEditMessageResponse message
         * @property {proto.RoomMessageType|null} [messageType] ChatEditMessageResponse messageType
         */

    /**
         * Constructs a new ChatEditMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChatEditMessageResponse.
         * @implements IChatEditMessageResponse
         * @constructor
         * @param {proto.IChatEditMessageResponse=} [properties] Properties to set
         */
    function ChatEditMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatEditMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.response = null;

    /**
         * ChatEditMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatEditMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatEditMessageResponse messageVersion.
         * @member {Long} messageVersion
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.messageVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatEditMessageResponse message.
         * @member {string} message
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.message = '';

    /**
         * ChatEditMessageResponse messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.ChatEditMessageResponse
         * @instance
         */
    ChatEditMessageResponse.prototype.messageType = 0;

    /**
         * Creates a new ChatEditMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatEditMessageResponse
         * @static
         * @param {proto.IChatEditMessageResponse=} [properties] Properties to set
         * @returns {proto.ChatEditMessageResponse} ChatEditMessageResponse instance
         */
    ChatEditMessageResponse.create = function create(properties) {
      return new ChatEditMessageResponse(properties);
    };

    /**
         * Encodes the specified ChatEditMessageResponse message. Does not implicitly {@link proto.ChatEditMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatEditMessageResponse
         * @static
         * @param {proto.ChatEditMessageResponse} message ChatEditMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatEditMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageVersion);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.messageType);}
      return writer;
    };

    /**
         * Decodes a ChatEditMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatEditMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatEditMessageResponse} ChatEditMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatEditMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatEditMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.messageVersion = reader.uint64();
            break;
          case 5:
            message.message = reader.string();
            break;
          case 6:
            message.messageType = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatEditMessageResponse message.
         * @function verify
         * @memberof proto.ChatEditMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatEditMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {
        if (!$util.isInteger(message.messageVersion) && !(message.messageVersion && $util.isInteger(message.messageVersion.low) && $util.isInteger(message.messageVersion.high))) {return 'messageVersion: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      return null;
    };

    return ChatEditMessageResponse;
  })();

  proto.ChatGetDraft = (function() {

    /**
         * Properties of a ChatGetDraft.
         * @memberof proto
         * @interface IChatGetDraft
         * @property {proto.Request|null} [request] ChatGetDraft request
         * @property {Long|null} [roomId] ChatGetDraft roomId
         */

    /**
         * Constructs a new ChatGetDraft.
         * @memberof proto
         * @classdesc Represents a ChatGetDraft.
         * @implements IChatGetDraft
         * @constructor
         * @param {proto.IChatGetDraft=} [properties] Properties to set
         */
    function ChatGetDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatGetDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatGetDraft
         * @instance
         */
    ChatGetDraft.prototype.request = null;

    /**
         * ChatGetDraft roomId.
         * @member {Long} roomId
         * @memberof proto.ChatGetDraft
         * @instance
         */
    ChatGetDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatGetDraft instance using the specified properties.
         * @function create
         * @memberof proto.ChatGetDraft
         * @static
         * @param {proto.IChatGetDraft=} [properties] Properties to set
         * @returns {proto.ChatGetDraft} ChatGetDraft instance
         */
    ChatGetDraft.create = function create(properties) {
      return new ChatGetDraft(properties);
    };

    /**
         * Encodes the specified ChatGetDraft message. Does not implicitly {@link proto.ChatGetDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatGetDraft
         * @static
         * @param {proto.ChatGetDraft} message ChatGetDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatGetDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ChatGetDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatGetDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatGetDraft} ChatGetDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatGetDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatGetDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatGetDraft message.
         * @function verify
         * @memberof proto.ChatGetDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatGetDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ChatGetDraft;
  })();

  proto.ChatGetDraftResponse = (function() {

    /**
         * Properties of a ChatGetDraftResponse.
         * @memberof proto
         * @interface IChatGetDraftResponse
         * @property {proto.Response|null} [response] ChatGetDraftResponse response
         * @property {proto.RoomDraft|null} [draft] ChatGetDraftResponse draft
         */

    /**
         * Constructs a new ChatGetDraftResponse.
         * @memberof proto
         * @classdesc Represents a ChatGetDraftResponse.
         * @implements IChatGetDraftResponse
         * @constructor
         * @param {proto.IChatGetDraftResponse=} [properties] Properties to set
         */
    function ChatGetDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatGetDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatGetDraftResponse
         * @instance
         */
    ChatGetDraftResponse.prototype.response = null;

    /**
         * ChatGetDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChatGetDraftResponse
         * @instance
         */
    ChatGetDraftResponse.prototype.draft = null;

    /**
         * Creates a new ChatGetDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatGetDraftResponse
         * @static
         * @param {proto.IChatGetDraftResponse=} [properties] Properties to set
         * @returns {proto.ChatGetDraftResponse} ChatGetDraftResponse instance
         */
    ChatGetDraftResponse.create = function create(properties) {
      return new ChatGetDraftResponse(properties);
    };

    /**
         * Encodes the specified ChatGetDraftResponse message. Does not implicitly {@link proto.ChatGetDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatGetDraftResponse
         * @static
         * @param {proto.ChatGetDraftResponse} message ChatGetDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatGetDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatGetDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatGetDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatGetDraftResponse} ChatGetDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatGetDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatGetDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatGetDraftResponse message.
         * @function verify
         * @memberof proto.ChatGetDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatGetDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChatGetDraftResponse;
  })();

  proto.ChatGetRoom = (function() {

    /**
         * Properties of a ChatGetRoom.
         * @memberof proto
         * @interface IChatGetRoom
         * @property {proto.Request|null} [request] ChatGetRoom request
         * @property {Long|null} [peerId] ChatGetRoom peerId
         */

    /**
         * Constructs a new ChatGetRoom.
         * @memberof proto
         * @classdesc Represents a ChatGetRoom.
         * @implements IChatGetRoom
         * @constructor
         * @param {proto.IChatGetRoom=} [properties] Properties to set
         */
    function ChatGetRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatGetRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatGetRoom
         * @instance
         */
    ChatGetRoom.prototype.request = null;

    /**
         * ChatGetRoom peerId.
         * @member {Long} peerId
         * @memberof proto.ChatGetRoom
         * @instance
         */
    ChatGetRoom.prototype.peerId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatGetRoom instance using the specified properties.
         * @function create
         * @memberof proto.ChatGetRoom
         * @static
         * @param {proto.IChatGetRoom=} [properties] Properties to set
         * @returns {proto.ChatGetRoom} ChatGetRoom instance
         */
    ChatGetRoom.create = function create(properties) {
      return new ChatGetRoom(properties);
    };

    /**
         * Encodes the specified ChatGetRoom message. Does not implicitly {@link proto.ChatGetRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatGetRoom
         * @static
         * @param {proto.ChatGetRoom} message ChatGetRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatGetRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.peerId != null && message.hasOwnProperty('peerId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.peerId);}
      return writer;
    };

    /**
         * Decodes a ChatGetRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatGetRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatGetRoom} ChatGetRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatGetRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatGetRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.peerId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatGetRoom message.
         * @function verify
         * @memberof proto.ChatGetRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatGetRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.peerId != null && message.hasOwnProperty('peerId')) {
        if (!$util.isInteger(message.peerId) && !(message.peerId && $util.isInteger(message.peerId.low) && $util.isInteger(message.peerId.high))) {return 'peerId: integer|Long expected';}
      }
      return null;
    };

    return ChatGetRoom;
  })();

  proto.ChatGetRoomResponse = (function() {

    /**
         * Properties of a ChatGetRoomResponse.
         * @memberof proto
         * @interface IChatGetRoomResponse
         * @property {proto.Response|null} [response] ChatGetRoomResponse response
         * @property {proto.Room|null} [room] ChatGetRoomResponse room
         */

    /**
         * Constructs a new ChatGetRoomResponse.
         * @memberof proto
         * @classdesc Represents a ChatGetRoomResponse.
         * @implements IChatGetRoomResponse
         * @constructor
         * @param {proto.IChatGetRoomResponse=} [properties] Properties to set
         */
    function ChatGetRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatGetRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatGetRoomResponse
         * @instance
         */
    ChatGetRoomResponse.prototype.response = null;

    /**
         * ChatGetRoomResponse room.
         * @member {proto.Room|null|undefined} room
         * @memberof proto.ChatGetRoomResponse
         * @instance
         */
    ChatGetRoomResponse.prototype.room = null;

    /**
         * Creates a new ChatGetRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatGetRoomResponse
         * @static
         * @param {proto.IChatGetRoomResponse=} [properties] Properties to set
         * @returns {proto.ChatGetRoomResponse} ChatGetRoomResponse instance
         */
    ChatGetRoomResponse.create = function create(properties) {
      return new ChatGetRoomResponse(properties);
    };

    /**
         * Encodes the specified ChatGetRoomResponse message. Does not implicitly {@link proto.ChatGetRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatGetRoomResponse
         * @static
         * @param {proto.ChatGetRoomResponse} message ChatGetRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatGetRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.room != null && message.hasOwnProperty('room')) {$root.proto.Room.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatGetRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatGetRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatGetRoomResponse} ChatGetRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatGetRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatGetRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.room = $root.proto.Room.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatGetRoomResponse message.
         * @function verify
         * @memberof proto.ChatGetRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatGetRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.room != null && message.hasOwnProperty('room')) {
        let error = $root.proto.Room.verify(message.room);
        if (error) {return 'room.' + error;}
      }
      return null;
    };

    return ChatGetRoomResponse;
  })();

  proto.ChatSendMessage = (function() {

    /**
         * Properties of a ChatSendMessage.
         * @memberof proto
         * @interface IChatSendMessage
         * @property {proto.Request|null} [request] ChatSendMessage request
         * @property {proto.RoomMessageType|null} [messageType] ChatSendMessage messageType
         * @property {Long|null} [roomId] ChatSendMessage roomId
         * @property {string|null} [message] ChatSendMessage message
         * @property {string|null} [attachment] ChatSendMessage attachment
         * @property {proto.RoomMessageLocation|null} [location] ChatSendMessage location
         * @property {proto.RoomMessageContact|null} [contact] ChatSendMessage contact
         * @property {Long|null} [replyTo] ChatSendMessage replyTo
         * @property {proto.RoomMessageForwardFrom|null} [forwardFrom] ChatSendMessage forwardFrom
         * @property {Long|null} [randomId] ChatSendMessage randomId
         */

    /**
         * Constructs a new ChatSendMessage.
         * @memberof proto
         * @classdesc Represents a ChatSendMessage.
         * @implements IChatSendMessage
         * @constructor
         * @param {proto.IChatSendMessage=} [properties] Properties to set
         */
    function ChatSendMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatSendMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.request = null;

    /**
         * ChatSendMessage messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.messageType = 0;

    /**
         * ChatSendMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatSendMessage message.
         * @member {string} message
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.message = '';

    /**
         * ChatSendMessage attachment.
         * @member {string} attachment
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.attachment = '';

    /**
         * ChatSendMessage location.
         * @member {proto.RoomMessageLocation|null|undefined} location
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.location = null;

    /**
         * ChatSendMessage contact.
         * @member {proto.RoomMessageContact|null|undefined} contact
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.contact = null;

    /**
         * ChatSendMessage replyTo.
         * @member {Long} replyTo
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.replyTo = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatSendMessage forwardFrom.
         * @member {proto.RoomMessageForwardFrom|null|undefined} forwardFrom
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.forwardFrom = null;

    /**
         * ChatSendMessage randomId.
         * @member {Long} randomId
         * @memberof proto.ChatSendMessage
         * @instance
         */
    ChatSendMessage.prototype.randomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatSendMessage instance using the specified properties.
         * @function create
         * @memberof proto.ChatSendMessage
         * @static
         * @param {proto.IChatSendMessage=} [properties] Properties to set
         * @returns {proto.ChatSendMessage} ChatSendMessage instance
         */
    ChatSendMessage.create = function create(properties) {
      return new ChatSendMessage(properties);
    };

    /**
         * Encodes the specified ChatSendMessage message. Does not implicitly {@link proto.ChatSendMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatSendMessage
         * @static
         * @param {proto.ChatSendMessage} message ChatSendMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatSendMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messageType);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.attachment);}
      if (message.location != null && message.hasOwnProperty('location')) {$root.proto.RoomMessageLocation.encode(message.location, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();}
      if (message.contact != null && message.hasOwnProperty('contact')) {$root.proto.RoomMessageContact.encode(message.contact, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.replyTo);}
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {$root.proto.RoomMessageForwardFrom.encode(message.forwardFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.randomId != null && message.hasOwnProperty('randomId')) {writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.randomId);}
      return writer;
    };

    /**
         * Decodes a ChatSendMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatSendMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatSendMessage} ChatSendMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatSendMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatSendMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.messageType = reader.int32();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          case 5:
            message.attachment = reader.string();
            break;
          case 6:
            message.location = $root.proto.RoomMessageLocation.decode(reader, reader.uint32());
            break;
          case 7:
            message.contact = $root.proto.RoomMessageContact.decode(reader, reader.uint32());
            break;
          case 8:
            message.replyTo = reader.uint64();
            break;
          case 9:
            message.forwardFrom = $root.proto.RoomMessageForwardFrom.decode(reader, reader.uint32());
            break;
          case 10:
            message.randomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatSendMessage message.
         * @function verify
         * @memberof proto.ChatSendMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatSendMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      if (message.location != null && message.hasOwnProperty('location')) {
        let error = $root.proto.RoomMessageLocation.verify(message.location);
        if (error) {return 'location.' + error;}
      }
      if (message.contact != null && message.hasOwnProperty('contact')) {
        let error = $root.proto.RoomMessageContact.verify(message.contact);
        if (error) {return 'contact.' + error;}
      }
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {
        if (!$util.isInteger(message.replyTo) && !(message.replyTo && $util.isInteger(message.replyTo.low) && $util.isInteger(message.replyTo.high))) {return 'replyTo: integer|Long expected';}
      }
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {
        let error = $root.proto.RoomMessageForwardFrom.verify(message.forwardFrom);
        if (error) {return 'forwardFrom.' + error;}
      }
      if (message.randomId != null && message.hasOwnProperty('randomId')) {
        if (!$util.isInteger(message.randomId) && !(message.randomId && $util.isInteger(message.randomId.low) && $util.isInteger(message.randomId.high))) {return 'randomId: integer|Long expected';}
      }
      return null;
    };

    return ChatSendMessage;
  })();

  proto.ChatSendMessageResponse = (function() {

    /**
         * Properties of a ChatSendMessageResponse.
         * @memberof proto
         * @interface IChatSendMessageResponse
         * @property {proto.Response|null} [response] ChatSendMessageResponse response
         * @property {Long|null} [roomId] ChatSendMessageResponse roomId
         * @property {proto.RoomMessage|null} [roomMessage] ChatSendMessageResponse roomMessage
         */

    /**
         * Constructs a new ChatSendMessageResponse.
         * @memberof proto
         * @classdesc Represents a ChatSendMessageResponse.
         * @implements IChatSendMessageResponse
         * @constructor
         * @param {proto.IChatSendMessageResponse=} [properties] Properties to set
         */
    function ChatSendMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatSendMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatSendMessageResponse
         * @instance
         */
    ChatSendMessageResponse.prototype.response = null;

    /**
         * ChatSendMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatSendMessageResponse
         * @instance
         */
    ChatSendMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatSendMessageResponse roomMessage.
         * @member {proto.RoomMessage|null|undefined} roomMessage
         * @memberof proto.ChatSendMessageResponse
         * @instance
         */
    ChatSendMessageResponse.prototype.roomMessage = null;

    /**
         * Creates a new ChatSendMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatSendMessageResponse
         * @static
         * @param {proto.IChatSendMessageResponse=} [properties] Properties to set
         * @returns {proto.ChatSendMessageResponse} ChatSendMessageResponse instance
         */
    ChatSendMessageResponse.create = function create(properties) {
      return new ChatSendMessageResponse(properties);
    };

    /**
         * Encodes the specified ChatSendMessageResponse message. Does not implicitly {@link proto.ChatSendMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatSendMessageResponse
         * @static
         * @param {proto.ChatSendMessageResponse} message ChatSendMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatSendMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {$root.proto.RoomMessage.encode(message.roomMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatSendMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatSendMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatSendMessageResponse} ChatSendMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatSendMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatSendMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.roomMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatSendMessageResponse message.
         * @function verify
         * @memberof proto.ChatSendMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatSendMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {
        let error = $root.proto.RoomMessage.verify(message.roomMessage);
        if (error) {return 'roomMessage.' + error;}
      }
      return null;
    };

    return ChatSendMessageResponse;
  })();

  proto.ChatSetAction = (function() {

    /**
         * Properties of a ChatSetAction.
         * @memberof proto
         * @interface IChatSetAction
         * @property {proto.Request|null} [request] ChatSetAction request
         * @property {Long|null} [roomId] ChatSetAction roomId
         * @property {proto.ClientAction|null} [action] ChatSetAction action
         * @property {number|null} [actionId] ChatSetAction actionId
         */

    /**
         * Constructs a new ChatSetAction.
         * @memberof proto
         * @classdesc Represents a ChatSetAction.
         * @implements IChatSetAction
         * @constructor
         * @param {proto.IChatSetAction=} [properties] Properties to set
         */
    function ChatSetAction(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatSetAction request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatSetAction
         * @instance
         */
    ChatSetAction.prototype.request = null;

    /**
         * ChatSetAction roomId.
         * @member {Long} roomId
         * @memberof proto.ChatSetAction
         * @instance
         */
    ChatSetAction.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatSetAction action.
         * @member {proto.ClientAction} action
         * @memberof proto.ChatSetAction
         * @instance
         */
    ChatSetAction.prototype.action = 0;

    /**
         * ChatSetAction actionId.
         * @member {number} actionId
         * @memberof proto.ChatSetAction
         * @instance
         */
    ChatSetAction.prototype.actionId = 0;

    /**
         * Creates a new ChatSetAction instance using the specified properties.
         * @function create
         * @memberof proto.ChatSetAction
         * @static
         * @param {proto.IChatSetAction=} [properties] Properties to set
         * @returns {proto.ChatSetAction} ChatSetAction instance
         */
    ChatSetAction.create = function create(properties) {
      return new ChatSetAction(properties);
    };

    /**
         * Encodes the specified ChatSetAction message. Does not implicitly {@link proto.ChatSetAction.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatSetAction
         * @static
         * @param {proto.ChatSetAction} message ChatSetAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatSetAction.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.actionId != null && message.hasOwnProperty('actionId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.actionId);}
      return writer;
    };

    /**
         * Decodes a ChatSetAction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatSetAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatSetAction} ChatSetAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatSetAction.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatSetAction();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.actionId = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatSetAction message.
         * @function verify
         * @memberof proto.ChatSetAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatSetAction.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.actionId != null && message.hasOwnProperty('actionId')) {
        if (!$util.isInteger(message.actionId)) {return 'actionId: integer expected';}
      }
      return null;
    };

    return ChatSetAction;
  })();

  proto.ChatSetActionResponse = (function() {

    /**
         * Properties of a ChatSetActionResponse.
         * @memberof proto
         * @interface IChatSetActionResponse
         * @property {proto.Response|null} [response] ChatSetActionResponse response
         * @property {Long|null} [roomId] ChatSetActionResponse roomId
         * @property {proto.ClientAction|null} [action] ChatSetActionResponse action
         * @property {Long|null} [userId] ChatSetActionResponse userId
         */

    /**
         * Constructs a new ChatSetActionResponse.
         * @memberof proto
         * @classdesc Represents a ChatSetActionResponse.
         * @implements IChatSetActionResponse
         * @constructor
         * @param {proto.IChatSetActionResponse=} [properties] Properties to set
         */
    function ChatSetActionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatSetActionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatSetActionResponse
         * @instance
         */
    ChatSetActionResponse.prototype.response = null;

    /**
         * ChatSetActionResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatSetActionResponse
         * @instance
         */
    ChatSetActionResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatSetActionResponse action.
         * @member {proto.ClientAction} action
         * @memberof proto.ChatSetActionResponse
         * @instance
         */
    ChatSetActionResponse.prototype.action = 0;

    /**
         * ChatSetActionResponse userId.
         * @member {Long} userId
         * @memberof proto.ChatSetActionResponse
         * @instance
         */
    ChatSetActionResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ChatSetActionResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatSetActionResponse
         * @static
         * @param {proto.IChatSetActionResponse=} [properties] Properties to set
         * @returns {proto.ChatSetActionResponse} ChatSetActionResponse instance
         */
    ChatSetActionResponse.create = function create(properties) {
      return new ChatSetActionResponse(properties);
    };

    /**
         * Encodes the specified ChatSetActionResponse message. Does not implicitly {@link proto.ChatSetActionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatSetActionResponse
         * @static
         * @param {proto.ChatSetActionResponse} message ChatSetActionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatSetActionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a ChatSetActionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatSetActionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatSetActionResponse} ChatSetActionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatSetActionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatSetActionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatSetActionResponse message.
         * @function verify
         * @memberof proto.ChatSetActionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatSetActionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return ChatSetActionResponse;
  })();

  proto.ChatUpdateDraft = (function() {

    /**
         * Properties of a ChatUpdateDraft.
         * @memberof proto
         * @interface IChatUpdateDraft
         * @property {proto.Request|null} [request] ChatUpdateDraft request
         * @property {Long|null} [roomId] ChatUpdateDraft roomId
         * @property {proto.RoomDraft|null} [draft] ChatUpdateDraft draft
         */

    /**
         * Constructs a new ChatUpdateDraft.
         * @memberof proto
         * @classdesc Represents a ChatUpdateDraft.
         * @implements IChatUpdateDraft
         * @constructor
         * @param {proto.IChatUpdateDraft=} [properties] Properties to set
         */
    function ChatUpdateDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatUpdateDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatUpdateDraft
         * @instance
         */
    ChatUpdateDraft.prototype.request = null;

    /**
         * ChatUpdateDraft roomId.
         * @member {Long} roomId
         * @memberof proto.ChatUpdateDraft
         * @instance
         */
    ChatUpdateDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateDraft draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChatUpdateDraft
         * @instance
         */
    ChatUpdateDraft.prototype.draft = null;

    /**
         * Creates a new ChatUpdateDraft instance using the specified properties.
         * @function create
         * @memberof proto.ChatUpdateDraft
         * @static
         * @param {proto.IChatUpdateDraft=} [properties] Properties to set
         * @returns {proto.ChatUpdateDraft} ChatUpdateDraft instance
         */
    ChatUpdateDraft.create = function create(properties) {
      return new ChatUpdateDraft(properties);
    };

    /**
         * Encodes the specified ChatUpdateDraft message. Does not implicitly {@link proto.ChatUpdateDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatUpdateDraft
         * @static
         * @param {proto.ChatUpdateDraft} message ChatUpdateDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatUpdateDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatUpdateDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatUpdateDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatUpdateDraft} ChatUpdateDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatUpdateDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatUpdateDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatUpdateDraft message.
         * @function verify
         * @memberof proto.ChatUpdateDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatUpdateDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChatUpdateDraft;
  })();

  proto.ChatUpdateDraftResponse = (function() {

    /**
         * Properties of a ChatUpdateDraftResponse.
         * @memberof proto
         * @interface IChatUpdateDraftResponse
         * @property {proto.Response|null} [response] ChatUpdateDraftResponse response
         * @property {Long|null} [roomId] ChatUpdateDraftResponse roomId
         * @property {proto.RoomDraft|null} [draft] ChatUpdateDraftResponse draft
         */

    /**
         * Constructs a new ChatUpdateDraftResponse.
         * @memberof proto
         * @classdesc Represents a ChatUpdateDraftResponse.
         * @implements IChatUpdateDraftResponse
         * @constructor
         * @param {proto.IChatUpdateDraftResponse=} [properties] Properties to set
         */
    function ChatUpdateDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatUpdateDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatUpdateDraftResponse
         * @instance
         */
    ChatUpdateDraftResponse.prototype.response = null;

    /**
         * ChatUpdateDraftResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatUpdateDraftResponse
         * @instance
         */
    ChatUpdateDraftResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.ChatUpdateDraftResponse
         * @instance
         */
    ChatUpdateDraftResponse.prototype.draft = null;

    /**
         * Creates a new ChatUpdateDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatUpdateDraftResponse
         * @static
         * @param {proto.IChatUpdateDraftResponse=} [properties] Properties to set
         * @returns {proto.ChatUpdateDraftResponse} ChatUpdateDraftResponse instance
         */
    ChatUpdateDraftResponse.create = function create(properties) {
      return new ChatUpdateDraftResponse(properties);
    };

    /**
         * Encodes the specified ChatUpdateDraftResponse message. Does not implicitly {@link proto.ChatUpdateDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatUpdateDraftResponse
         * @static
         * @param {proto.ChatUpdateDraftResponse} message ChatUpdateDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatUpdateDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ChatUpdateDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatUpdateDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatUpdateDraftResponse} ChatUpdateDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatUpdateDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatUpdateDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatUpdateDraftResponse message.
         * @function verify
         * @memberof proto.ChatUpdateDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatUpdateDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return ChatUpdateDraftResponse;
  })();

  proto.ChatUpdateStatus = (function() {

    /**
         * Properties of a ChatUpdateStatus.
         * @memberof proto
         * @interface IChatUpdateStatus
         * @property {proto.Request|null} [request] ChatUpdateStatus request
         * @property {Long|null} [roomId] ChatUpdateStatus roomId
         * @property {Long|null} [messageId] ChatUpdateStatus messageId
         * @property {proto.RoomMessageStatus|null} [status] ChatUpdateStatus status
         */

    /**
         * Constructs a new ChatUpdateStatus.
         * @memberof proto
         * @classdesc Represents a ChatUpdateStatus.
         * @implements IChatUpdateStatus
         * @constructor
         * @param {proto.IChatUpdateStatus=} [properties] Properties to set
         */
    function ChatUpdateStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatUpdateStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ChatUpdateStatus
         * @instance
         */
    ChatUpdateStatus.prototype.request = null;

    /**
         * ChatUpdateStatus roomId.
         * @member {Long} roomId
         * @memberof proto.ChatUpdateStatus
         * @instance
         */
    ChatUpdateStatus.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateStatus messageId.
         * @member {Long} messageId
         * @memberof proto.ChatUpdateStatus
         * @instance
         */
    ChatUpdateStatus.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateStatus status.
         * @member {proto.RoomMessageStatus} status
         * @memberof proto.ChatUpdateStatus
         * @instance
         */
    ChatUpdateStatus.prototype.status = 0;

    /**
         * Creates a new ChatUpdateStatus instance using the specified properties.
         * @function create
         * @memberof proto.ChatUpdateStatus
         * @static
         * @param {proto.IChatUpdateStatus=} [properties] Properties to set
         * @returns {proto.ChatUpdateStatus} ChatUpdateStatus instance
         */
    ChatUpdateStatus.create = function create(properties) {
      return new ChatUpdateStatus(properties);
    };

    /**
         * Encodes the specified ChatUpdateStatus message. Does not implicitly {@link proto.ChatUpdateStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatUpdateStatus
         * @static
         * @param {proto.ChatUpdateStatus} message ChatUpdateStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatUpdateStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a ChatUpdateStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatUpdateStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatUpdateStatus} ChatUpdateStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatUpdateStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatUpdateStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatUpdateStatus message.
         * @function verify
         * @memberof proto.ChatUpdateStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatUpdateStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      return null;
    };

    return ChatUpdateStatus;
  })();

  proto.ChatUpdateStatusResponse = (function() {

    /**
         * Properties of a ChatUpdateStatusResponse.
         * @memberof proto
         * @interface IChatUpdateStatusResponse
         * @property {proto.Response|null} [response] ChatUpdateStatusResponse response
         * @property {Long|null} [roomId] ChatUpdateStatusResponse roomId
         * @property {Long|null} [messageId] ChatUpdateStatusResponse messageId
         * @property {proto.RoomMessageStatus|null} [status] ChatUpdateStatusResponse status
         * @property {Long|null} [statusVersion] ChatUpdateStatusResponse statusVersion
         * @property {string|null} [updaterAuthorHash] ChatUpdateStatusResponse updaterAuthorHash
         */

    /**
         * Constructs a new ChatUpdateStatusResponse.
         * @memberof proto
         * @classdesc Represents a ChatUpdateStatusResponse.
         * @implements IChatUpdateStatusResponse
         * @constructor
         * @param {proto.IChatUpdateStatusResponse=} [properties] Properties to set
         */
    function ChatUpdateStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ChatUpdateStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.response = null;

    /**
         * ChatUpdateStatusResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateStatusResponse messageId.
         * @member {Long} messageId
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateStatusResponse status.
         * @member {proto.RoomMessageStatus} status
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.status = 0;

    /**
         * ChatUpdateStatusResponse statusVersion.
         * @member {Long} statusVersion
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.statusVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ChatUpdateStatusResponse updaterAuthorHash.
         * @member {string} updaterAuthorHash
         * @memberof proto.ChatUpdateStatusResponse
         * @instance
         */
    ChatUpdateStatusResponse.prototype.updaterAuthorHash = '';

    /**
         * Creates a new ChatUpdateStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.ChatUpdateStatusResponse
         * @static
         * @param {proto.IChatUpdateStatusResponse=} [properties] Properties to set
         * @returns {proto.ChatUpdateStatusResponse} ChatUpdateStatusResponse instance
         */
    ChatUpdateStatusResponse.create = function create(properties) {
      return new ChatUpdateStatusResponse(properties);
    };

    /**
         * Encodes the specified ChatUpdateStatusResponse message. Does not implicitly {@link proto.ChatUpdateStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ChatUpdateStatusResponse
         * @static
         * @param {proto.ChatUpdateStatusResponse} message ChatUpdateStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ChatUpdateStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);}
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.statusVersion);}
      if (message.updaterAuthorHash != null && message.hasOwnProperty('updaterAuthorHash')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.updaterAuthorHash);}
      return writer;
    };

    /**
         * Decodes a ChatUpdateStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ChatUpdateStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ChatUpdateStatusResponse} ChatUpdateStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ChatUpdateStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ChatUpdateStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.status = reader.int32();
            break;
          case 5:
            message.statusVersion = reader.uint64();
            break;
          case 6:
            message.updaterAuthorHash = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ChatUpdateStatusResponse message.
         * @function verify
         * @memberof proto.ChatUpdateStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ChatUpdateStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {
        if (!$util.isInteger(message.statusVersion) && !(message.statusVersion && $util.isInteger(message.statusVersion.low) && $util.isInteger(message.statusVersion.high))) {return 'statusVersion: integer|Long expected';}
      }
      if (message.updaterAuthorHash != null && message.hasOwnProperty('updaterAuthorHash')) {
        if (!$util.isString(message.updaterAuthorHash)) {return 'updaterAuthorHash: string expected';}
      }
      return null;
    };

    return ChatUpdateStatusResponse;
  })();

  proto.ClientCheckInviteLink = (function() {

    /**
         * Properties of a ClientCheckInviteLink.
         * @memberof proto
         * @interface IClientCheckInviteLink
         * @property {proto.Request|null} [request] ClientCheckInviteLink request
         * @property {string|null} [inviteToken] ClientCheckInviteLink inviteToken
         */

    /**
         * Constructs a new ClientCheckInviteLink.
         * @memberof proto
         * @classdesc Represents a ClientCheckInviteLink.
         * @implements IClientCheckInviteLink
         * @constructor
         * @param {proto.IClientCheckInviteLink=} [properties] Properties to set
         */
    function ClientCheckInviteLink(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientCheckInviteLink request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientCheckInviteLink
         * @instance
         */
    ClientCheckInviteLink.prototype.request = null;

    /**
         * ClientCheckInviteLink inviteToken.
         * @member {string} inviteToken
         * @memberof proto.ClientCheckInviteLink
         * @instance
         */
    ClientCheckInviteLink.prototype.inviteToken = '';

    /**
         * Creates a new ClientCheckInviteLink instance using the specified properties.
         * @function create
         * @memberof proto.ClientCheckInviteLink
         * @static
         * @param {proto.IClientCheckInviteLink=} [properties] Properties to set
         * @returns {proto.ClientCheckInviteLink} ClientCheckInviteLink instance
         */
    ClientCheckInviteLink.create = function create(properties) {
      return new ClientCheckInviteLink(properties);
    };

    /**
         * Encodes the specified ClientCheckInviteLink message. Does not implicitly {@link proto.ClientCheckInviteLink.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientCheckInviteLink
         * @static
         * @param {proto.ClientCheckInviteLink} message ClientCheckInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientCheckInviteLink.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteToken);}
      return writer;
    };

    /**
         * Decodes a ClientCheckInviteLink message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientCheckInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientCheckInviteLink} ClientCheckInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientCheckInviteLink.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCheckInviteLink();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.inviteToken = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientCheckInviteLink message.
         * @function verify
         * @memberof proto.ClientCheckInviteLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientCheckInviteLink.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
        if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
      }
      return null;
    };

    return ClientCheckInviteLink;
  })();

  proto.ClientCheckInviteLinkResponse = (function() {

    /**
         * Properties of a ClientCheckInviteLinkResponse.
         * @memberof proto
         * @interface IClientCheckInviteLinkResponse
         * @property {proto.Response|null} [response] ClientCheckInviteLinkResponse response
         * @property {proto.Room|null} [room] ClientCheckInviteLinkResponse room
         */

    /**
         * Constructs a new ClientCheckInviteLinkResponse.
         * @memberof proto
         * @classdesc Represents a ClientCheckInviteLinkResponse.
         * @implements IClientCheckInviteLinkResponse
         * @constructor
         * @param {proto.IClientCheckInviteLinkResponse=} [properties] Properties to set
         */
    function ClientCheckInviteLinkResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientCheckInviteLinkResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientCheckInviteLinkResponse
         * @instance
         */
    ClientCheckInviteLinkResponse.prototype.response = null;

    /**
         * ClientCheckInviteLinkResponse room.
         * @member {proto.Room|null|undefined} room
         * @memberof proto.ClientCheckInviteLinkResponse
         * @instance
         */
    ClientCheckInviteLinkResponse.prototype.room = null;

    /**
         * Creates a new ClientCheckInviteLinkResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientCheckInviteLinkResponse
         * @static
         * @param {proto.IClientCheckInviteLinkResponse=} [properties] Properties to set
         * @returns {proto.ClientCheckInviteLinkResponse} ClientCheckInviteLinkResponse instance
         */
    ClientCheckInviteLinkResponse.create = function create(properties) {
      return new ClientCheckInviteLinkResponse(properties);
    };

    /**
         * Encodes the specified ClientCheckInviteLinkResponse message. Does not implicitly {@link proto.ClientCheckInviteLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientCheckInviteLinkResponse
         * @static
         * @param {proto.ClientCheckInviteLinkResponse} message ClientCheckInviteLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientCheckInviteLinkResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.room != null && message.hasOwnProperty('room')) {$root.proto.Room.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientCheckInviteLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientCheckInviteLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientCheckInviteLinkResponse} ClientCheckInviteLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientCheckInviteLinkResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCheckInviteLinkResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.room = $root.proto.Room.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientCheckInviteLinkResponse message.
         * @function verify
         * @memberof proto.ClientCheckInviteLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientCheckInviteLinkResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.room != null && message.hasOwnProperty('room')) {
        let error = $root.proto.Room.verify(message.room);
        if (error) {return 'room.' + error;}
      }
      return null;
    };

    return ClientCheckInviteLinkResponse;
  })();

  proto.ClientCondition = (function() {

    /**
         * Properties of a ClientCondition.
         * @memberof proto
         * @interface IClientCondition
         * @property {proto.Request|null} [request] ClientCondition request
         * @property {Array.<proto.ClientCondition.Room>|null} [rooms] ClientCondition rooms
         */

    /**
         * Constructs a new ClientCondition.
         * @memberof proto
         * @classdesc Represents a ClientCondition.
         * @implements IClientCondition
         * @constructor
         * @param {proto.IClientCondition=} [properties] Properties to set
         */
    function ClientCondition(properties) {
      this.rooms = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientCondition request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientCondition
         * @instance
         */
    ClientCondition.prototype.request = null;

    /**
         * ClientCondition rooms.
         * @member {Array.<proto.ClientCondition.Room>} rooms
         * @memberof proto.ClientCondition
         * @instance
         */
    ClientCondition.prototype.rooms = $util.emptyArray;

    /**
         * Creates a new ClientCondition instance using the specified properties.
         * @function create
         * @memberof proto.ClientCondition
         * @static
         * @param {proto.IClientCondition=} [properties] Properties to set
         * @returns {proto.ClientCondition} ClientCondition instance
         */
    ClientCondition.create = function create(properties) {
      return new ClientCondition(properties);
    };

    /**
         * Encodes the specified ClientCondition message. Does not implicitly {@link proto.ClientCondition.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientCondition
         * @static
         * @param {proto.ClientCondition} message ClientCondition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientCondition.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.rooms != null && message.rooms.length) {
        for (let i = 0; i < message.rooms.length; ++i) {$root.proto.ClientCondition.Room.encode(message.rooms[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ClientCondition message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientCondition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientCondition} ClientCondition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientCondition.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCondition();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.rooms && message.rooms.length)) {message.rooms = [];}
            message.rooms.push($root.proto.ClientCondition.Room.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientCondition message.
         * @function verify
         * @memberof proto.ClientCondition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientCondition.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.rooms != null && message.hasOwnProperty('rooms')) {
        if (!Array.isArray(message.rooms)) {return 'rooms: array expected';}
        for (let i = 0; i < message.rooms.length; ++i) {
          let error = $root.proto.ClientCondition.Room.verify(message.rooms[i]);
          if (error) {return 'rooms.' + error;}
        }
      }
      return null;
    };

    ClientCondition.Room = (function() {

      /**
             * Properties of a Room.
             * @memberof proto.ClientCondition
             * @interface IRoom
             * @property {Long|null} [roomId] Room roomId
             * @property {Long|null} [messageVersion] Room messageVersion
             * @property {Long|null} [statusVersion] Room statusVersion
             * @property {Long|null} [deleteVersion] Room deleteVersion
             * @property {Array.<Long>|null} [offlineDeletedDeprecated] Room offlineDeletedDeprecated
             * @property {Array.<proto.ClientCondition.Room.OfflineEdited>|null} [offlineEdited] Room offlineEdited
             * @property {Array.<Long>|null} [offlineSeen] Room offlineSeen
             * @property {Long|null} [clearId] Room clearId
             * @property {Long|null} [cacheStartId] Room cacheStartId
             * @property {Long|null} [cacheEndId] Room cacheEndId
             * @property {proto.ClientCondition.Room.OfflineMute|null} [offlineMute] Room offlineMute
             * @property {Array.<Long>|null} [offlineListened] Room offlineListened
             * @property {Array.<proto.ClientCondition.Room.OfflineDeleted>|null} [offlineDeleted] Room offlineDeleted
             */

      /**
             * Constructs a new Room.
             * @memberof proto.ClientCondition
             * @classdesc Represents a Room.
             * @implements IRoom
             * @constructor
             * @param {proto.ClientCondition.IRoom=} [properties] Properties to set
             */
      function Room(properties) {
        this.offlineDeletedDeprecated = [];
        this.offlineEdited = [];
        this.offlineSeen = [];
        this.offlineListened = [];
        this.offlineDeleted = [];
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Room roomId.
             * @member {Long} roomId
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room messageVersion.
             * @member {Long} messageVersion
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.messageVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room statusVersion.
             * @member {Long} statusVersion
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.statusVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room deleteVersion.
             * @member {Long} deleteVersion
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.deleteVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room offlineDeletedDeprecated.
             * @member {Array.<Long>} offlineDeletedDeprecated
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineDeletedDeprecated = $util.emptyArray;

      /**
             * Room offlineEdited.
             * @member {Array.<proto.ClientCondition.Room.OfflineEdited>} offlineEdited
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineEdited = $util.emptyArray;

      /**
             * Room offlineSeen.
             * @member {Array.<Long>} offlineSeen
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineSeen = $util.emptyArray;

      /**
             * Room clearId.
             * @member {Long} clearId
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room cacheStartId.
             * @member {Long} cacheStartId
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.cacheStartId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room cacheEndId.
             * @member {Long} cacheEndId
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.cacheEndId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Room offlineMute.
             * @member {proto.ClientCondition.Room.OfflineMute} offlineMute
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineMute = 0;

      /**
             * Room offlineListened.
             * @member {Array.<Long>} offlineListened
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineListened = $util.emptyArray;

      /**
             * Room offlineDeleted.
             * @member {Array.<proto.ClientCondition.Room.OfflineDeleted>} offlineDeleted
             * @memberof proto.ClientCondition.Room
             * @instance
             */
      Room.prototype.offlineDeleted = $util.emptyArray;

      /**
             * Creates a new Room instance using the specified properties.
             * @function create
             * @memberof proto.ClientCondition.Room
             * @static
             * @param {proto.ClientCondition.IRoom=} [properties] Properties to set
             * @returns {proto.ClientCondition.Room} Room instance
             */
      Room.create = function create(properties) {
        return new Room(properties);
      };

      /**
             * Encodes the specified Room message. Does not implicitly {@link proto.ClientCondition.Room.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientCondition.Room
             * @static
             * @param {proto.ClientCondition.Room} message Room message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Room.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
        if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageVersion);}
        if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.statusVersion);}
        if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.deleteVersion);}
        if (message.offlineDeletedDeprecated != null && message.offlineDeletedDeprecated.length) {
          writer.uint32(/* id 6, wireType 2 =*/50).fork();
          for (let i = 0; i < message.offlineDeletedDeprecated.length; ++i) {writer.uint64(message.offlineDeletedDeprecated[i]);}
          writer.ldelim();
        }
        if (message.offlineEdited != null && message.offlineEdited.length) {
          for (let i = 0; i < message.offlineEdited.length; ++i) {$root.proto.ClientCondition.Room.OfflineEdited.encode(message.offlineEdited[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
        }
        if (message.offlineSeen != null && message.offlineSeen.length) {
          writer.uint32(/* id 8, wireType 2 =*/66).fork();
          for (let i = 0; i < message.offlineSeen.length; ++i) {writer.uint64(message.offlineSeen[i]);}
          writer.ldelim();
        }
        if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.clearId);}
        if (message.cacheStartId != null && message.hasOwnProperty('cacheStartId')) {writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.cacheStartId);}
        if (message.cacheEndId != null && message.hasOwnProperty('cacheEndId')) {writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.cacheEndId);}
        if (message.offlineMute != null && message.hasOwnProperty('offlineMute')) {writer.uint32(/* id 12, wireType 0 =*/96).int32(message.offlineMute);}
        if (message.offlineListened != null && message.offlineListened.length) {
          writer.uint32(/* id 13, wireType 2 =*/106).fork();
          for (let i = 0; i < message.offlineListened.length; ++i) {writer.uint64(message.offlineListened[i]);}
          writer.ldelim();
        }
        if (message.offlineDeleted != null && message.offlineDeleted.length) {
          for (let i = 0; i < message.offlineDeleted.length; ++i) {$root.proto.ClientCondition.Room.OfflineDeleted.encode(message.offlineDeleted[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();}
        }
        return writer;
      };

      /**
             * Decodes a Room message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientCondition.Room
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientCondition.Room} Room
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Room.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCondition.Room();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.roomId = reader.uint64();
              break;
            case 3:
              message.messageVersion = reader.uint64();
              break;
            case 4:
              message.statusVersion = reader.uint64();
              break;
            case 5:
              message.deleteVersion = reader.uint64();
              break;
            case 6:
              if (!(message.offlineDeletedDeprecated && message.offlineDeletedDeprecated.length)) {message.offlineDeletedDeprecated = [];}
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {message.offlineDeletedDeprecated.push(reader.uint64());}
              } else {message.offlineDeletedDeprecated.push(reader.uint64());}
              break;
            case 7:
              if (!(message.offlineEdited && message.offlineEdited.length)) {message.offlineEdited = [];}
              message.offlineEdited.push($root.proto.ClientCondition.Room.OfflineEdited.decode(reader, reader.uint32()));
              break;
            case 8:
              if (!(message.offlineSeen && message.offlineSeen.length)) {message.offlineSeen = [];}
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {message.offlineSeen.push(reader.uint64());}
              } else {message.offlineSeen.push(reader.uint64());}
              break;
            case 9:
              message.clearId = reader.uint64();
              break;
            case 10:
              message.cacheStartId = reader.uint64();
              break;
            case 11:
              message.cacheEndId = reader.uint64();
              break;
            case 12:
              message.offlineMute = reader.int32();
              break;
            case 13:
              if (!(message.offlineListened && message.offlineListened.length)) {message.offlineListened = [];}
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {message.offlineListened.push(reader.uint64());}
              } else {message.offlineListened.push(reader.uint64());}
              break;
            case 14:
              if (!(message.offlineDeleted && message.offlineDeleted.length)) {message.offlineDeleted = [];}
              message.offlineDeleted.push($root.proto.ClientCondition.Room.OfflineDeleted.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Room message.
             * @function verify
             * @memberof proto.ClientCondition.Room
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Room.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.roomId != null && message.hasOwnProperty('roomId')) {
          if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
        }
        if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {
          if (!$util.isInteger(message.messageVersion) && !(message.messageVersion && $util.isInteger(message.messageVersion.low) && $util.isInteger(message.messageVersion.high))) {return 'messageVersion: integer|Long expected';}
        }
        if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {
          if (!$util.isInteger(message.statusVersion) && !(message.statusVersion && $util.isInteger(message.statusVersion.low) && $util.isInteger(message.statusVersion.high))) {return 'statusVersion: integer|Long expected';}
        }
        if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {
          if (!$util.isInteger(message.deleteVersion) && !(message.deleteVersion && $util.isInteger(message.deleteVersion.low) && $util.isInteger(message.deleteVersion.high))) {return 'deleteVersion: integer|Long expected';}
        }
        if (message.offlineDeletedDeprecated != null && message.hasOwnProperty('offlineDeletedDeprecated')) {
          if (!Array.isArray(message.offlineDeletedDeprecated)) {return 'offlineDeletedDeprecated: array expected';}
          for (let i = 0; i < message.offlineDeletedDeprecated.length; ++i) {
            if (!$util.isInteger(message.offlineDeletedDeprecated[i]) && !(message.offlineDeletedDeprecated[i] && $util.isInteger(message.offlineDeletedDeprecated[i].low) && $util.isInteger(message.offlineDeletedDeprecated[i].high))) {return 'offlineDeletedDeprecated: integer|Long[] expected';}
          }
        }
        if (message.offlineEdited != null && message.hasOwnProperty('offlineEdited')) {
          if (!Array.isArray(message.offlineEdited)) {return 'offlineEdited: array expected';}
          for (let i = 0; i < message.offlineEdited.length; ++i) {
            let error = $root.proto.ClientCondition.Room.OfflineEdited.verify(message.offlineEdited[i]);
            if (error) {return 'offlineEdited.' + error;}
          }
        }
        if (message.offlineSeen != null && message.hasOwnProperty('offlineSeen')) {
          if (!Array.isArray(message.offlineSeen)) {return 'offlineSeen: array expected';}
          for (let i = 0; i < message.offlineSeen.length; ++i) {
            if (!$util.isInteger(message.offlineSeen[i]) && !(message.offlineSeen[i] && $util.isInteger(message.offlineSeen[i].low) && $util.isInteger(message.offlineSeen[i].high))) {return 'offlineSeen: integer|Long[] expected';}
          }
        }
        if (message.clearId != null && message.hasOwnProperty('clearId')) {
          if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
        }
        if (message.cacheStartId != null && message.hasOwnProperty('cacheStartId')) {
          if (!$util.isInteger(message.cacheStartId) && !(message.cacheStartId && $util.isInteger(message.cacheStartId.low) && $util.isInteger(message.cacheStartId.high))) {return 'cacheStartId: integer|Long expected';}
        }
        if (message.cacheEndId != null && message.hasOwnProperty('cacheEndId')) {
          if (!$util.isInteger(message.cacheEndId) && !(message.cacheEndId && $util.isInteger(message.cacheEndId.low) && $util.isInteger(message.cacheEndId.high))) {return 'cacheEndId: integer|Long expected';}
        }
        if (message.offlineMute != null && message.hasOwnProperty('offlineMute')) {
          switch (message.offlineMute) {
            default:
              return 'offlineMute: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        }
        if (message.offlineListened != null && message.hasOwnProperty('offlineListened')) {
          if (!Array.isArray(message.offlineListened)) {return 'offlineListened: array expected';}
          for (let i = 0; i < message.offlineListened.length; ++i) {
            if (!$util.isInteger(message.offlineListened[i]) && !(message.offlineListened[i] && $util.isInteger(message.offlineListened[i].low) && $util.isInteger(message.offlineListened[i].high))) {return 'offlineListened: integer|Long[] expected';}
          }
        }
        if (message.offlineDeleted != null && message.hasOwnProperty('offlineDeleted')) {
          if (!Array.isArray(message.offlineDeleted)) {return 'offlineDeleted: array expected';}
          for (let i = 0; i < message.offlineDeleted.length; ++i) {
            let error = $root.proto.ClientCondition.Room.OfflineDeleted.verify(message.offlineDeleted[i]);
            if (error) {return 'offlineDeleted.' + error;}
          }
        }
        return null;
      };

      Room.OfflineEdited = (function() {

        /**
                 * Properties of an OfflineEdited.
                 * @memberof proto.ClientCondition.Room
                 * @interface IOfflineEdited
                 * @property {Long|null} [messageId] OfflineEdited messageId
                 * @property {string|null} [message] OfflineEdited message
                 */

        /**
                 * Constructs a new OfflineEdited.
                 * @memberof proto.ClientCondition.Room
                 * @classdesc Represents an OfflineEdited.
                 * @implements IOfflineEdited
                 * @constructor
                 * @param {proto.ClientCondition.Room.IOfflineEdited=} [properties] Properties to set
                 */
        function OfflineEdited(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
              if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
            }
          }
        }

        /**
                 * OfflineEdited messageId.
                 * @member {Long} messageId
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @instance
                 */
        OfflineEdited.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
                 * OfflineEdited message.
                 * @member {string} message
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @instance
                 */
        OfflineEdited.prototype.message = '';

        /**
                 * Creates a new OfflineEdited instance using the specified properties.
                 * @function create
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @static
                 * @param {proto.ClientCondition.Room.IOfflineEdited=} [properties] Properties to set
                 * @returns {proto.ClientCondition.Room.OfflineEdited} OfflineEdited instance
                 */
        OfflineEdited.create = function create(properties) {
          return new OfflineEdited(properties);
        };

        /**
                 * Encodes the specified OfflineEdited message. Does not implicitly {@link proto.ClientCondition.Room.OfflineEdited.verify|verify} messages.
                 * @function encode
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @static
                 * @param {proto.ClientCondition.Room.OfflineEdited} message OfflineEdited message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
        OfflineEdited.encode = function encode(message, writer) {
          if (!writer) {writer = $Writer.create();}
          if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);}
          if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);}
          return writer;
        };

        /**
                 * Decodes an OfflineEdited message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.ClientCondition.Room.OfflineEdited} OfflineEdited
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
        OfflineEdited.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCondition.Room.OfflineEdited();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.messageId = reader.uint64();
                break;
              case 2:
                message.message = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
                 * Verifies an OfflineEdited message.
                 * @function verify
                 * @memberof proto.ClientCondition.Room.OfflineEdited
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
        OfflineEdited.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) {return 'object expected';}
          if (message.messageId != null && message.hasOwnProperty('messageId')) {
            if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
          }
          if (message.message != null && message.hasOwnProperty('message')) {
            if (!$util.isString(message.message)) {return 'message: string expected';}
          }
          return null;
        };

        return OfflineEdited;
      })();

      /**
             * OfflineMute enum.
             * @name proto.ClientCondition.Room.OfflineMute
             * @enum {string}
             * @property {number} UNCHANGED=0 UNCHANGED value
             * @property {number} MUTED=1 MUTED value
             * @property {number} UNMUTED=2 UNMUTED value
             */
      Room.OfflineMute = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = 'UNCHANGED'] = 0;
        values[valuesById[1] = 'MUTED'] = 1;
        values[valuesById[2] = 'UNMUTED'] = 2;
        return values;
      })();

      Room.OfflineDeleted = (function() {

        /**
                 * Properties of an OfflineDeleted.
                 * @memberof proto.ClientCondition.Room
                 * @interface IOfflineDeleted
                 * @property {Long|null} [messageId] OfflineDeleted messageId
                 * @property {boolean|null} [both] OfflineDeleted both
                 */

        /**
                 * Constructs a new OfflineDeleted.
                 * @memberof proto.ClientCondition.Room
                 * @classdesc Represents an OfflineDeleted.
                 * @implements IOfflineDeleted
                 * @constructor
                 * @param {proto.ClientCondition.Room.IOfflineDeleted=} [properties] Properties to set
                 */
        function OfflineDeleted(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
              if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
            }
          }
        }

        /**
                 * OfflineDeleted messageId.
                 * @member {Long} messageId
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @instance
                 */
        OfflineDeleted.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
                 * OfflineDeleted both.
                 * @member {boolean} both
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @instance
                 */
        OfflineDeleted.prototype.both = false;

        /**
                 * Creates a new OfflineDeleted instance using the specified properties.
                 * @function create
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @static
                 * @param {proto.ClientCondition.Room.IOfflineDeleted=} [properties] Properties to set
                 * @returns {proto.ClientCondition.Room.OfflineDeleted} OfflineDeleted instance
                 */
        OfflineDeleted.create = function create(properties) {
          return new OfflineDeleted(properties);
        };

        /**
                 * Encodes the specified OfflineDeleted message. Does not implicitly {@link proto.ClientCondition.Room.OfflineDeleted.verify|verify} messages.
                 * @function encode
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @static
                 * @param {proto.ClientCondition.Room.OfflineDeleted} message OfflineDeleted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
        OfflineDeleted.encode = function encode(message, writer) {
          if (!writer) {writer = $Writer.create();}
          if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);}
          if (message.both != null && message.hasOwnProperty('both')) {writer.uint32(/* id 4, wireType 0 =*/32).bool(message.both);}
          return writer;
        };

        /**
                 * Decodes an OfflineDeleted message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.ClientCondition.Room.OfflineDeleted} OfflineDeleted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
        OfflineDeleted.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
          let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCondition.Room.OfflineDeleted();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.messageId = reader.uint64();
                break;
              case 4:
                message.both = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
                 * Verifies an OfflineDeleted message.
                 * @function verify
                 * @memberof proto.ClientCondition.Room.OfflineDeleted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
        OfflineDeleted.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) {return 'object expected';}
          if (message.messageId != null && message.hasOwnProperty('messageId')) {
            if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
          }
          if (message.both != null && message.hasOwnProperty('both')) {
            if (typeof message.both !== 'boolean') {return 'both: boolean expected';}
          }
          return null;
        };

        return OfflineDeleted;
      })();

      return Room;
    })();

    return ClientCondition;
  })();

  proto.ClientConditionResponse = (function() {

    /**
         * Properties of a ClientConditionResponse.
         * @memberof proto
         * @interface IClientConditionResponse
         * @property {proto.Response|null} [response] ClientConditionResponse response
         */

    /**
         * Constructs a new ClientConditionResponse.
         * @memberof proto
         * @classdesc Represents a ClientConditionResponse.
         * @implements IClientConditionResponse
         * @constructor
         * @param {proto.IClientConditionResponse=} [properties] Properties to set
         */
    function ClientConditionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientConditionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientConditionResponse
         * @instance
         */
    ClientConditionResponse.prototype.response = null;

    /**
         * Creates a new ClientConditionResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientConditionResponse
         * @static
         * @param {proto.IClientConditionResponse=} [properties] Properties to set
         * @returns {proto.ClientConditionResponse} ClientConditionResponse instance
         */
    ClientConditionResponse.create = function create(properties) {
      return new ClientConditionResponse(properties);
    };

    /**
         * Encodes the specified ClientConditionResponse message. Does not implicitly {@link proto.ClientConditionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientConditionResponse
         * @static
         * @param {proto.ClientConditionResponse} message ClientConditionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientConditionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientConditionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientConditionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientConditionResponse} ClientConditionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientConditionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientConditionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientConditionResponse message.
         * @function verify
         * @memberof proto.ClientConditionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientConditionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientConditionResponse;
  })();

  proto.ClientCountRoomHistory = (function() {

    /**
         * Properties of a ClientCountRoomHistory.
         * @memberof proto
         * @interface IClientCountRoomHistory
         * @property {proto.Request|null} [request] ClientCountRoomHistory request
         * @property {Long|null} [roomId] ClientCountRoomHistory roomId
         */

    /**
         * Constructs a new ClientCountRoomHistory.
         * @memberof proto
         * @classdesc Represents a ClientCountRoomHistory.
         * @implements IClientCountRoomHistory
         * @constructor
         * @param {proto.IClientCountRoomHistory=} [properties] Properties to set
         */
    function ClientCountRoomHistory(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientCountRoomHistory request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientCountRoomHistory
         * @instance
         */
    ClientCountRoomHistory.prototype.request = null;

    /**
         * ClientCountRoomHistory roomId.
         * @member {Long} roomId
         * @memberof proto.ClientCountRoomHistory
         * @instance
         */
    ClientCountRoomHistory.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientCountRoomHistory instance using the specified properties.
         * @function create
         * @memberof proto.ClientCountRoomHistory
         * @static
         * @param {proto.IClientCountRoomHistory=} [properties] Properties to set
         * @returns {proto.ClientCountRoomHistory} ClientCountRoomHistory instance
         */
    ClientCountRoomHistory.create = function create(properties) {
      return new ClientCountRoomHistory(properties);
    };

    /**
         * Encodes the specified ClientCountRoomHistory message. Does not implicitly {@link proto.ClientCountRoomHistory.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientCountRoomHistory
         * @static
         * @param {proto.ClientCountRoomHistory} message ClientCountRoomHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientCountRoomHistory.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ClientCountRoomHistory message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientCountRoomHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientCountRoomHistory} ClientCountRoomHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientCountRoomHistory.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCountRoomHistory();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientCountRoomHistory message.
         * @function verify
         * @memberof proto.ClientCountRoomHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientCountRoomHistory.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ClientCountRoomHistory;
  })();

  proto.ClientCountRoomHistoryResponse = (function() {

    /**
         * Properties of a ClientCountRoomHistoryResponse.
         * @memberof proto
         * @interface IClientCountRoomHistoryResponse
         * @property {proto.Response|null} [response] ClientCountRoomHistoryResponse response
         * @property {number|null} [media] ClientCountRoomHistoryResponse media
         * @property {number|null} [image] ClientCountRoomHistoryResponse image
         * @property {number|null} [video] ClientCountRoomHistoryResponse video
         * @property {number|null} [audio] ClientCountRoomHistoryResponse audio
         * @property {number|null} [voice] ClientCountRoomHistoryResponse voice
         * @property {number|null} [gif] ClientCountRoomHistoryResponse gif
         * @property {number|null} [file] ClientCountRoomHistoryResponse file
         * @property {number|null} [url] ClientCountRoomHistoryResponse url
         */

    /**
         * Constructs a new ClientCountRoomHistoryResponse.
         * @memberof proto
         * @classdesc Represents a ClientCountRoomHistoryResponse.
         * @implements IClientCountRoomHistoryResponse
         * @constructor
         * @param {proto.IClientCountRoomHistoryResponse=} [properties] Properties to set
         */
    function ClientCountRoomHistoryResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientCountRoomHistoryResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.response = null;

    /**
         * ClientCountRoomHistoryResponse media.
         * @member {number} media
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.media = 0;

    /**
         * ClientCountRoomHistoryResponse image.
         * @member {number} image
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.image = 0;

    /**
         * ClientCountRoomHistoryResponse video.
         * @member {number} video
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.video = 0;

    /**
         * ClientCountRoomHistoryResponse audio.
         * @member {number} audio
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.audio = 0;

    /**
         * ClientCountRoomHistoryResponse voice.
         * @member {number} voice
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.voice = 0;

    /**
         * ClientCountRoomHistoryResponse gif.
         * @member {number} gif
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.gif = 0;

    /**
         * ClientCountRoomHistoryResponse file.
         * @member {number} file
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.file = 0;

    /**
         * ClientCountRoomHistoryResponse url.
         * @member {number} url
         * @memberof proto.ClientCountRoomHistoryResponse
         * @instance
         */
    ClientCountRoomHistoryResponse.prototype.url = 0;

    /**
         * Creates a new ClientCountRoomHistoryResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientCountRoomHistoryResponse
         * @static
         * @param {proto.IClientCountRoomHistoryResponse=} [properties] Properties to set
         * @returns {proto.ClientCountRoomHistoryResponse} ClientCountRoomHistoryResponse instance
         */
    ClientCountRoomHistoryResponse.create = function create(properties) {
      return new ClientCountRoomHistoryResponse(properties);
    };

    /**
         * Encodes the specified ClientCountRoomHistoryResponse message. Does not implicitly {@link proto.ClientCountRoomHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientCountRoomHistoryResponse
         * @static
         * @param {proto.ClientCountRoomHistoryResponse} message ClientCountRoomHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientCountRoomHistoryResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.media != null && message.hasOwnProperty('media')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.media);}
      if (message.image != null && message.hasOwnProperty('image')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.image);}
      if (message.video != null && message.hasOwnProperty('video')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.video);}
      if (message.audio != null && message.hasOwnProperty('audio')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.audio);}
      if (message.voice != null && message.hasOwnProperty('voice')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.voice);}
      if (message.gif != null && message.hasOwnProperty('gif')) {writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.gif);}
      if (message.file != null && message.hasOwnProperty('file')) {writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.file);}
      if (message.url != null && message.hasOwnProperty('url')) {writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.url);}
      return writer;
    };

    /**
         * Decodes a ClientCountRoomHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientCountRoomHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientCountRoomHistoryResponse} ClientCountRoomHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientCountRoomHistoryResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientCountRoomHistoryResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.media = reader.uint32();
            break;
          case 3:
            message.image = reader.uint32();
            break;
          case 4:
            message.video = reader.uint32();
            break;
          case 5:
            message.audio = reader.uint32();
            break;
          case 6:
            message.voice = reader.uint32();
            break;
          case 7:
            message.gif = reader.uint32();
            break;
          case 8:
            message.file = reader.uint32();
            break;
          case 9:
            message.url = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientCountRoomHistoryResponse message.
         * @function verify
         * @memberof proto.ClientCountRoomHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientCountRoomHistoryResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.media != null && message.hasOwnProperty('media')) {
        if (!$util.isInteger(message.media)) {return 'media: integer expected';}
      }
      if (message.image != null && message.hasOwnProperty('image')) {
        if (!$util.isInteger(message.image)) {return 'image: integer expected';}
      }
      if (message.video != null && message.hasOwnProperty('video')) {
        if (!$util.isInteger(message.video)) {return 'video: integer expected';}
      }
      if (message.audio != null && message.hasOwnProperty('audio')) {
        if (!$util.isInteger(message.audio)) {return 'audio: integer expected';}
      }
      if (message.voice != null && message.hasOwnProperty('voice')) {
        if (!$util.isInteger(message.voice)) {return 'voice: integer expected';}
      }
      if (message.gif != null && message.hasOwnProperty('gif')) {
        if (!$util.isInteger(message.gif)) {return 'gif: integer expected';}
      }
      if (message.file != null && message.hasOwnProperty('file')) {
        if (!$util.isInteger(message.file)) {return 'file: integer expected';}
      }
      if (message.url != null && message.hasOwnProperty('url')) {
        if (!$util.isInteger(message.url)) {return 'url: integer expected';}
      }
      return null;
    };

    return ClientCountRoomHistoryResponse;
  })();

  proto.ClientGetRoom = (function() {

    /**
         * Properties of a ClientGetRoom.
         * @memberof proto
         * @interface IClientGetRoom
         * @property {proto.Request|null} [request] ClientGetRoom request
         * @property {Long|null} [roomId] ClientGetRoom roomId
         */

    /**
         * Constructs a new ClientGetRoom.
         * @memberof proto
         * @classdesc Represents a ClientGetRoom.
         * @implements IClientGetRoom
         * @constructor
         * @param {proto.IClientGetRoom=} [properties] Properties to set
         */
    function ClientGetRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientGetRoom
         * @instance
         */
    ClientGetRoom.prototype.request = null;

    /**
         * ClientGetRoom roomId.
         * @member {Long} roomId
         * @memberof proto.ClientGetRoom
         * @instance
         */
    ClientGetRoom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientGetRoom instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoom
         * @static
         * @param {proto.IClientGetRoom=} [properties] Properties to set
         * @returns {proto.ClientGetRoom} ClientGetRoom instance
         */
    ClientGetRoom.create = function create(properties) {
      return new ClientGetRoom(properties);
    };

    /**
         * Encodes the specified ClientGetRoom message. Does not implicitly {@link proto.ClientGetRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoom
         * @static
         * @param {proto.ClientGetRoom} message ClientGetRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ClientGetRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoom} ClientGetRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoom message.
         * @function verify
         * @memberof proto.ClientGetRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ClientGetRoom;
  })();

  proto.ClientGetRoomResponse = (function() {

    /**
         * Properties of a ClientGetRoomResponse.
         * @memberof proto
         * @interface IClientGetRoomResponse
         * @property {proto.Response|null} [response] ClientGetRoomResponse response
         * @property {proto.Room|null} [room] ClientGetRoomResponse room
         */

    /**
         * Constructs a new ClientGetRoomResponse.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomResponse.
         * @implements IClientGetRoomResponse
         * @constructor
         * @param {proto.IClientGetRoomResponse=} [properties] Properties to set
         */
    function ClientGetRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientGetRoomResponse
         * @instance
         */
    ClientGetRoomResponse.prototype.response = null;

    /**
         * ClientGetRoomResponse room.
         * @member {proto.Room|null|undefined} room
         * @memberof proto.ClientGetRoomResponse
         * @instance
         */
    ClientGetRoomResponse.prototype.room = null;

    /**
         * Creates a new ClientGetRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomResponse
         * @static
         * @param {proto.IClientGetRoomResponse=} [properties] Properties to set
         * @returns {proto.ClientGetRoomResponse} ClientGetRoomResponse instance
         */
    ClientGetRoomResponse.create = function create(properties) {
      return new ClientGetRoomResponse(properties);
    };

    /**
         * Encodes the specified ClientGetRoomResponse message. Does not implicitly {@link proto.ClientGetRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomResponse
         * @static
         * @param {proto.ClientGetRoomResponse} message ClientGetRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.room != null && message.hasOwnProperty('room')) {$root.proto.Room.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientGetRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomResponse} ClientGetRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.room = $root.proto.Room.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomResponse message.
         * @function verify
         * @memberof proto.ClientGetRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.room != null && message.hasOwnProperty('room')) {
        let error = $root.proto.Room.verify(message.room);
        if (error) {return 'room.' + error;}
      }
      return null;
    };

    return ClientGetRoomResponse;
  })();

  proto.ClientGetRoomHistory = (function() {

    /**
         * Properties of a ClientGetRoomHistory.
         * @memberof proto
         * @interface IClientGetRoomHistory
         * @property {proto.Request|null} [request] ClientGetRoomHistory request
         * @property {Long|null} [roomId] ClientGetRoomHistory roomId
         * @property {Long|null} [firstMessageId] ClientGetRoomHistory firstMessageId
         * @property {proto.ClientGetRoomHistory.Direction|null} [direction] ClientGetRoomHistory direction
         * @property {number|null} [limit] ClientGetRoomHistory limit
         */

    /**
         * Constructs a new ClientGetRoomHistory.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomHistory.
         * @implements IClientGetRoomHistory
         * @constructor
         * @param {proto.IClientGetRoomHistory=} [properties] Properties to set
         */
    function ClientGetRoomHistory(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomHistory request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientGetRoomHistory
         * @instance
         */
    ClientGetRoomHistory.prototype.request = null;

    /**
         * ClientGetRoomHistory roomId.
         * @member {Long} roomId
         * @memberof proto.ClientGetRoomHistory
         * @instance
         */
    ClientGetRoomHistory.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientGetRoomHistory firstMessageId.
         * @member {Long} firstMessageId
         * @memberof proto.ClientGetRoomHistory
         * @instance
         */
    ClientGetRoomHistory.prototype.firstMessageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientGetRoomHistory direction.
         * @member {proto.ClientGetRoomHistory.Direction} direction
         * @memberof proto.ClientGetRoomHistory
         * @instance
         */
    ClientGetRoomHistory.prototype.direction = 0;

    /**
         * ClientGetRoomHistory limit.
         * @member {number} limit
         * @memberof proto.ClientGetRoomHistory
         * @instance
         */
    ClientGetRoomHistory.prototype.limit = 0;

    /**
         * Creates a new ClientGetRoomHistory instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomHistory
         * @static
         * @param {proto.IClientGetRoomHistory=} [properties] Properties to set
         * @returns {proto.ClientGetRoomHistory} ClientGetRoomHistory instance
         */
    ClientGetRoomHistory.create = function create(properties) {
      return new ClientGetRoomHistory(properties);
    };

    /**
         * Encodes the specified ClientGetRoomHistory message. Does not implicitly {@link proto.ClientGetRoomHistory.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomHistory
         * @static
         * @param {proto.ClientGetRoomHistory} message ClientGetRoomHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomHistory.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.firstMessageId != null && message.hasOwnProperty('firstMessageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.firstMessageId);}
      if (message.direction != null && message.hasOwnProperty('direction')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.direction);}
      if (message.limit != null && message.hasOwnProperty('limit')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.limit);}
      return writer;
    };

    /**
         * Decodes a ClientGetRoomHistory message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomHistory} ClientGetRoomHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomHistory.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomHistory();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.firstMessageId = reader.uint64();
            break;
          case 4:
            message.direction = reader.int32();
            break;
          case 5:
            message.limit = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomHistory message.
         * @function verify
         * @memberof proto.ClientGetRoomHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomHistory.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.firstMessageId != null && message.hasOwnProperty('firstMessageId')) {
        if (!$util.isInteger(message.firstMessageId) && !(message.firstMessageId && $util.isInteger(message.firstMessageId.low) && $util.isInteger(message.firstMessageId.high))) {return 'firstMessageId: integer|Long expected';}
      }
      if (message.direction != null && message.hasOwnProperty('direction')) {
        switch (message.direction) {
          default:
            return 'direction: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.limit != null && message.hasOwnProperty('limit')) {
        if (!$util.isInteger(message.limit)) {return 'limit: integer expected';}
      }
      return null;
    };

    /**
         * Direction enum.
         * @name proto.ClientGetRoomHistory.Direction
         * @enum {string}
         * @property {number} UP=0 UP value
         * @property {number} DOWN=1 DOWN value
         */
    ClientGetRoomHistory.Direction = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'UP'] = 0;
      values[valuesById[1] = 'DOWN'] = 1;
      return values;
    })();

    return ClientGetRoomHistory;
  })();

  proto.ClientGetRoomHistoryResponse = (function() {

    /**
         * Properties of a ClientGetRoomHistoryResponse.
         * @memberof proto
         * @interface IClientGetRoomHistoryResponse
         * @property {proto.Response|null} [response] ClientGetRoomHistoryResponse response
         * @property {Array.<proto.RoomMessage>|null} [message] ClientGetRoomHistoryResponse message
         */

    /**
         * Constructs a new ClientGetRoomHistoryResponse.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomHistoryResponse.
         * @implements IClientGetRoomHistoryResponse
         * @constructor
         * @param {proto.IClientGetRoomHistoryResponse=} [properties] Properties to set
         */
    function ClientGetRoomHistoryResponse(properties) {
      this.message = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomHistoryResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientGetRoomHistoryResponse
         * @instance
         */
    ClientGetRoomHistoryResponse.prototype.response = null;

    /**
         * ClientGetRoomHistoryResponse message.
         * @member {Array.<proto.RoomMessage>} message
         * @memberof proto.ClientGetRoomHistoryResponse
         * @instance
         */
    ClientGetRoomHistoryResponse.prototype.message = $util.emptyArray;

    /**
         * Creates a new ClientGetRoomHistoryResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomHistoryResponse
         * @static
         * @param {proto.IClientGetRoomHistoryResponse=} [properties] Properties to set
         * @returns {proto.ClientGetRoomHistoryResponse} ClientGetRoomHistoryResponse instance
         */
    ClientGetRoomHistoryResponse.create = function create(properties) {
      return new ClientGetRoomHistoryResponse(properties);
    };

    /**
         * Encodes the specified ClientGetRoomHistoryResponse message. Does not implicitly {@link proto.ClientGetRoomHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomHistoryResponse
         * @static
         * @param {proto.ClientGetRoomHistoryResponse} message ClientGetRoomHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomHistoryResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.message != null && message.message.length) {
        for (let i = 0; i < message.message.length; ++i) {$root.proto.RoomMessage.encode(message.message[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ClientGetRoomHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomHistoryResponse} ClientGetRoomHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomHistoryResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomHistoryResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.message && message.message.length)) {message.message = [];}
            message.message.push($root.proto.RoomMessage.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomHistoryResponse message.
         * @function verify
         * @memberof proto.ClientGetRoomHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomHistoryResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!Array.isArray(message.message)) {return 'message: array expected';}
        for (let i = 0; i < message.message.length; ++i) {
          let error = $root.proto.RoomMessage.verify(message.message[i]);
          if (error) {return 'message.' + error;}
        }
      }
      return null;
    };

    return ClientGetRoomHistoryResponse;
  })();

  proto.ClientGetRoomList = (function() {

    /**
         * Properties of a ClientGetRoomList.
         * @memberof proto
         * @interface IClientGetRoomList
         * @property {proto.Request|null} [request] ClientGetRoomList request
         * @property {proto.Pagination|null} [pagination] ClientGetRoomList pagination
         */

    /**
         * Constructs a new ClientGetRoomList.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomList.
         * @implements IClientGetRoomList
         * @constructor
         * @param {proto.IClientGetRoomList=} [properties] Properties to set
         */
    function ClientGetRoomList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientGetRoomList
         * @instance
         */
    ClientGetRoomList.prototype.request = null;

    /**
         * ClientGetRoomList pagination.
         * @member {proto.Pagination|null|undefined} pagination
         * @memberof proto.ClientGetRoomList
         * @instance
         */
    ClientGetRoomList.prototype.pagination = null;

    /**
         * Creates a new ClientGetRoomList instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomList
         * @static
         * @param {proto.IClientGetRoomList=} [properties] Properties to set
         * @returns {proto.ClientGetRoomList} ClientGetRoomList instance
         */
    ClientGetRoomList.create = function create(properties) {
      return new ClientGetRoomList(properties);
    };

    /**
         * Encodes the specified ClientGetRoomList message. Does not implicitly {@link proto.ClientGetRoomList.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomList
         * @static
         * @param {proto.ClientGetRoomList} message ClientGetRoomList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.pagination != null && message.hasOwnProperty('pagination')) {$root.proto.Pagination.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientGetRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomList} ClientGetRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.pagination = $root.proto.Pagination.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomList message.
         * @function verify
         * @memberof proto.ClientGetRoomList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.pagination != null && message.hasOwnProperty('pagination')) {
        let error = $root.proto.Pagination.verify(message.pagination);
        if (error) {return 'pagination.' + error;}
      }
      return null;
    };

    return ClientGetRoomList;
  })();

  proto.ClientGetRoomListResponse = (function() {

    /**
         * Properties of a ClientGetRoomListResponse.
         * @memberof proto
         * @interface IClientGetRoomListResponse
         * @property {proto.Response|null} [response] ClientGetRoomListResponse response
         * @property {Array.<proto.Room>|null} [rooms] ClientGetRoomListResponse rooms
         */

    /**
         * Constructs a new ClientGetRoomListResponse.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomListResponse.
         * @implements IClientGetRoomListResponse
         * @constructor
         * @param {proto.IClientGetRoomListResponse=} [properties] Properties to set
         */
    function ClientGetRoomListResponse(properties) {
      this.rooms = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientGetRoomListResponse
         * @instance
         */
    ClientGetRoomListResponse.prototype.response = null;

    /**
         * ClientGetRoomListResponse rooms.
         * @member {Array.<proto.Room>} rooms
         * @memberof proto.ClientGetRoomListResponse
         * @instance
         */
    ClientGetRoomListResponse.prototype.rooms = $util.emptyArray;

    /**
         * Creates a new ClientGetRoomListResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomListResponse
         * @static
         * @param {proto.IClientGetRoomListResponse=} [properties] Properties to set
         * @returns {proto.ClientGetRoomListResponse} ClientGetRoomListResponse instance
         */
    ClientGetRoomListResponse.create = function create(properties) {
      return new ClientGetRoomListResponse(properties);
    };

    /**
         * Encodes the specified ClientGetRoomListResponse message. Does not implicitly {@link proto.ClientGetRoomListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomListResponse
         * @static
         * @param {proto.ClientGetRoomListResponse} message ClientGetRoomListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.rooms != null && message.rooms.length) {
        for (let i = 0; i < message.rooms.length; ++i) {$root.proto.Room.encode(message.rooms[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ClientGetRoomListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomListResponse} ClientGetRoomListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.rooms && message.rooms.length)) {message.rooms = [];}
            message.rooms.push($root.proto.Room.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomListResponse message.
         * @function verify
         * @memberof proto.ClientGetRoomListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.rooms != null && message.hasOwnProperty('rooms')) {
        if (!Array.isArray(message.rooms)) {return 'rooms: array expected';}
        for (let i = 0; i < message.rooms.length; ++i) {
          let error = $root.proto.Room.verify(message.rooms[i]);
          if (error) {return 'rooms.' + error;}
        }
      }
      return null;
    };

    return ClientGetRoomListResponse;
  })();

  proto.ClientGetRoomMessage = (function() {

    /**
         * Properties of a ClientGetRoomMessage.
         * @memberof proto
         * @interface IClientGetRoomMessage
         * @property {proto.Request|null} [request] ClientGetRoomMessage request
         * @property {Long|null} [roomId] ClientGetRoomMessage roomId
         * @property {Long|null} [messageId] ClientGetRoomMessage messageId
         */

    /**
         * Constructs a new ClientGetRoomMessage.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomMessage.
         * @implements IClientGetRoomMessage
         * @constructor
         * @param {proto.IClientGetRoomMessage=} [properties] Properties to set
         */
    function ClientGetRoomMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientGetRoomMessage
         * @instance
         */
    ClientGetRoomMessage.prototype.request = null;

    /**
         * ClientGetRoomMessage roomId.
         * @member {Long} roomId
         * @memberof proto.ClientGetRoomMessage
         * @instance
         */
    ClientGetRoomMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientGetRoomMessage messageId.
         * @member {Long} messageId
         * @memberof proto.ClientGetRoomMessage
         * @instance
         */
    ClientGetRoomMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientGetRoomMessage instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomMessage
         * @static
         * @param {proto.IClientGetRoomMessage=} [properties] Properties to set
         * @returns {proto.ClientGetRoomMessage} ClientGetRoomMessage instance
         */
    ClientGetRoomMessage.create = function create(properties) {
      return new ClientGetRoomMessage(properties);
    };

    /**
         * Encodes the specified ClientGetRoomMessage message. Does not implicitly {@link proto.ClientGetRoomMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomMessage
         * @static
         * @param {proto.ClientGetRoomMessage} message ClientGetRoomMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a ClientGetRoomMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomMessage} ClientGetRoomMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomMessage message.
         * @function verify
         * @memberof proto.ClientGetRoomMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return ClientGetRoomMessage;
  })();

  proto.ClientGetRoomMessageResponse = (function() {

    /**
         * Properties of a ClientGetRoomMessageResponse.
         * @memberof proto
         * @interface IClientGetRoomMessageResponse
         * @property {proto.Response|null} [response] ClientGetRoomMessageResponse response
         * @property {proto.RoomMessage|null} [message] ClientGetRoomMessageResponse message
         */

    /**
         * Constructs a new ClientGetRoomMessageResponse.
         * @memberof proto
         * @classdesc Represents a ClientGetRoomMessageResponse.
         * @implements IClientGetRoomMessageResponse
         * @constructor
         * @param {proto.IClientGetRoomMessageResponse=} [properties] Properties to set
         */
    function ClientGetRoomMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientGetRoomMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientGetRoomMessageResponse
         * @instance
         */
    ClientGetRoomMessageResponse.prototype.response = null;

    /**
         * ClientGetRoomMessageResponse message.
         * @member {proto.RoomMessage|null|undefined} message
         * @memberof proto.ClientGetRoomMessageResponse
         * @instance
         */
    ClientGetRoomMessageResponse.prototype.message = null;

    /**
         * Creates a new ClientGetRoomMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientGetRoomMessageResponse
         * @static
         * @param {proto.IClientGetRoomMessageResponse=} [properties] Properties to set
         * @returns {proto.ClientGetRoomMessageResponse} ClientGetRoomMessageResponse instance
         */
    ClientGetRoomMessageResponse.create = function create(properties) {
      return new ClientGetRoomMessageResponse(properties);
    };

    /**
         * Encodes the specified ClientGetRoomMessageResponse message. Does not implicitly {@link proto.ClientGetRoomMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientGetRoomMessageResponse
         * @static
         * @param {proto.ClientGetRoomMessageResponse} message ClientGetRoomMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientGetRoomMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.message != null && message.hasOwnProperty('message')) {$root.proto.RoomMessage.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientGetRoomMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientGetRoomMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientGetRoomMessageResponse} ClientGetRoomMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientGetRoomMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientGetRoomMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.message = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientGetRoomMessageResponse message.
         * @function verify
         * @memberof proto.ClientGetRoomMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientGetRoomMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        let error = $root.proto.RoomMessage.verify(message.message);
        if (error) {return 'message.' + error;}
      }
      return null;
    };

    return ClientGetRoomMessageResponse;
  })();

  proto.ClientJoinByInviteLink = (function() {

    /**
         * Properties of a ClientJoinByInviteLink.
         * @memberof proto
         * @interface IClientJoinByInviteLink
         * @property {proto.Request|null} [request] ClientJoinByInviteLink request
         * @property {string|null} [inviteToken] ClientJoinByInviteLink inviteToken
         */

    /**
         * Constructs a new ClientJoinByInviteLink.
         * @memberof proto
         * @classdesc Represents a ClientJoinByInviteLink.
         * @implements IClientJoinByInviteLink
         * @constructor
         * @param {proto.IClientJoinByInviteLink=} [properties] Properties to set
         */
    function ClientJoinByInviteLink(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientJoinByInviteLink request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientJoinByInviteLink
         * @instance
         */
    ClientJoinByInviteLink.prototype.request = null;

    /**
         * ClientJoinByInviteLink inviteToken.
         * @member {string} inviteToken
         * @memberof proto.ClientJoinByInviteLink
         * @instance
         */
    ClientJoinByInviteLink.prototype.inviteToken = '';

    /**
         * Creates a new ClientJoinByInviteLink instance using the specified properties.
         * @function create
         * @memberof proto.ClientJoinByInviteLink
         * @static
         * @param {proto.IClientJoinByInviteLink=} [properties] Properties to set
         * @returns {proto.ClientJoinByInviteLink} ClientJoinByInviteLink instance
         */
    ClientJoinByInviteLink.create = function create(properties) {
      return new ClientJoinByInviteLink(properties);
    };

    /**
         * Encodes the specified ClientJoinByInviteLink message. Does not implicitly {@link proto.ClientJoinByInviteLink.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientJoinByInviteLink
         * @static
         * @param {proto.ClientJoinByInviteLink} message ClientJoinByInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientJoinByInviteLink.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteToken);}
      return writer;
    };

    /**
         * Decodes a ClientJoinByInviteLink message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientJoinByInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientJoinByInviteLink} ClientJoinByInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientJoinByInviteLink.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientJoinByInviteLink();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.inviteToken = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientJoinByInviteLink message.
         * @function verify
         * @memberof proto.ClientJoinByInviteLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientJoinByInviteLink.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
        if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
      }
      return null;
    };

    return ClientJoinByInviteLink;
  })();

  proto.ClientJoinByInviteLinkResponse = (function() {

    /**
         * Properties of a ClientJoinByInviteLinkResponse.
         * @memberof proto
         * @interface IClientJoinByInviteLinkResponse
         * @property {proto.Response|null} [response] ClientJoinByInviteLinkResponse response
         */

    /**
         * Constructs a new ClientJoinByInviteLinkResponse.
         * @memberof proto
         * @classdesc Represents a ClientJoinByInviteLinkResponse.
         * @implements IClientJoinByInviteLinkResponse
         * @constructor
         * @param {proto.IClientJoinByInviteLinkResponse=} [properties] Properties to set
         */
    function ClientJoinByInviteLinkResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientJoinByInviteLinkResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientJoinByInviteLinkResponse
         * @instance
         */
    ClientJoinByInviteLinkResponse.prototype.response = null;

    /**
         * Creates a new ClientJoinByInviteLinkResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientJoinByInviteLinkResponse
         * @static
         * @param {proto.IClientJoinByInviteLinkResponse=} [properties] Properties to set
         * @returns {proto.ClientJoinByInviteLinkResponse} ClientJoinByInviteLinkResponse instance
         */
    ClientJoinByInviteLinkResponse.create = function create(properties) {
      return new ClientJoinByInviteLinkResponse(properties);
    };

    /**
         * Encodes the specified ClientJoinByInviteLinkResponse message. Does not implicitly {@link proto.ClientJoinByInviteLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientJoinByInviteLinkResponse
         * @static
         * @param {proto.ClientJoinByInviteLinkResponse} message ClientJoinByInviteLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientJoinByInviteLinkResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientJoinByInviteLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientJoinByInviteLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientJoinByInviteLinkResponse} ClientJoinByInviteLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientJoinByInviteLinkResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientJoinByInviteLinkResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientJoinByInviteLinkResponse message.
         * @function verify
         * @memberof proto.ClientJoinByInviteLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientJoinByInviteLinkResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientJoinByInviteLinkResponse;
  })();

  proto.ClientJoinByUsername = (function() {

    /**
         * Properties of a ClientJoinByUsername.
         * @memberof proto
         * @interface IClientJoinByUsername
         * @property {proto.Request|null} [request] ClientJoinByUsername request
         * @property {string|null} [username] ClientJoinByUsername username
         */

    /**
         * Constructs a new ClientJoinByUsername.
         * @memberof proto
         * @classdesc Represents a ClientJoinByUsername.
         * @implements IClientJoinByUsername
         * @constructor
         * @param {proto.IClientJoinByUsername=} [properties] Properties to set
         */
    function ClientJoinByUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientJoinByUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientJoinByUsername
         * @instance
         */
    ClientJoinByUsername.prototype.request = null;

    /**
         * ClientJoinByUsername username.
         * @member {string} username
         * @memberof proto.ClientJoinByUsername
         * @instance
         */
    ClientJoinByUsername.prototype.username = '';

    /**
         * Creates a new ClientJoinByUsername instance using the specified properties.
         * @function create
         * @memberof proto.ClientJoinByUsername
         * @static
         * @param {proto.IClientJoinByUsername=} [properties] Properties to set
         * @returns {proto.ClientJoinByUsername} ClientJoinByUsername instance
         */
    ClientJoinByUsername.create = function create(properties) {
      return new ClientJoinByUsername(properties);
    };

    /**
         * Encodes the specified ClientJoinByUsername message. Does not implicitly {@link proto.ClientJoinByUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientJoinByUsername
         * @static
         * @param {proto.ClientJoinByUsername} message ClientJoinByUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientJoinByUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a ClientJoinByUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientJoinByUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientJoinByUsername} ClientJoinByUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientJoinByUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientJoinByUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientJoinByUsername message.
         * @function verify
         * @memberof proto.ClientJoinByUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientJoinByUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return ClientJoinByUsername;
  })();

  proto.ClientJoinByUsernameResponse = (function() {

    /**
         * Properties of a ClientJoinByUsernameResponse.
         * @memberof proto
         * @interface IClientJoinByUsernameResponse
         * @property {proto.Response|null} [response] ClientJoinByUsernameResponse response
         */

    /**
         * Constructs a new ClientJoinByUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ClientJoinByUsernameResponse.
         * @implements IClientJoinByUsernameResponse
         * @constructor
         * @param {proto.IClientJoinByUsernameResponse=} [properties] Properties to set
         */
    function ClientJoinByUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientJoinByUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientJoinByUsernameResponse
         * @instance
         */
    ClientJoinByUsernameResponse.prototype.response = null;

    /**
         * Creates a new ClientJoinByUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientJoinByUsernameResponse
         * @static
         * @param {proto.IClientJoinByUsernameResponse=} [properties] Properties to set
         * @returns {proto.ClientJoinByUsernameResponse} ClientJoinByUsernameResponse instance
         */
    ClientJoinByUsernameResponse.create = function create(properties) {
      return new ClientJoinByUsernameResponse(properties);
    };

    /**
         * Encodes the specified ClientJoinByUsernameResponse message. Does not implicitly {@link proto.ClientJoinByUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientJoinByUsernameResponse
         * @static
         * @param {proto.ClientJoinByUsernameResponse} message ClientJoinByUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientJoinByUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientJoinByUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientJoinByUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientJoinByUsernameResponse} ClientJoinByUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientJoinByUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientJoinByUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientJoinByUsernameResponse message.
         * @function verify
         * @memberof proto.ClientJoinByUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientJoinByUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientJoinByUsernameResponse;
  })();

  proto.ClientMuteRoom = (function() {

    /**
         * Properties of a ClientMuteRoom.
         * @memberof proto
         * @interface IClientMuteRoom
         * @property {proto.Request|null} [request] ClientMuteRoom request
         * @property {Long|null} [roomId] ClientMuteRoom roomId
         * @property {proto.RoomMute|null} [roomMute] ClientMuteRoom roomMute
         */

    /**
         * Constructs a new ClientMuteRoom.
         * @memberof proto
         * @classdesc Represents a ClientMuteRoom.
         * @implements IClientMuteRoom
         * @constructor
         * @param {proto.IClientMuteRoom=} [properties] Properties to set
         */
    function ClientMuteRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientMuteRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientMuteRoom
         * @instance
         */
    ClientMuteRoom.prototype.request = null;

    /**
         * ClientMuteRoom roomId.
         * @member {Long} roomId
         * @memberof proto.ClientMuteRoom
         * @instance
         */
    ClientMuteRoom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientMuteRoom roomMute.
         * @member {proto.RoomMute} roomMute
         * @memberof proto.ClientMuteRoom
         * @instance
         */
    ClientMuteRoom.prototype.roomMute = 0;

    /**
         * Creates a new ClientMuteRoom instance using the specified properties.
         * @function create
         * @memberof proto.ClientMuteRoom
         * @static
         * @param {proto.IClientMuteRoom=} [properties] Properties to set
         * @returns {proto.ClientMuteRoom} ClientMuteRoom instance
         */
    ClientMuteRoom.create = function create(properties) {
      return new ClientMuteRoom(properties);
    };

    /**
         * Encodes the specified ClientMuteRoom message. Does not implicitly {@link proto.ClientMuteRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientMuteRoom
         * @static
         * @param {proto.ClientMuteRoom} message ClientMuteRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientMuteRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roomMute);}
      return writer;
    };

    /**
         * Decodes a ClientMuteRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientMuteRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientMuteRoom} ClientMuteRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientMuteRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientMuteRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.roomMute = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientMuteRoom message.
         * @function verify
         * @memberof proto.ClientMuteRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientMuteRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {
        switch (message.roomMute) {
          default:
            return 'roomMute: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      return null;
    };

    return ClientMuteRoom;
  })();

  proto.ClientMuteRoomResponse = (function() {

    /**
         * Properties of a ClientMuteRoomResponse.
         * @memberof proto
         * @interface IClientMuteRoomResponse
         * @property {proto.Response|null} [response] ClientMuteRoomResponse response
         * @property {Long|null} [roomId] ClientMuteRoomResponse roomId
         * @property {proto.RoomMute|null} [roomMute] ClientMuteRoomResponse roomMute
         */

    /**
         * Constructs a new ClientMuteRoomResponse.
         * @memberof proto
         * @classdesc Represents a ClientMuteRoomResponse.
         * @implements IClientMuteRoomResponse
         * @constructor
         * @param {proto.IClientMuteRoomResponse=} [properties] Properties to set
         */
    function ClientMuteRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientMuteRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientMuteRoomResponse
         * @instance
         */
    ClientMuteRoomResponse.prototype.response = null;

    /**
         * ClientMuteRoomResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ClientMuteRoomResponse
         * @instance
         */
    ClientMuteRoomResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientMuteRoomResponse roomMute.
         * @member {proto.RoomMute} roomMute
         * @memberof proto.ClientMuteRoomResponse
         * @instance
         */
    ClientMuteRoomResponse.prototype.roomMute = 0;

    /**
         * Creates a new ClientMuteRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientMuteRoomResponse
         * @static
         * @param {proto.IClientMuteRoomResponse=} [properties] Properties to set
         * @returns {proto.ClientMuteRoomResponse} ClientMuteRoomResponse instance
         */
    ClientMuteRoomResponse.create = function create(properties) {
      return new ClientMuteRoomResponse(properties);
    };

    /**
         * Encodes the specified ClientMuteRoomResponse message. Does not implicitly {@link proto.ClientMuteRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientMuteRoomResponse
         * @static
         * @param {proto.ClientMuteRoomResponse} message ClientMuteRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientMuteRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roomMute);}
      return writer;
    };

    /**
         * Decodes a ClientMuteRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientMuteRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientMuteRoomResponse} ClientMuteRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientMuteRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientMuteRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.roomMute = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientMuteRoomResponse message.
         * @function verify
         * @memberof proto.ClientMuteRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientMuteRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.roomMute != null && message.hasOwnProperty('roomMute')) {
        switch (message.roomMute) {
          default:
            return 'roomMute: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      return null;
    };

    return ClientMuteRoomResponse;
  })();

  proto.ClientPinRoom = (function() {

    /**
         * Properties of a ClientPinRoom.
         * @memberof proto
         * @interface IClientPinRoom
         * @property {proto.Request|null} [request] ClientPinRoom request
         * @property {Long|null} [roomId] ClientPinRoom roomId
         * @property {boolean|null} [pin] ClientPinRoom pin
         */

    /**
         * Constructs a new ClientPinRoom.
         * @memberof proto
         * @classdesc Represents a ClientPinRoom.
         * @implements IClientPinRoom
         * @constructor
         * @param {proto.IClientPinRoom=} [properties] Properties to set
         */
    function ClientPinRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientPinRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientPinRoom
         * @instance
         */
    ClientPinRoom.prototype.request = null;

    /**
         * ClientPinRoom roomId.
         * @member {Long} roomId
         * @memberof proto.ClientPinRoom
         * @instance
         */
    ClientPinRoom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientPinRoom pin.
         * @member {boolean} pin
         * @memberof proto.ClientPinRoom
         * @instance
         */
    ClientPinRoom.prototype.pin = false;

    /**
         * Creates a new ClientPinRoom instance using the specified properties.
         * @function create
         * @memberof proto.ClientPinRoom
         * @static
         * @param {proto.IClientPinRoom=} [properties] Properties to set
         * @returns {proto.ClientPinRoom} ClientPinRoom instance
         */
    ClientPinRoom.create = function create(properties) {
      return new ClientPinRoom(properties);
    };

    /**
         * Encodes the specified ClientPinRoom message. Does not implicitly {@link proto.ClientPinRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientPinRoom
         * @static
         * @param {proto.ClientPinRoom} message ClientPinRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientPinRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.pin != null && message.hasOwnProperty('pin')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.pin);}
      return writer;
    };

    /**
         * Decodes a ClientPinRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientPinRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientPinRoom} ClientPinRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientPinRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPinRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.pin = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientPinRoom message.
         * @function verify
         * @memberof proto.ClientPinRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientPinRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.pin != null && message.hasOwnProperty('pin')) {
        if (typeof message.pin !== 'boolean') {return 'pin: boolean expected';}
      }
      return null;
    };

    return ClientPinRoom;
  })();

  proto.ClientPinRoomResponse = (function() {

    /**
         * Properties of a ClientPinRoomResponse.
         * @memberof proto
         * @interface IClientPinRoomResponse
         * @property {proto.Response|null} [response] ClientPinRoomResponse response
         * @property {Long|null} [roomId] ClientPinRoomResponse roomId
         * @property {Long|null} [pinId] ClientPinRoomResponse pinId
         */

    /**
         * Constructs a new ClientPinRoomResponse.
         * @memberof proto
         * @classdesc Represents a ClientPinRoomResponse.
         * @implements IClientPinRoomResponse
         * @constructor
         * @param {proto.IClientPinRoomResponse=} [properties] Properties to set
         */
    function ClientPinRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientPinRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientPinRoomResponse
         * @instance
         */
    ClientPinRoomResponse.prototype.response = null;

    /**
         * ClientPinRoomResponse roomId.
         * @member {Long} roomId
         * @memberof proto.ClientPinRoomResponse
         * @instance
         */
    ClientPinRoomResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientPinRoomResponse pinId.
         * @member {Long} pinId
         * @memberof proto.ClientPinRoomResponse
         * @instance
         */
    ClientPinRoomResponse.prototype.pinId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientPinRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientPinRoomResponse
         * @static
         * @param {proto.IClientPinRoomResponse=} [properties] Properties to set
         * @returns {proto.ClientPinRoomResponse} ClientPinRoomResponse instance
         */
    ClientPinRoomResponse.create = function create(properties) {
      return new ClientPinRoomResponse(properties);
    };

    /**
         * Encodes the specified ClientPinRoomResponse message. Does not implicitly {@link proto.ClientPinRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientPinRoomResponse
         * @static
         * @param {proto.ClientPinRoomResponse} message ClientPinRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientPinRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.pinId != null && message.hasOwnProperty('pinId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.pinId);}
      return writer;
    };

    /**
         * Decodes a ClientPinRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientPinRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientPinRoomResponse} ClientPinRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientPinRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientPinRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.pinId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientPinRoomResponse message.
         * @function verify
         * @memberof proto.ClientPinRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientPinRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.pinId != null && message.hasOwnProperty('pinId')) {
        if (!$util.isInteger(message.pinId) && !(message.pinId && $util.isInteger(message.pinId.low) && $util.isInteger(message.pinId.high))) {return 'pinId: integer|Long expected';}
      }
      return null;
    };

    return ClientPinRoomResponse;
  })();

  proto.ClientRegisterDevice = (function() {

    /**
         * Properties of a ClientRegisterDevice.
         * @memberof proto
         * @interface IClientRegisterDevice
         * @property {proto.Request|null} [request] ClientRegisterDevice request
         * @property {string|null} [token] ClientRegisterDevice token
         * @property {proto.ClientRegisterDevice.Type|null} [type] ClientRegisterDevice type
         */

    /**
         * Constructs a new ClientRegisterDevice.
         * @memberof proto
         * @classdesc Represents a ClientRegisterDevice.
         * @implements IClientRegisterDevice
         * @constructor
         * @param {proto.IClientRegisterDevice=} [properties] Properties to set
         */
    function ClientRegisterDevice(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientRegisterDevice request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientRegisterDevice
         * @instance
         */
    ClientRegisterDevice.prototype.request = null;

    /**
         * ClientRegisterDevice token.
         * @member {string} token
         * @memberof proto.ClientRegisterDevice
         * @instance
         */
    ClientRegisterDevice.prototype.token = '';

    /**
         * ClientRegisterDevice type.
         * @member {proto.ClientRegisterDevice.Type} type
         * @memberof proto.ClientRegisterDevice
         * @instance
         */
    ClientRegisterDevice.prototype.type = 0;

    /**
         * Creates a new ClientRegisterDevice instance using the specified properties.
         * @function create
         * @memberof proto.ClientRegisterDevice
         * @static
         * @param {proto.IClientRegisterDevice=} [properties] Properties to set
         * @returns {proto.ClientRegisterDevice} ClientRegisterDevice instance
         */
    ClientRegisterDevice.create = function create(properties) {
      return new ClientRegisterDevice(properties);
    };

    /**
         * Encodes the specified ClientRegisterDevice message. Does not implicitly {@link proto.ClientRegisterDevice.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientRegisterDevice
         * @static
         * @param {proto.ClientRegisterDevice} message ClientRegisterDevice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientRegisterDevice.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);}
      return writer;
    };

    /**
         * Decodes a ClientRegisterDevice message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientRegisterDevice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientRegisterDevice} ClientRegisterDevice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientRegisterDevice.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientRegisterDevice();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.type = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientRegisterDevice message.
         * @function verify
         * @memberof proto.ClientRegisterDevice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientRegisterDevice.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.ClientRegisterDevice.Type
         * @enum {string}
         * @property {number} GENERIC=0 GENERIC value
         * @property {number} ANDROID=1 ANDROID value
         * @property {number} IOS=2 IOS value
         * @property {number} WEB=3 WEB value
         */
    ClientRegisterDevice.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'GENERIC'] = 0;
      values[valuesById[1] = 'ANDROID'] = 1;
      values[valuesById[2] = 'IOS'] = 2;
      values[valuesById[3] = 'WEB'] = 3;
      return values;
    })();

    return ClientRegisterDevice;
  })();

  proto.ClientRegisterDeviceResponse = (function() {

    /**
         * Properties of a ClientRegisterDeviceResponse.
         * @memberof proto
         * @interface IClientRegisterDeviceResponse
         * @property {proto.Response|null} [response] ClientRegisterDeviceResponse response
         */

    /**
         * Constructs a new ClientRegisterDeviceResponse.
         * @memberof proto
         * @classdesc Represents a ClientRegisterDeviceResponse.
         * @implements IClientRegisterDeviceResponse
         * @constructor
         * @param {proto.IClientRegisterDeviceResponse=} [properties] Properties to set
         */
    function ClientRegisterDeviceResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientRegisterDeviceResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientRegisterDeviceResponse
         * @instance
         */
    ClientRegisterDeviceResponse.prototype.response = null;

    /**
         * Creates a new ClientRegisterDeviceResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientRegisterDeviceResponse
         * @static
         * @param {proto.IClientRegisterDeviceResponse=} [properties] Properties to set
         * @returns {proto.ClientRegisterDeviceResponse} ClientRegisterDeviceResponse instance
         */
    ClientRegisterDeviceResponse.create = function create(properties) {
      return new ClientRegisterDeviceResponse(properties);
    };

    /**
         * Encodes the specified ClientRegisterDeviceResponse message. Does not implicitly {@link proto.ClientRegisterDeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientRegisterDeviceResponse
         * @static
         * @param {proto.ClientRegisterDeviceResponse} message ClientRegisterDeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientRegisterDeviceResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientRegisterDeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientRegisterDeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientRegisterDeviceResponse} ClientRegisterDeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientRegisterDeviceResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientRegisterDeviceResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientRegisterDeviceResponse message.
         * @function verify
         * @memberof proto.ClientRegisterDeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientRegisterDeviceResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientRegisterDeviceResponse;
  })();

  proto.ClientResolveUsername = (function() {

    /**
         * Properties of a ClientResolveUsername.
         * @memberof proto
         * @interface IClientResolveUsername
         * @property {proto.Request|null} [request] ClientResolveUsername request
         * @property {string|null} [username] ClientResolveUsername username
         */

    /**
         * Constructs a new ClientResolveUsername.
         * @memberof proto
         * @classdesc Represents a ClientResolveUsername.
         * @implements IClientResolveUsername
         * @constructor
         * @param {proto.IClientResolveUsername=} [properties] Properties to set
         */
    function ClientResolveUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientResolveUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientResolveUsername
         * @instance
         */
    ClientResolveUsername.prototype.request = null;

    /**
         * ClientResolveUsername username.
         * @member {string} username
         * @memberof proto.ClientResolveUsername
         * @instance
         */
    ClientResolveUsername.prototype.username = '';

    /**
         * Creates a new ClientResolveUsername instance using the specified properties.
         * @function create
         * @memberof proto.ClientResolveUsername
         * @static
         * @param {proto.IClientResolveUsername=} [properties] Properties to set
         * @returns {proto.ClientResolveUsername} ClientResolveUsername instance
         */
    ClientResolveUsername.create = function create(properties) {
      return new ClientResolveUsername(properties);
    };

    /**
         * Encodes the specified ClientResolveUsername message. Does not implicitly {@link proto.ClientResolveUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientResolveUsername
         * @static
         * @param {proto.ClientResolveUsername} message ClientResolveUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientResolveUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a ClientResolveUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientResolveUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientResolveUsername} ClientResolveUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientResolveUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientResolveUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientResolveUsername message.
         * @function verify
         * @memberof proto.ClientResolveUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientResolveUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return ClientResolveUsername;
  })();

  proto.ClientResolveUsernameResponse = (function() {

    /**
         * Properties of a ClientResolveUsernameResponse.
         * @memberof proto
         * @interface IClientResolveUsernameResponse
         * @property {proto.Response|null} [response] ClientResolveUsernameResponse response
         * @property {proto.ClientResolveUsernameResponse.Type|null} [type] ClientResolveUsernameResponse type
         * @property {proto.RegisteredUser|null} [user] ClientResolveUsernameResponse user
         * @property {proto.Room|null} [room] ClientResolveUsernameResponse room
         */

    /**
         * Constructs a new ClientResolveUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ClientResolveUsernameResponse.
         * @implements IClientResolveUsernameResponse
         * @constructor
         * @param {proto.IClientResolveUsernameResponse=} [properties] Properties to set
         */
    function ClientResolveUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientResolveUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientResolveUsernameResponse
         * @instance
         */
    ClientResolveUsernameResponse.prototype.response = null;

    /**
         * ClientResolveUsernameResponse type.
         * @member {proto.ClientResolveUsernameResponse.Type} type
         * @memberof proto.ClientResolveUsernameResponse
         * @instance
         */
    ClientResolveUsernameResponse.prototype.type = 0;

    /**
         * ClientResolveUsernameResponse user.
         * @member {proto.RegisteredUser|null|undefined} user
         * @memberof proto.ClientResolveUsernameResponse
         * @instance
         */
    ClientResolveUsernameResponse.prototype.user = null;

    /**
         * ClientResolveUsernameResponse room.
         * @member {proto.Room|null|undefined} room
         * @memberof proto.ClientResolveUsernameResponse
         * @instance
         */
    ClientResolveUsernameResponse.prototype.room = null;

    /**
         * Creates a new ClientResolveUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientResolveUsernameResponse
         * @static
         * @param {proto.IClientResolveUsernameResponse=} [properties] Properties to set
         * @returns {proto.ClientResolveUsernameResponse} ClientResolveUsernameResponse instance
         */
    ClientResolveUsernameResponse.create = function create(properties) {
      return new ClientResolveUsernameResponse(properties);
    };

    /**
         * Encodes the specified ClientResolveUsernameResponse message. Does not implicitly {@link proto.ClientResolveUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientResolveUsernameResponse
         * @static
         * @param {proto.ClientResolveUsernameResponse} message ClientResolveUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientResolveUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      if (message.user != null && message.hasOwnProperty('user')) {$root.proto.RegisteredUser.encode(message.user, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      if (message.room != null && message.hasOwnProperty('room')) {$root.proto.Room.encode(message.room, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientResolveUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientResolveUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientResolveUsernameResponse} ClientResolveUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientResolveUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientResolveUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.type = reader.int32();
            break;
          case 3:
            message.user = $root.proto.RegisteredUser.decode(reader, reader.uint32());
            break;
          case 4:
            message.room = $root.proto.Room.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientResolveUsernameResponse message.
         * @function verify
         * @memberof proto.ClientResolveUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientResolveUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.user != null && message.hasOwnProperty('user')) {
        let error = $root.proto.RegisteredUser.verify(message.user);
        if (error) {return 'user.' + error;}
      }
      if (message.room != null && message.hasOwnProperty('room')) {
        let error = $root.proto.Room.verify(message.room);
        if (error) {return 'room.' + error;}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.ClientResolveUsernameResponse.Type
         * @enum {string}
         * @property {number} USER=0 USER value
         * @property {number} ROOM=1 ROOM value
         */
    ClientResolveUsernameResponse.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'USER'] = 0;
      values[valuesById[1] = 'ROOM'] = 1;
      return values;
    })();

    return ClientResolveUsernameResponse;
  })();

  proto.ClientRoomReport = (function() {

    /**
         * Properties of a ClientRoomReport.
         * @memberof proto
         * @interface IClientRoomReport
         * @property {proto.Request|null} [request] ClientRoomReport request
         * @property {Long|null} [roomId] ClientRoomReport roomId
         * @property {Long|null} [messageId] ClientRoomReport messageId
         * @property {proto.ClientRoomReport.Reason|null} [reason] ClientRoomReport reason
         * @property {string|null} [description] ClientRoomReport description
         */

    /**
         * Constructs a new ClientRoomReport.
         * @memberof proto
         * @classdesc Represents a ClientRoomReport.
         * @implements IClientRoomReport
         * @constructor
         * @param {proto.IClientRoomReport=} [properties] Properties to set
         */
    function ClientRoomReport(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientRoomReport request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientRoomReport
         * @instance
         */
    ClientRoomReport.prototype.request = null;

    /**
         * ClientRoomReport roomId.
         * @member {Long} roomId
         * @memberof proto.ClientRoomReport
         * @instance
         */
    ClientRoomReport.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientRoomReport messageId.
         * @member {Long} messageId
         * @memberof proto.ClientRoomReport
         * @instance
         */
    ClientRoomReport.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientRoomReport reason.
         * @member {proto.ClientRoomReport.Reason} reason
         * @memberof proto.ClientRoomReport
         * @instance
         */
    ClientRoomReport.prototype.reason = 0;

    /**
         * ClientRoomReport description.
         * @member {string} description
         * @memberof proto.ClientRoomReport
         * @instance
         */
    ClientRoomReport.prototype.description = '';

    /**
         * Creates a new ClientRoomReport instance using the specified properties.
         * @function create
         * @memberof proto.ClientRoomReport
         * @static
         * @param {proto.IClientRoomReport=} [properties] Properties to set
         * @returns {proto.ClientRoomReport} ClientRoomReport instance
         */
    ClientRoomReport.create = function create(properties) {
      return new ClientRoomReport(properties);
    };

    /**
         * Encodes the specified ClientRoomReport message. Does not implicitly {@link proto.ClientRoomReport.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientRoomReport
         * @static
         * @param {proto.ClientRoomReport} message ClientRoomReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientRoomReport.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.reason != null && message.hasOwnProperty('reason')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reason);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);}
      return writer;
    };

    /**
         * Decodes a ClientRoomReport message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientRoomReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientRoomReport} ClientRoomReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientRoomReport.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientRoomReport();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.reason = reader.int32();
            break;
          case 5:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientRoomReport message.
         * @function verify
         * @memberof proto.ClientRoomReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientRoomReport.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.reason != null && message.hasOwnProperty('reason')) {
        switch (message.reason) {
          default:
            return 'reason: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    /**
         * Reason enum.
         * @name proto.ClientRoomReport.Reason
         * @enum {string}
         * @property {number} OTHER=0 OTHER value
         * @property {number} SPAM=1 SPAM value
         * @property {number} PORNOGRAPHY=2 PORNOGRAPHY value
         * @property {number} VIOLENCE=3 VIOLENCE value
         * @property {number} ABUSE=4 ABUSE value
         */
    ClientRoomReport.Reason = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'OTHER'] = 0;
      values[valuesById[1] = 'SPAM'] = 1;
      values[valuesById[2] = 'PORNOGRAPHY'] = 2;
      values[valuesById[3] = 'VIOLENCE'] = 3;
      values[valuesById[4] = 'ABUSE'] = 4;
      return values;
    })();

    return ClientRoomReport;
  })();

  proto.ClientRoomReportResponse = (function() {

    /**
         * Properties of a ClientRoomReportResponse.
         * @memberof proto
         * @interface IClientRoomReportResponse
         * @property {proto.Response|null} [response] ClientRoomReportResponse response
         */

    /**
         * Constructs a new ClientRoomReportResponse.
         * @memberof proto
         * @classdesc Represents a ClientRoomReportResponse.
         * @implements IClientRoomReportResponse
         * @constructor
         * @param {proto.IClientRoomReportResponse=} [properties] Properties to set
         */
    function ClientRoomReportResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientRoomReportResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientRoomReportResponse
         * @instance
         */
    ClientRoomReportResponse.prototype.response = null;

    /**
         * Creates a new ClientRoomReportResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientRoomReportResponse
         * @static
         * @param {proto.IClientRoomReportResponse=} [properties] Properties to set
         * @returns {proto.ClientRoomReportResponse} ClientRoomReportResponse instance
         */
    ClientRoomReportResponse.create = function create(properties) {
      return new ClientRoomReportResponse(properties);
    };

    /**
         * Encodes the specified ClientRoomReportResponse message. Does not implicitly {@link proto.ClientRoomReportResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientRoomReportResponse
         * @static
         * @param {proto.ClientRoomReportResponse} message ClientRoomReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientRoomReportResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientRoomReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientRoomReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientRoomReportResponse} ClientRoomReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientRoomReportResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientRoomReportResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientRoomReportResponse message.
         * @function verify
         * @memberof proto.ClientRoomReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientRoomReportResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientRoomReportResponse;
  })();

  proto.ClientSearchRoomHistory = (function() {

    /**
         * Properties of a ClientSearchRoomHistory.
         * @memberof proto
         * @interface IClientSearchRoomHistory
         * @property {proto.Request|null} [request] ClientSearchRoomHistory request
         * @property {Long|null} [roomId] ClientSearchRoomHistory roomId
         * @property {number|null} [offset] ClientSearchRoomHistory offset
         * @property {proto.ClientSearchRoomHistory.Filter|null} [filter] ClientSearchRoomHistory filter
         * @property {Long|null} [offsetMessageId] ClientSearchRoomHistory offsetMessageId
         */

    /**
         * Constructs a new ClientSearchRoomHistory.
         * @memberof proto
         * @classdesc Represents a ClientSearchRoomHistory.
         * @implements IClientSearchRoomHistory
         * @constructor
         * @param {proto.IClientSearchRoomHistory=} [properties] Properties to set
         */
    function ClientSearchRoomHistory(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSearchRoomHistory request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientSearchRoomHistory
         * @instance
         */
    ClientSearchRoomHistory.prototype.request = null;

    /**
         * ClientSearchRoomHistory roomId.
         * @member {Long} roomId
         * @memberof proto.ClientSearchRoomHistory
         * @instance
         */
    ClientSearchRoomHistory.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * ClientSearchRoomHistory offset.
         * @member {number} offset
         * @memberof proto.ClientSearchRoomHistory
         * @instance
         */
    ClientSearchRoomHistory.prototype.offset = 0;

    /**
         * ClientSearchRoomHistory filter.
         * @member {proto.ClientSearchRoomHistory.Filter} filter
         * @memberof proto.ClientSearchRoomHistory
         * @instance
         */
    ClientSearchRoomHistory.prototype.filter = 0;

    /**
         * ClientSearchRoomHistory offsetMessageId.
         * @member {Long} offsetMessageId
         * @memberof proto.ClientSearchRoomHistory
         * @instance
         */
    ClientSearchRoomHistory.prototype.offsetMessageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientSearchRoomHistory instance using the specified properties.
         * @function create
         * @memberof proto.ClientSearchRoomHistory
         * @static
         * @param {proto.IClientSearchRoomHistory=} [properties] Properties to set
         * @returns {proto.ClientSearchRoomHistory} ClientSearchRoomHistory instance
         */
    ClientSearchRoomHistory.create = function create(properties) {
      return new ClientSearchRoomHistory(properties);
    };

    /**
         * Encodes the specified ClientSearchRoomHistory message. Does not implicitly {@link proto.ClientSearchRoomHistory.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSearchRoomHistory
         * @static
         * @param {proto.ClientSearchRoomHistory} message ClientSearchRoomHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSearchRoomHistory.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.offset != null && message.hasOwnProperty('offset')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);}
      if (message.filter != null && message.hasOwnProperty('filter')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.filter);}
      if (message.offsetMessageId != null && message.hasOwnProperty('offsetMessageId')) {writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.offsetMessageId);}
      return writer;
    };

    /**
         * Decodes a ClientSearchRoomHistory message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSearchRoomHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSearchRoomHistory} ClientSearchRoomHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSearchRoomHistory.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSearchRoomHistory();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.offset = reader.uint32();
            break;
          case 4:
            message.filter = reader.int32();
            break;
          case 5:
            message.offsetMessageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSearchRoomHistory message.
         * @function verify
         * @memberof proto.ClientSearchRoomHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSearchRoomHistory.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.offset != null && message.hasOwnProperty('offset')) {
        if (!$util.isInteger(message.offset)) {return 'offset: integer expected';}
      }
      if (message.filter != null && message.hasOwnProperty('filter')) {
        switch (message.filter) {
          default:
            return 'filter: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      }
      if (message.offsetMessageId != null && message.hasOwnProperty('offsetMessageId')) {
        if (!$util.isInteger(message.offsetMessageId) && !(message.offsetMessageId && $util.isInteger(message.offsetMessageId.low) && $util.isInteger(message.offsetMessageId.high))) {return 'offsetMessageId: integer|Long expected';}
      }
      return null;
    };

    /**
         * Filter enum.
         * @name proto.ClientSearchRoomHistory.Filter
         * @enum {string}
         * @property {number} IMAGE=0 IMAGE value
         * @property {number} VIDEO=1 VIDEO value
         * @property {number} AUDIO=2 AUDIO value
         * @property {number} VOICE=3 VOICE value
         * @property {number} GIF=4 GIF value
         * @property {number} FILE=5 FILE value
         * @property {number} URL=6 URL value
         */
    ClientSearchRoomHistory.Filter = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'IMAGE'] = 0;
      values[valuesById[1] = 'VIDEO'] = 1;
      values[valuesById[2] = 'AUDIO'] = 2;
      values[valuesById[3] = 'VOICE'] = 3;
      values[valuesById[4] = 'GIF'] = 4;
      values[valuesById[5] = 'FILE'] = 5;
      values[valuesById[6] = 'URL'] = 6;
      return values;
    })();

    return ClientSearchRoomHistory;
  })();

  proto.ClientSearchRoomHistoryResponse = (function() {

    /**
         * Properties of a ClientSearchRoomHistoryResponse.
         * @memberof proto
         * @interface IClientSearchRoomHistoryResponse
         * @property {proto.Response|null} [response] ClientSearchRoomHistoryResponse response
         * @property {number|null} [totalCount] ClientSearchRoomHistoryResponse totalCount
         * @property {number|null} [notDeletedCount] ClientSearchRoomHistoryResponse notDeletedCount
         * @property {Array.<proto.RoomMessage>|null} [result] ClientSearchRoomHistoryResponse result
         */

    /**
         * Constructs a new ClientSearchRoomHistoryResponse.
         * @memberof proto
         * @classdesc Represents a ClientSearchRoomHistoryResponse.
         * @implements IClientSearchRoomHistoryResponse
         * @constructor
         * @param {proto.IClientSearchRoomHistoryResponse=} [properties] Properties to set
         */
    function ClientSearchRoomHistoryResponse(properties) {
      this.result = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSearchRoomHistoryResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @instance
         */
    ClientSearchRoomHistoryResponse.prototype.response = null;

    /**
         * ClientSearchRoomHistoryResponse totalCount.
         * @member {number} totalCount
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @instance
         */
    ClientSearchRoomHistoryResponse.prototype.totalCount = 0;

    /**
         * ClientSearchRoomHistoryResponse notDeletedCount.
         * @member {number} notDeletedCount
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @instance
         */
    ClientSearchRoomHistoryResponse.prototype.notDeletedCount = 0;

    /**
         * ClientSearchRoomHistoryResponse result.
         * @member {Array.<proto.RoomMessage>} result
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @instance
         */
    ClientSearchRoomHistoryResponse.prototype.result = $util.emptyArray;

    /**
         * Creates a new ClientSearchRoomHistoryResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @static
         * @param {proto.IClientSearchRoomHistoryResponse=} [properties] Properties to set
         * @returns {proto.ClientSearchRoomHistoryResponse} ClientSearchRoomHistoryResponse instance
         */
    ClientSearchRoomHistoryResponse.create = function create(properties) {
      return new ClientSearchRoomHistoryResponse(properties);
    };

    /**
         * Encodes the specified ClientSearchRoomHistoryResponse message. Does not implicitly {@link proto.ClientSearchRoomHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @static
         * @param {proto.ClientSearchRoomHistoryResponse} message ClientSearchRoomHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSearchRoomHistoryResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.totalCount != null && message.hasOwnProperty('totalCount')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalCount);}
      if (message.notDeletedCount != null && message.hasOwnProperty('notDeletedCount')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.notDeletedCount);}
      if (message.result != null && message.result.length) {
        for (let i = 0; i < message.result.length; ++i) {$root.proto.RoomMessage.encode(message.result[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ClientSearchRoomHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSearchRoomHistoryResponse} ClientSearchRoomHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSearchRoomHistoryResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSearchRoomHistoryResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.totalCount = reader.uint32();
            break;
          case 3:
            message.notDeletedCount = reader.uint32();
            break;
          case 4:
            if (!(message.result && message.result.length)) {message.result = [];}
            message.result.push($root.proto.RoomMessage.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSearchRoomHistoryResponse message.
         * @function verify
         * @memberof proto.ClientSearchRoomHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSearchRoomHistoryResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.totalCount != null && message.hasOwnProperty('totalCount')) {
        if (!$util.isInteger(message.totalCount)) {return 'totalCount: integer expected';}
      }
      if (message.notDeletedCount != null && message.hasOwnProperty('notDeletedCount')) {
        if (!$util.isInteger(message.notDeletedCount)) {return 'notDeletedCount: integer expected';}
      }
      if (message.result != null && message.hasOwnProperty('result')) {
        if (!Array.isArray(message.result)) {return 'result: array expected';}
        for (let i = 0; i < message.result.length; ++i) {
          let error = $root.proto.RoomMessage.verify(message.result[i]);
          if (error) {return 'result.' + error;}
        }
      }
      return null;
    };

    return ClientSearchRoomHistoryResponse;
  })();

  proto.ClientSearchUsername = (function() {

    /**
         * Properties of a ClientSearchUsername.
         * @memberof proto
         * @interface IClientSearchUsername
         * @property {proto.Request|null} [request] ClientSearchUsername request
         * @property {string|null} [query] ClientSearchUsername query
         */

    /**
         * Constructs a new ClientSearchUsername.
         * @memberof proto
         * @classdesc Represents a ClientSearchUsername.
         * @implements IClientSearchUsername
         * @constructor
         * @param {proto.IClientSearchUsername=} [properties] Properties to set
         */
    function ClientSearchUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSearchUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientSearchUsername
         * @instance
         */
    ClientSearchUsername.prototype.request = null;

    /**
         * ClientSearchUsername query.
         * @member {string} query
         * @memberof proto.ClientSearchUsername
         * @instance
         */
    ClientSearchUsername.prototype.query = '';

    /**
         * Creates a new ClientSearchUsername instance using the specified properties.
         * @function create
         * @memberof proto.ClientSearchUsername
         * @static
         * @param {proto.IClientSearchUsername=} [properties] Properties to set
         * @returns {proto.ClientSearchUsername} ClientSearchUsername instance
         */
    ClientSearchUsername.create = function create(properties) {
      return new ClientSearchUsername(properties);
    };

    /**
         * Encodes the specified ClientSearchUsername message. Does not implicitly {@link proto.ClientSearchUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSearchUsername
         * @static
         * @param {proto.ClientSearchUsername} message ClientSearchUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSearchUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.query != null && message.hasOwnProperty('query')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.query);}
      return writer;
    };

    /**
         * Decodes a ClientSearchUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSearchUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSearchUsername} ClientSearchUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSearchUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSearchUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.query = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSearchUsername message.
         * @function verify
         * @memberof proto.ClientSearchUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSearchUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.query != null && message.hasOwnProperty('query')) {
        if (!$util.isString(message.query)) {return 'query: string expected';}
      }
      return null;
    };

    return ClientSearchUsername;
  })();

  proto.ClientSearchUsernameResponse = (function() {

    /**
         * Properties of a ClientSearchUsernameResponse.
         * @memberof proto
         * @interface IClientSearchUsernameResponse
         * @property {proto.Response|null} [response] ClientSearchUsernameResponse response
         * @property {Array.<proto.ClientSearchUsernameResponse.Result>|null} [result] ClientSearchUsernameResponse result
         */

    /**
         * Constructs a new ClientSearchUsernameResponse.
         * @memberof proto
         * @classdesc Represents a ClientSearchUsernameResponse.
         * @implements IClientSearchUsernameResponse
         * @constructor
         * @param {proto.IClientSearchUsernameResponse=} [properties] Properties to set
         */
    function ClientSearchUsernameResponse(properties) {
      this.result = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSearchUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientSearchUsernameResponse
         * @instance
         */
    ClientSearchUsernameResponse.prototype.response = null;

    /**
         * ClientSearchUsernameResponse result.
         * @member {Array.<proto.ClientSearchUsernameResponse.Result>} result
         * @memberof proto.ClientSearchUsernameResponse
         * @instance
         */
    ClientSearchUsernameResponse.prototype.result = $util.emptyArray;

    /**
         * Creates a new ClientSearchUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientSearchUsernameResponse
         * @static
         * @param {proto.IClientSearchUsernameResponse=} [properties] Properties to set
         * @returns {proto.ClientSearchUsernameResponse} ClientSearchUsernameResponse instance
         */
    ClientSearchUsernameResponse.create = function create(properties) {
      return new ClientSearchUsernameResponse(properties);
    };

    /**
         * Encodes the specified ClientSearchUsernameResponse message. Does not implicitly {@link proto.ClientSearchUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSearchUsernameResponse
         * @static
         * @param {proto.ClientSearchUsernameResponse} message ClientSearchUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSearchUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.result != null && message.result.length) {
        for (let i = 0; i < message.result.length; ++i) {$root.proto.ClientSearchUsernameResponse.Result.encode(message.result[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a ClientSearchUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSearchUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSearchUsernameResponse} ClientSearchUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSearchUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSearchUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.result && message.result.length)) {message.result = [];}
            message.result.push($root.proto.ClientSearchUsernameResponse.Result.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSearchUsernameResponse message.
         * @function verify
         * @memberof proto.ClientSearchUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSearchUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.result != null && message.hasOwnProperty('result')) {
        if (!Array.isArray(message.result)) {return 'result: array expected';}
        for (let i = 0; i < message.result.length; ++i) {
          let error = $root.proto.ClientSearchUsernameResponse.Result.verify(message.result[i]);
          if (error) {return 'result.' + error;}
        }
      }
      return null;
    };

    ClientSearchUsernameResponse.Result = (function() {

      /**
             * Properties of a Result.
             * @memberof proto.ClientSearchUsernameResponse
             * @interface IResult
             * @property {proto.ClientSearchUsernameResponse.Result.Type|null} [type] Result type
             * @property {boolean|null} [exactMatch] Result exactMatch
             * @property {proto.RegisteredUser|null} [user] Result user
             * @property {proto.Room|null} [room] Result room
             */

      /**
             * Constructs a new Result.
             * @memberof proto.ClientSearchUsernameResponse
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {proto.ClientSearchUsernameResponse.IResult=} [properties] Properties to set
             */
      function Result(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Result type.
             * @member {proto.ClientSearchUsernameResponse.Result.Type} type
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @instance
             */
      Result.prototype.type = 0;

      /**
             * Result exactMatch.
             * @member {boolean} exactMatch
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @instance
             */
      Result.prototype.exactMatch = false;

      /**
             * Result user.
             * @member {proto.RegisteredUser|null|undefined} user
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @instance
             */
      Result.prototype.user = null;

      /**
             * Result room.
             * @member {proto.Room|null|undefined} room
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @instance
             */
      Result.prototype.room = null;

      /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @static
             * @param {proto.ClientSearchUsernameResponse.IResult=} [properties] Properties to set
             * @returns {proto.ClientSearchUsernameResponse.Result} Result instance
             */
      Result.create = function create(properties) {
        return new Result(properties);
      };

      /**
             * Encodes the specified Result message. Does not implicitly {@link proto.ClientSearchUsernameResponse.Result.verify|verify} messages.
             * @function encode
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @static
             * @param {proto.ClientSearchUsernameResponse.Result} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Result.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);}
        if (message.exactMatch != null && message.hasOwnProperty('exactMatch')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.exactMatch);}
        if (message.user != null && message.hasOwnProperty('user')) {$root.proto.RegisteredUser.encode(message.user, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
        if (message.room != null && message.hasOwnProperty('room')) {$root.proto.Room.encode(message.room, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
        return writer;
      };

      /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.ClientSearchUsernameResponse.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Result.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSearchUsernameResponse.Result();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.exactMatch = reader.bool();
              break;
            case 3:
              message.user = $root.proto.RegisteredUser.decode(reader, reader.uint32());
              break;
            case 4:
              message.room = $root.proto.Room.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Result message.
             * @function verify
             * @memberof proto.ClientSearchUsernameResponse.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Result.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.type != null && message.hasOwnProperty('type')) {
          switch (message.type) {
            default:
              return 'type: enum value expected';
            case 0:
            case 1:
              break;
          }
        }
        if (message.exactMatch != null && message.hasOwnProperty('exactMatch')) {
          if (typeof message.exactMatch !== 'boolean') {return 'exactMatch: boolean expected';}
        }
        if (message.user != null && message.hasOwnProperty('user')) {
          let error = $root.proto.RegisteredUser.verify(message.user);
          if (error) {return 'user.' + error;}
        }
        if (message.room != null && message.hasOwnProperty('room')) {
          let error = $root.proto.Room.verify(message.room);
          if (error) {return 'room.' + error;}
        }
        return null;
      };

      /**
             * Type enum.
             * @name proto.ClientSearchUsernameResponse.Result.Type
             * @enum {string}
             * @property {number} USER=0 USER value
             * @property {number} ROOM=1 ROOM value
             */
      Result.Type = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = 'USER'] = 0;
        values[valuesById[1] = 'ROOM'] = 1;
        return values;
      })();

      return Result;
    })();

    return ClientSearchUsernameResponse;
  })();

  proto.ClientSubscribeToRoom = (function() {

    /**
         * Properties of a ClientSubscribeToRoom.
         * @memberof proto
         * @interface IClientSubscribeToRoom
         * @property {proto.Request|null} [request] ClientSubscribeToRoom request
         * @property {Long|null} [roomId] ClientSubscribeToRoom roomId
         */

    /**
         * Constructs a new ClientSubscribeToRoom.
         * @memberof proto
         * @classdesc Represents a ClientSubscribeToRoom.
         * @implements IClientSubscribeToRoom
         * @constructor
         * @param {proto.IClientSubscribeToRoom=} [properties] Properties to set
         */
    function ClientSubscribeToRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSubscribeToRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientSubscribeToRoom
         * @instance
         */
    ClientSubscribeToRoom.prototype.request = null;

    /**
         * ClientSubscribeToRoom roomId.
         * @member {Long} roomId
         * @memberof proto.ClientSubscribeToRoom
         * @instance
         */
    ClientSubscribeToRoom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientSubscribeToRoom instance using the specified properties.
         * @function create
         * @memberof proto.ClientSubscribeToRoom
         * @static
         * @param {proto.IClientSubscribeToRoom=} [properties] Properties to set
         * @returns {proto.ClientSubscribeToRoom} ClientSubscribeToRoom instance
         */
    ClientSubscribeToRoom.create = function create(properties) {
      return new ClientSubscribeToRoom(properties);
    };

    /**
         * Encodes the specified ClientSubscribeToRoom message. Does not implicitly {@link proto.ClientSubscribeToRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSubscribeToRoom
         * @static
         * @param {proto.ClientSubscribeToRoom} message ClientSubscribeToRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSubscribeToRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ClientSubscribeToRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSubscribeToRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSubscribeToRoom} ClientSubscribeToRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSubscribeToRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSubscribeToRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSubscribeToRoom message.
         * @function verify
         * @memberof proto.ClientSubscribeToRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSubscribeToRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ClientSubscribeToRoom;
  })();

  proto.ClientSubscribeToRoomResponse = (function() {

    /**
         * Properties of a ClientSubscribeToRoomResponse.
         * @memberof proto
         * @interface IClientSubscribeToRoomResponse
         * @property {proto.Response|null} [response] ClientSubscribeToRoomResponse response
         */

    /**
         * Constructs a new ClientSubscribeToRoomResponse.
         * @memberof proto
         * @classdesc Represents a ClientSubscribeToRoomResponse.
         * @implements IClientSubscribeToRoomResponse
         * @constructor
         * @param {proto.IClientSubscribeToRoomResponse=} [properties] Properties to set
         */
    function ClientSubscribeToRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientSubscribeToRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientSubscribeToRoomResponse
         * @instance
         */
    ClientSubscribeToRoomResponse.prototype.response = null;

    /**
         * Creates a new ClientSubscribeToRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientSubscribeToRoomResponse
         * @static
         * @param {proto.IClientSubscribeToRoomResponse=} [properties] Properties to set
         * @returns {proto.ClientSubscribeToRoomResponse} ClientSubscribeToRoomResponse instance
         */
    ClientSubscribeToRoomResponse.create = function create(properties) {
      return new ClientSubscribeToRoomResponse(properties);
    };

    /**
         * Encodes the specified ClientSubscribeToRoomResponse message. Does not implicitly {@link proto.ClientSubscribeToRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientSubscribeToRoomResponse
         * @static
         * @param {proto.ClientSubscribeToRoomResponse} message ClientSubscribeToRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientSubscribeToRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientSubscribeToRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientSubscribeToRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientSubscribeToRoomResponse} ClientSubscribeToRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientSubscribeToRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientSubscribeToRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientSubscribeToRoomResponse message.
         * @function verify
         * @memberof proto.ClientSubscribeToRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientSubscribeToRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientSubscribeToRoomResponse;
  })();

  proto.ClientUnsubscribeFromRoom = (function() {

    /**
         * Properties of a ClientUnsubscribeFromRoom.
         * @memberof proto
         * @interface IClientUnsubscribeFromRoom
         * @property {proto.Request|null} [request] ClientUnsubscribeFromRoom request
         * @property {Long|null} [roomId] ClientUnsubscribeFromRoom roomId
         */

    /**
         * Constructs a new ClientUnsubscribeFromRoom.
         * @memberof proto
         * @classdesc Represents a ClientUnsubscribeFromRoom.
         * @implements IClientUnsubscribeFromRoom
         * @constructor
         * @param {proto.IClientUnsubscribeFromRoom=} [properties] Properties to set
         */
    function ClientUnsubscribeFromRoom(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientUnsubscribeFromRoom request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ClientUnsubscribeFromRoom
         * @instance
         */
    ClientUnsubscribeFromRoom.prototype.request = null;

    /**
         * ClientUnsubscribeFromRoom roomId.
         * @member {Long} roomId
         * @memberof proto.ClientUnsubscribeFromRoom
         * @instance
         */
    ClientUnsubscribeFromRoom.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new ClientUnsubscribeFromRoom instance using the specified properties.
         * @function create
         * @memberof proto.ClientUnsubscribeFromRoom
         * @static
         * @param {proto.IClientUnsubscribeFromRoom=} [properties] Properties to set
         * @returns {proto.ClientUnsubscribeFromRoom} ClientUnsubscribeFromRoom instance
         */
    ClientUnsubscribeFromRoom.create = function create(properties) {
      return new ClientUnsubscribeFromRoom(properties);
    };

    /**
         * Encodes the specified ClientUnsubscribeFromRoom message. Does not implicitly {@link proto.ClientUnsubscribeFromRoom.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientUnsubscribeFromRoom
         * @static
         * @param {proto.ClientUnsubscribeFromRoom} message ClientUnsubscribeFromRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientUnsubscribeFromRoom.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a ClientUnsubscribeFromRoom message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientUnsubscribeFromRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientUnsubscribeFromRoom} ClientUnsubscribeFromRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientUnsubscribeFromRoom.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientUnsubscribeFromRoom();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientUnsubscribeFromRoom message.
         * @function verify
         * @memberof proto.ClientUnsubscribeFromRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientUnsubscribeFromRoom.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return ClientUnsubscribeFromRoom;
  })();

  proto.ClientUnsubscribeFromRoomResponse = (function() {

    /**
         * Properties of a ClientUnsubscribeFromRoomResponse.
         * @memberof proto
         * @interface IClientUnsubscribeFromRoomResponse
         * @property {proto.Response|null} [response] ClientUnsubscribeFromRoomResponse response
         */

    /**
         * Constructs a new ClientUnsubscribeFromRoomResponse.
         * @memberof proto
         * @classdesc Represents a ClientUnsubscribeFromRoomResponse.
         * @implements IClientUnsubscribeFromRoomResponse
         * @constructor
         * @param {proto.IClientUnsubscribeFromRoomResponse=} [properties] Properties to set
         */
    function ClientUnsubscribeFromRoomResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ClientUnsubscribeFromRoomResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ClientUnsubscribeFromRoomResponse
         * @instance
         */
    ClientUnsubscribeFromRoomResponse.prototype.response = null;

    /**
         * Creates a new ClientUnsubscribeFromRoomResponse instance using the specified properties.
         * @function create
         * @memberof proto.ClientUnsubscribeFromRoomResponse
         * @static
         * @param {proto.IClientUnsubscribeFromRoomResponse=} [properties] Properties to set
         * @returns {proto.ClientUnsubscribeFromRoomResponse} ClientUnsubscribeFromRoomResponse instance
         */
    ClientUnsubscribeFromRoomResponse.create = function create(properties) {
      return new ClientUnsubscribeFromRoomResponse(properties);
    };

    /**
         * Encodes the specified ClientUnsubscribeFromRoomResponse message. Does not implicitly {@link proto.ClientUnsubscribeFromRoomResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ClientUnsubscribeFromRoomResponse
         * @static
         * @param {proto.ClientUnsubscribeFromRoomResponse} message ClientUnsubscribeFromRoomResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ClientUnsubscribeFromRoomResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a ClientUnsubscribeFromRoomResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ClientUnsubscribeFromRoomResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ClientUnsubscribeFromRoomResponse} ClientUnsubscribeFromRoomResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ClientUnsubscribeFromRoomResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ClientUnsubscribeFromRoomResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ClientUnsubscribeFromRoomResponse message.
         * @function verify
         * @memberof proto.ClientUnsubscribeFromRoomResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ClientUnsubscribeFromRoomResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return ClientUnsubscribeFromRoomResponse;
  })();

  proto.ConnectionSecuringResponse = (function() {

    /**
         * Properties of a ConnectionSecuringResponse.
         * @memberof proto
         * @interface IConnectionSecuringResponse
         * @property {proto.Response|null} [response] ConnectionSecuringResponse response
         * @property {string|null} [publicKey] ConnectionSecuringResponse publicKey
         * @property {number|null} [symmetricKeyLength] ConnectionSecuringResponse symmetricKeyLength
         * @property {number|null} [heartbeatInterval] ConnectionSecuringResponse heartbeatInterval
         * @property {string|null} [primaryNodeName] ConnectionSecuringResponse primaryNodeName
         * @property {number|null} [secondaryChunkSize] ConnectionSecuringResponse secondaryChunkSize
         */

    /**
         * Constructs a new ConnectionSecuringResponse.
         * @memberof proto
         * @classdesc Represents a ConnectionSecuringResponse.
         * @implements IConnectionSecuringResponse
         * @constructor
         * @param {proto.IConnectionSecuringResponse=} [properties] Properties to set
         */
    function ConnectionSecuringResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ConnectionSecuringResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.response = null;

    /**
         * ConnectionSecuringResponse publicKey.
         * @member {string} publicKey
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.publicKey = '';

    /**
         * ConnectionSecuringResponse symmetricKeyLength.
         * @member {number} symmetricKeyLength
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.symmetricKeyLength = 0;

    /**
         * ConnectionSecuringResponse heartbeatInterval.
         * @member {number} heartbeatInterval
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.heartbeatInterval = 0;

    /**
         * ConnectionSecuringResponse primaryNodeName.
         * @member {string} primaryNodeName
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.primaryNodeName = '';

    /**
         * ConnectionSecuringResponse secondaryChunkSize.
         * @member {number} secondaryChunkSize
         * @memberof proto.ConnectionSecuringResponse
         * @instance
         */
    ConnectionSecuringResponse.prototype.secondaryChunkSize = 0;

    /**
         * Creates a new ConnectionSecuringResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConnectionSecuringResponse
         * @static
         * @param {proto.IConnectionSecuringResponse=} [properties] Properties to set
         * @returns {proto.ConnectionSecuringResponse} ConnectionSecuringResponse instance
         */
    ConnectionSecuringResponse.create = function create(properties) {
      return new ConnectionSecuringResponse(properties);
    };

    /**
         * Encodes the specified ConnectionSecuringResponse message. Does not implicitly {@link proto.ConnectionSecuringResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConnectionSecuringResponse
         * @static
         * @param {proto.ConnectionSecuringResponse} message ConnectionSecuringResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ConnectionSecuringResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.publicKey != null && message.hasOwnProperty('publicKey')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.publicKey);}
      if (message.symmetricKeyLength != null && message.hasOwnProperty('symmetricKeyLength')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.symmetricKeyLength);}
      if (message.heartbeatInterval != null && message.hasOwnProperty('heartbeatInterval')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.heartbeatInterval);}
      if (message.primaryNodeName != null && message.hasOwnProperty('primaryNodeName')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.primaryNodeName);}
      if (message.secondaryChunkSize != null && message.hasOwnProperty('secondaryChunkSize')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.secondaryChunkSize);}
      return writer;
    };

    /**
         * Decodes a ConnectionSecuringResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConnectionSecuringResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ConnectionSecuringResponse} ConnectionSecuringResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ConnectionSecuringResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectionSecuringResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.publicKey = reader.string();
            break;
          case 3:
            message.symmetricKeyLength = reader.uint32();
            break;
          case 4:
            message.heartbeatInterval = reader.uint32();
            break;
          case 5:
            message.primaryNodeName = reader.string();
            break;
          case 6:
            message.secondaryChunkSize = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ConnectionSecuringResponse message.
         * @function verify
         * @memberof proto.ConnectionSecuringResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ConnectionSecuringResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.publicKey != null && message.hasOwnProperty('publicKey')) {
        if (!$util.isString(message.publicKey)) {return 'publicKey: string expected';}
      }
      if (message.symmetricKeyLength != null && message.hasOwnProperty('symmetricKeyLength')) {
        if (!$util.isInteger(message.symmetricKeyLength)) {return 'symmetricKeyLength: integer expected';}
      }
      if (message.heartbeatInterval != null && message.hasOwnProperty('heartbeatInterval')) {
        if (!$util.isInteger(message.heartbeatInterval)) {return 'heartbeatInterval: integer expected';}
      }
      if (message.primaryNodeName != null && message.hasOwnProperty('primaryNodeName')) {
        if (!$util.isString(message.primaryNodeName)) {return 'primaryNodeName: string expected';}
      }
      if (message.secondaryChunkSize != null && message.hasOwnProperty('secondaryChunkSize')) {
        if (!$util.isInteger(message.secondaryChunkSize)) {return 'secondaryChunkSize: integer expected';}
      }
      return null;
    };

    return ConnectionSecuringResponse;
  })();

  proto.ConnectionSymmetricKey = (function() {

    /**
         * Properties of a ConnectionSymmetricKey.
         * @memberof proto
         * @interface IConnectionSymmetricKey
         * @property {proto.Request|null} [request] ConnectionSymmetricKey request
         * @property {Uint8Array|null} [symmetricKey] ConnectionSymmetricKey symmetricKey
         * @property {number|null} [version] ConnectionSymmetricKey version
         */

    /**
         * Constructs a new ConnectionSymmetricKey.
         * @memberof proto
         * @classdesc Represents a ConnectionSymmetricKey.
         * @implements IConnectionSymmetricKey
         * @constructor
         * @param {proto.IConnectionSymmetricKey=} [properties] Properties to set
         */
    function ConnectionSymmetricKey(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ConnectionSymmetricKey request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.ConnectionSymmetricKey
         * @instance
         */
    ConnectionSymmetricKey.prototype.request = null;

    /**
         * ConnectionSymmetricKey symmetricKey.
         * @member {Uint8Array} symmetricKey
         * @memberof proto.ConnectionSymmetricKey
         * @instance
         */
    ConnectionSymmetricKey.prototype.symmetricKey = $util.newBuffer([]);

    /**
         * ConnectionSymmetricKey version.
         * @member {number} version
         * @memberof proto.ConnectionSymmetricKey
         * @instance
         */
    ConnectionSymmetricKey.prototype.version = 0;

    /**
         * Creates a new ConnectionSymmetricKey instance using the specified properties.
         * @function create
         * @memberof proto.ConnectionSymmetricKey
         * @static
         * @param {proto.IConnectionSymmetricKey=} [properties] Properties to set
         * @returns {proto.ConnectionSymmetricKey} ConnectionSymmetricKey instance
         */
    ConnectionSymmetricKey.create = function create(properties) {
      return new ConnectionSymmetricKey(properties);
    };

    /**
         * Encodes the specified ConnectionSymmetricKey message. Does not implicitly {@link proto.ConnectionSymmetricKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ConnectionSymmetricKey
         * @static
         * @param {proto.ConnectionSymmetricKey} message ConnectionSymmetricKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ConnectionSymmetricKey.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.symmetricKey != null && message.hasOwnProperty('symmetricKey')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.symmetricKey);}
      if (message.version != null && message.hasOwnProperty('version')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);}
      return writer;
    };

    /**
         * Decodes a ConnectionSymmetricKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConnectionSymmetricKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ConnectionSymmetricKey} ConnectionSymmetricKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ConnectionSymmetricKey.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectionSymmetricKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.symmetricKey = reader.bytes();
            break;
          case 3:
            message.version = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ConnectionSymmetricKey message.
         * @function verify
         * @memberof proto.ConnectionSymmetricKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ConnectionSymmetricKey.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.symmetricKey != null && message.hasOwnProperty('symmetricKey')) {
        if (!(message.symmetricKey && typeof message.symmetricKey.length === 'number' || $util.isString(message.symmetricKey))) {return 'symmetricKey: buffer expected';}
      }
      if (message.version != null && message.hasOwnProperty('version')) {
        if (!$util.isInteger(message.version)) {return 'version: integer expected';}
      }
      return null;
    };

    return ConnectionSymmetricKey;
  })();

  proto.ConnectionSymmetricKeyResponse = (function() {

    /**
         * Properties of a ConnectionSymmetricKeyResponse.
         * @memberof proto
         * @interface IConnectionSymmetricKeyResponse
         * @property {proto.Response|null} [response] ConnectionSymmetricKeyResponse response
         * @property {proto.ConnectionSymmetricKeyResponse.Status|null} [status] ConnectionSymmetricKeyResponse status
         * @property {string|null} [symmetricMethod] ConnectionSymmetricKeyResponse symmetricMethod
         * @property {number|null} [symmetricIvSize] ConnectionSymmetricKeyResponse symmetricIvSize
         * @property {boolean|null} [securityIssue] ConnectionSymmetricKeyResponse securityIssue
         */

    /**
         * Constructs a new ConnectionSymmetricKeyResponse.
         * @memberof proto
         * @classdesc Represents a ConnectionSymmetricKeyResponse.
         * @implements IConnectionSymmetricKeyResponse
         * @constructor
         * @param {proto.IConnectionSymmetricKeyResponse=} [properties] Properties to set
         */
    function ConnectionSymmetricKeyResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ConnectionSymmetricKeyResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @instance
         */
    ConnectionSymmetricKeyResponse.prototype.response = null;

    /**
         * ConnectionSymmetricKeyResponse status.
         * @member {proto.ConnectionSymmetricKeyResponse.Status} status
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @instance
         */
    ConnectionSymmetricKeyResponse.prototype.status = 0;

    /**
         * ConnectionSymmetricKeyResponse symmetricMethod.
         * @member {string} symmetricMethod
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @instance
         */
    ConnectionSymmetricKeyResponse.prototype.symmetricMethod = '';

    /**
         * ConnectionSymmetricKeyResponse symmetricIvSize.
         * @member {number} symmetricIvSize
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @instance
         */
    ConnectionSymmetricKeyResponse.prototype.symmetricIvSize = 0;

    /**
         * ConnectionSymmetricKeyResponse securityIssue.
         * @member {boolean} securityIssue
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @instance
         */
    ConnectionSymmetricKeyResponse.prototype.securityIssue = false;

    /**
         * Creates a new ConnectionSymmetricKeyResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @static
         * @param {proto.IConnectionSymmetricKeyResponse=} [properties] Properties to set
         * @returns {proto.ConnectionSymmetricKeyResponse} ConnectionSymmetricKeyResponse instance
         */
    ConnectionSymmetricKeyResponse.create = function create(properties) {
      return new ConnectionSymmetricKeyResponse(properties);
    };

    /**
         * Encodes the specified ConnectionSymmetricKeyResponse message. Does not implicitly {@link proto.ConnectionSymmetricKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @static
         * @param {proto.ConnectionSymmetricKeyResponse} message ConnectionSymmetricKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ConnectionSymmetricKeyResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      if (message.symmetricMethod != null && message.hasOwnProperty('symmetricMethod')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.symmetricMethod);}
      if (message.symmetricIvSize != null && message.hasOwnProperty('symmetricIvSize')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.symmetricIvSize);}
      if (message.securityIssue != null && message.hasOwnProperty('securityIssue')) {writer.uint32(/* id 5, wireType 0 =*/40).bool(message.securityIssue);}
      return writer;
    };

    /**
         * Decodes a ConnectionSymmetricKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ConnectionSymmetricKeyResponse} ConnectionSymmetricKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ConnectionSymmetricKeyResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ConnectionSymmetricKeyResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          case 3:
            message.symmetricMethod = reader.string();
            break;
          case 4:
            message.symmetricIvSize = reader.uint32();
            break;
          case 5:
            message.securityIssue = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a ConnectionSymmetricKeyResponse message.
         * @function verify
         * @memberof proto.ConnectionSymmetricKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ConnectionSymmetricKeyResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.symmetricMethod != null && message.hasOwnProperty('symmetricMethod')) {
        if (!$util.isString(message.symmetricMethod)) {return 'symmetricMethod: string expected';}
      }
      if (message.symmetricIvSize != null && message.hasOwnProperty('symmetricIvSize')) {
        if (!$util.isInteger(message.symmetricIvSize)) {return 'symmetricIvSize: integer expected';}
      }
      if (message.securityIssue != null && message.hasOwnProperty('securityIssue')) {
        if (typeof message.securityIssue !== 'boolean') {return 'securityIssue: boolean expected';}
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.ConnectionSymmetricKeyResponse.Status
         * @enum {string}
         * @property {number} REJECTED=0 REJECTED value
         * @property {number} ACCEPTED=1 ACCEPTED value
         */
    ConnectionSymmetricKeyResponse.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'REJECTED'] = 0;
      values[valuesById[1] = 'ACCEPTED'] = 1;
      return values;
    })();

    return ConnectionSymmetricKeyResponse;
  })();

  proto.ErrorResponse = (function() {

    /**
         * Properties of an ErrorResponse.
         * @memberof proto
         * @interface IErrorResponse
         * @property {proto.Response|null} [response] ErrorResponse response
         * @property {number|null} [majorCode] ErrorResponse majorCode
         * @property {number|null} [minorCode] ErrorResponse minorCode
         * @property {number|null} [wait] ErrorResponse wait
         * @property {string|null} [message] ErrorResponse message
         */

    /**
         * Constructs a new ErrorResponse.
         * @memberof proto
         * @classdesc Represents an ErrorResponse.
         * @implements IErrorResponse
         * @constructor
         * @param {proto.IErrorResponse=} [properties] Properties to set
         */
    function ErrorResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * ErrorResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.ErrorResponse
         * @instance
         */
    ErrorResponse.prototype.response = null;

    /**
         * ErrorResponse majorCode.
         * @member {number} majorCode
         * @memberof proto.ErrorResponse
         * @instance
         */
    ErrorResponse.prototype.majorCode = 0;

    /**
         * ErrorResponse minorCode.
         * @member {number} minorCode
         * @memberof proto.ErrorResponse
         * @instance
         */
    ErrorResponse.prototype.minorCode = 0;

    /**
         * ErrorResponse wait.
         * @member {number} wait
         * @memberof proto.ErrorResponse
         * @instance
         */
    ErrorResponse.prototype.wait = 0;

    /**
         * ErrorResponse message.
         * @member {string} message
         * @memberof proto.ErrorResponse
         * @instance
         */
    ErrorResponse.prototype.message = '';

    /**
         * Creates a new ErrorResponse instance using the specified properties.
         * @function create
         * @memberof proto.ErrorResponse
         * @static
         * @param {proto.IErrorResponse=} [properties] Properties to set
         * @returns {proto.ErrorResponse} ErrorResponse instance
         */
    ErrorResponse.create = function create(properties) {
      return new ErrorResponse(properties);
    };

    /**
         * Encodes the specified ErrorResponse message. Does not implicitly {@link proto.ErrorResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ErrorResponse
         * @static
         * @param {proto.ErrorResponse} message ErrorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    ErrorResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.majorCode != null && message.hasOwnProperty('majorCode')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.majorCode);}
      if (message.minorCode != null && message.hasOwnProperty('minorCode')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.minorCode);}
      if (message.wait != null && message.hasOwnProperty('wait')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.wait);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);}
      return writer;
    };

    /**
         * Decodes an ErrorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ErrorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ErrorResponse} ErrorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    ErrorResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ErrorResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.majorCode = reader.uint32();
            break;
          case 3:
            message.minorCode = reader.uint32();
            break;
          case 4:
            message.wait = reader.uint32();
            break;
          case 5:
            message.message = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an ErrorResponse message.
         * @function verify
         * @memberof proto.ErrorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    ErrorResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.majorCode != null && message.hasOwnProperty('majorCode')) {
        if (!$util.isInteger(message.majorCode)) {return 'majorCode: integer expected';}
      }
      if (message.minorCode != null && message.hasOwnProperty('minorCode')) {
        if (!$util.isInteger(message.minorCode)) {return 'minorCode: integer expected';}
      }
      if (message.wait != null && message.hasOwnProperty('wait')) {
        if (!$util.isInteger(message.wait)) {return 'wait: integer expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      return null;
    };

    return ErrorResponse;
  })();

  proto.FileDownload = (function() {

    /**
         * Properties of a FileDownload.
         * @memberof proto
         * @interface IFileDownload
         * @property {proto.Request|null} [request] FileDownload request
         * @property {string|null} [token] FileDownload token
         * @property {Long|null} [offset] FileDownload offset
         * @property {number|null} [maxLimit] FileDownload maxLimit
         * @property {proto.FileDownload.Selector|null} [selector] FileDownload selector
         */

    /**
         * Constructs a new FileDownload.
         * @memberof proto
         * @classdesc Represents a FileDownload.
         * @implements IFileDownload
         * @constructor
         * @param {proto.IFileDownload=} [properties] Properties to set
         */
    function FileDownload(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileDownload request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileDownload
         * @instance
         */
    FileDownload.prototype.request = null;

    /**
         * FileDownload token.
         * @member {string} token
         * @memberof proto.FileDownload
         * @instance
         */
    FileDownload.prototype.token = '';

    /**
         * FileDownload offset.
         * @member {Long} offset
         * @memberof proto.FileDownload
         * @instance
         */
    FileDownload.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * FileDownload maxLimit.
         * @member {number} maxLimit
         * @memberof proto.FileDownload
         * @instance
         */
    FileDownload.prototype.maxLimit = 0;

    /**
         * FileDownload selector.
         * @member {proto.FileDownload.Selector} selector
         * @memberof proto.FileDownload
         * @instance
         */
    FileDownload.prototype.selector = 0;

    /**
         * Creates a new FileDownload instance using the specified properties.
         * @function create
         * @memberof proto.FileDownload
         * @static
         * @param {proto.IFileDownload=} [properties] Properties to set
         * @returns {proto.FileDownload} FileDownload instance
         */
    FileDownload.create = function create(properties) {
      return new FileDownload(properties);
    };

    /**
         * Encodes the specified FileDownload message. Does not implicitly {@link proto.FileDownload.verify|verify} messages.
         * @function encode
         * @memberof proto.FileDownload
         * @static
         * @param {proto.FileDownload} message FileDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileDownload.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.offset != null && message.hasOwnProperty('offset')) {writer.uint32(/* id 3, wireType 0 =*/24).int64(message.offset);}
      if (message.maxLimit != null && message.hasOwnProperty('maxLimit')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxLimit);}
      if (message.selector != null && message.hasOwnProperty('selector')) {writer.uint32(/* id 5, wireType 0 =*/40).int32(message.selector);}
      return writer;
    };

    /**
         * Decodes a FileDownload message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileDownload} FileDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileDownload.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileDownload();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.offset = reader.int64();
            break;
          case 4:
            message.maxLimit = reader.int32();
            break;
          case 5:
            message.selector = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileDownload message.
         * @function verify
         * @memberof proto.FileDownload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileDownload.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.offset != null && message.hasOwnProperty('offset')) {
        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))) {return 'offset: integer|Long expected';}
      }
      if (message.maxLimit != null && message.hasOwnProperty('maxLimit')) {
        if (!$util.isInteger(message.maxLimit)) {return 'maxLimit: integer expected';}
      }
      if (message.selector != null && message.hasOwnProperty('selector')) {
        switch (message.selector) {
          default:
            return 'selector: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    /**
         * Selector enum.
         * @name proto.FileDownload.Selector
         * @enum {string}
         * @property {number} FILE=0 FILE value
         * @property {number} SMALL_THUMBNAIL=1 SMALL_THUMBNAIL value
         * @property {number} LARGE_THUMBNAIL=2 LARGE_THUMBNAIL value
         * @property {number} WAVEFORM_THUMBNAIL=3 WAVEFORM_THUMBNAIL value
         */
    FileDownload.Selector = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'FILE'] = 0;
      values[valuesById[1] = 'SMALL_THUMBNAIL'] = 1;
      values[valuesById[2] = 'LARGE_THUMBNAIL'] = 2;
      values[valuesById[3] = 'WAVEFORM_THUMBNAIL'] = 3;
      return values;
    })();

    return FileDownload;
  })();

  proto.FileDownloadResponse = (function() {

    /**
         * Properties of a FileDownloadResponse.
         * @memberof proto
         * @interface IFileDownloadResponse
         * @property {proto.Response|null} [response] FileDownloadResponse response
         * @property {Uint8Array|null} [bytes] FileDownloadResponse bytes
         */

    /**
         * Constructs a new FileDownloadResponse.
         * @memberof proto
         * @classdesc Represents a FileDownloadResponse.
         * @implements IFileDownloadResponse
         * @constructor
         * @param {proto.IFileDownloadResponse=} [properties] Properties to set
         */
    function FileDownloadResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileDownloadResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileDownloadResponse
         * @instance
         */
    FileDownloadResponse.prototype.response = null;

    /**
         * FileDownloadResponse bytes.
         * @member {Uint8Array} bytes
         * @memberof proto.FileDownloadResponse
         * @instance
         */
    FileDownloadResponse.prototype.bytes = $util.newBuffer([]);

    /**
         * Creates a new FileDownloadResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileDownloadResponse
         * @static
         * @param {proto.IFileDownloadResponse=} [properties] Properties to set
         * @returns {proto.FileDownloadResponse} FileDownloadResponse instance
         */
    FileDownloadResponse.create = function create(properties) {
      return new FileDownloadResponse(properties);
    };

    /**
         * Encodes the specified FileDownloadResponse message. Does not implicitly {@link proto.FileDownloadResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileDownloadResponse
         * @static
         * @param {proto.FileDownloadResponse} message FileDownloadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileDownloadResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.bytes != null && message.hasOwnProperty('bytes')) {writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bytes);}
      return writer;
    };

    /**
         * Decodes a FileDownloadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileDownloadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileDownloadResponse} FileDownloadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileDownloadResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileDownloadResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 4:
            message.bytes = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileDownloadResponse message.
         * @function verify
         * @memberof proto.FileDownloadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileDownloadResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.bytes != null && message.hasOwnProperty('bytes')) {
        if (!(message.bytes && typeof message.bytes.length === 'number' || $util.isString(message.bytes))) {return 'bytes: buffer expected';}
      }
      return null;
    };

    return FileDownloadResponse;
  })();

  proto.FileInfo = (function() {

    /**
         * Properties of a FileInfo.
         * @memberof proto
         * @interface IFileInfo
         * @property {proto.Request|null} [request] FileInfo request
         * @property {string|null} [token] FileInfo token
         */

    /**
         * Constructs a new FileInfo.
         * @memberof proto
         * @classdesc Represents a FileInfo.
         * @implements IFileInfo
         * @constructor
         * @param {proto.IFileInfo=} [properties] Properties to set
         */
    function FileInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileInfo request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileInfo
         * @instance
         */
    FileInfo.prototype.request = null;

    /**
         * FileInfo token.
         * @member {string} token
         * @memberof proto.FileInfo
         * @instance
         */
    FileInfo.prototype.token = '';

    /**
         * Creates a new FileInfo instance using the specified properties.
         * @function create
         * @memberof proto.FileInfo
         * @static
         * @param {proto.IFileInfo=} [properties] Properties to set
         * @returns {proto.FileInfo} FileInfo instance
         */
    FileInfo.create = function create(properties) {
      return new FileInfo(properties);
    };

    /**
         * Encodes the specified FileInfo message. Does not implicitly {@link proto.FileInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.FileInfo
         * @static
         * @param {proto.FileInfo} message FileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileInfo.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a FileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileInfo} FileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileInfo.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileInfo();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileInfo message.
         * @function verify
         * @memberof proto.FileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileInfo.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return FileInfo;
  })();

  proto.FileInfoResponse = (function() {

    /**
         * Properties of a FileInfoResponse.
         * @memberof proto
         * @interface IFileInfoResponse
         * @property {proto.Response|null} [response] FileInfoResponse response
         * @property {proto.File|null} [file] FileInfoResponse file
         */

    /**
         * Constructs a new FileInfoResponse.
         * @memberof proto
         * @classdesc Represents a FileInfoResponse.
         * @implements IFileInfoResponse
         * @constructor
         * @param {proto.IFileInfoResponse=} [properties] Properties to set
         */
    function FileInfoResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileInfoResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileInfoResponse
         * @instance
         */
    FileInfoResponse.prototype.response = null;

    /**
         * FileInfoResponse file.
         * @member {proto.File|null|undefined} file
         * @memberof proto.FileInfoResponse
         * @instance
         */
    FileInfoResponse.prototype.file = null;

    /**
         * Creates a new FileInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileInfoResponse
         * @static
         * @param {proto.IFileInfoResponse=} [properties] Properties to set
         * @returns {proto.FileInfoResponse} FileInfoResponse instance
         */
    FileInfoResponse.create = function create(properties) {
      return new FileInfoResponse(properties);
    };

    /**
         * Encodes the specified FileInfoResponse message. Does not implicitly {@link proto.FileInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileInfoResponse
         * @static
         * @param {proto.FileInfoResponse} message FileInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileInfoResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.file != null && message.hasOwnProperty('file')) {$root.proto.File.encode(message.file, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a FileInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileInfoResponse} FileInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileInfoResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileInfoResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.file = $root.proto.File.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileInfoResponse message.
         * @function verify
         * @memberof proto.FileInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileInfoResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.file != null && message.hasOwnProperty('file')) {
        let error = $root.proto.File.verify(message.file);
        if (error) {return 'file.' + error;}
      }
      return null;
    };

    return FileInfoResponse;
  })();

  proto.FileUpload = (function() {

    /**
         * Properties of a FileUpload.
         * @memberof proto
         * @interface IFileUpload
         * @property {proto.Request|null} [request] FileUpload request
         * @property {string|null} [token] FileUpload token
         * @property {Long|null} [offset] FileUpload offset
         * @property {Uint8Array|null} [bytes] FileUpload bytes
         */

    /**
         * Constructs a new FileUpload.
         * @memberof proto
         * @classdesc Represents a FileUpload.
         * @implements IFileUpload
         * @constructor
         * @param {proto.IFileUpload=} [properties] Properties to set
         */
    function FileUpload(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUpload request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileUpload
         * @instance
         */
    FileUpload.prototype.request = null;

    /**
         * FileUpload token.
         * @member {string} token
         * @memberof proto.FileUpload
         * @instance
         */
    FileUpload.prototype.token = '';

    /**
         * FileUpload offset.
         * @member {Long} offset
         * @memberof proto.FileUpload
         * @instance
         */
    FileUpload.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * FileUpload bytes.
         * @member {Uint8Array} bytes
         * @memberof proto.FileUpload
         * @instance
         */
    FileUpload.prototype.bytes = $util.newBuffer([]);

    /**
         * Creates a new FileUpload instance using the specified properties.
         * @function create
         * @memberof proto.FileUpload
         * @static
         * @param {proto.IFileUpload=} [properties] Properties to set
         * @returns {proto.FileUpload} FileUpload instance
         */
    FileUpload.create = function create(properties) {
      return new FileUpload(properties);
    };

    /**
         * Encodes the specified FileUpload message. Does not implicitly {@link proto.FileUpload.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUpload
         * @static
         * @param {proto.FileUpload} message FileUpload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUpload.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.offset != null && message.hasOwnProperty('offset')) {writer.uint32(/* id 3, wireType 0 =*/24).int64(message.offset);}
      if (message.bytes != null && message.hasOwnProperty('bytes')) {writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bytes);}
      return writer;
    };

    /**
         * Decodes a FileUpload message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUpload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUpload} FileUpload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUpload.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUpload();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.offset = reader.int64();
            break;
          case 4:
            message.bytes = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUpload message.
         * @function verify
         * @memberof proto.FileUpload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUpload.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.offset != null && message.hasOwnProperty('offset')) {
        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))) {return 'offset: integer|Long expected';}
      }
      if (message.bytes != null && message.hasOwnProperty('bytes')) {
        if (!(message.bytes && typeof message.bytes.length === 'number' || $util.isString(message.bytes))) {return 'bytes: buffer expected';}
      }
      return null;
    };

    return FileUpload;
  })();

  proto.FileUploadResponse = (function() {

    /**
         * Properties of a FileUploadResponse.
         * @memberof proto
         * @interface IFileUploadResponse
         * @property {proto.Response|null} [response] FileUploadResponse response
         * @property {number|null} [progress] FileUploadResponse progress
         * @property {Long|null} [nextOffset] FileUploadResponse nextOffset
         * @property {number|null} [nextLimit] FileUploadResponse nextLimit
         */

    /**
         * Constructs a new FileUploadResponse.
         * @memberof proto
         * @classdesc Represents a FileUploadResponse.
         * @implements IFileUploadResponse
         * @constructor
         * @param {proto.IFileUploadResponse=} [properties] Properties to set
         */
    function FileUploadResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileUploadResponse
         * @instance
         */
    FileUploadResponse.prototype.response = null;

    /**
         * FileUploadResponse progress.
         * @member {number} progress
         * @memberof proto.FileUploadResponse
         * @instance
         */
    FileUploadResponse.prototype.progress = 0;

    /**
         * FileUploadResponse nextOffset.
         * @member {Long} nextOffset
         * @memberof proto.FileUploadResponse
         * @instance
         */
    FileUploadResponse.prototype.nextOffset = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * FileUploadResponse nextLimit.
         * @member {number} nextLimit
         * @memberof proto.FileUploadResponse
         * @instance
         */
    FileUploadResponse.prototype.nextLimit = 0;

    /**
         * Creates a new FileUploadResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadResponse
         * @static
         * @param {proto.IFileUploadResponse=} [properties] Properties to set
         * @returns {proto.FileUploadResponse} FileUploadResponse instance
         */
    FileUploadResponse.create = function create(properties) {
      return new FileUploadResponse(properties);
    };

    /**
         * Encodes the specified FileUploadResponse message. Does not implicitly {@link proto.FileUploadResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadResponse
         * @static
         * @param {proto.FileUploadResponse} message FileUploadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.progress != null && message.hasOwnProperty('progress')) {writer.uint32(/* id 2, wireType 1 =*/17).double(message.progress);}
      if (message.nextOffset != null && message.hasOwnProperty('nextOffset')) {writer.uint32(/* id 3, wireType 0 =*/24).int64(message.nextOffset);}
      if (message.nextLimit != null && message.hasOwnProperty('nextLimit')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.nextLimit);}
      return writer;
    };

    /**
         * Decodes a FileUploadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadResponse} FileUploadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.progress = reader.double();
            break;
          case 3:
            message.nextOffset = reader.int64();
            break;
          case 4:
            message.nextLimit = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadResponse message.
         * @function verify
         * @memberof proto.FileUploadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.progress != null && message.hasOwnProperty('progress')) {
        if (typeof message.progress !== 'number') {return 'progress: number expected';}
      }
      if (message.nextOffset != null && message.hasOwnProperty('nextOffset')) {
        if (!$util.isInteger(message.nextOffset) && !(message.nextOffset && $util.isInteger(message.nextOffset.low) && $util.isInteger(message.nextOffset.high))) {return 'nextOffset: integer|Long expected';}
      }
      if (message.nextLimit != null && message.hasOwnProperty('nextLimit')) {
        if (!$util.isInteger(message.nextLimit)) {return 'nextLimit: integer expected';}
      }
      return null;
    };

    return FileUploadResponse;
  })();

  proto.FileUploadInit = (function() {

    /**
         * Properties of a FileUploadInit.
         * @memberof proto
         * @interface IFileUploadInit
         * @property {proto.Request|null} [request] FileUploadInit request
         * @property {Uint8Array|null} [firstBytes] FileUploadInit firstBytes
         * @property {Uint8Array|null} [lastBytes] FileUploadInit lastBytes
         * @property {Long|null} [size] FileUploadInit size
         * @property {Uint8Array|null} [fileHash] FileUploadInit fileHash
         * @property {string|null} [fileName] FileUploadInit fileName
         */

    /**
         * Constructs a new FileUploadInit.
         * @memberof proto
         * @classdesc Represents a FileUploadInit.
         * @implements IFileUploadInit
         * @constructor
         * @param {proto.IFileUploadInit=} [properties] Properties to set
         */
    function FileUploadInit(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadInit request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.request = null;

    /**
         * FileUploadInit firstBytes.
         * @member {Uint8Array} firstBytes
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.firstBytes = $util.newBuffer([]);

    /**
         * FileUploadInit lastBytes.
         * @member {Uint8Array} lastBytes
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.lastBytes = $util.newBuffer([]);

    /**
         * FileUploadInit size.
         * @member {Long} size
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * FileUploadInit fileHash.
         * @member {Uint8Array} fileHash
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.fileHash = $util.newBuffer([]);

    /**
         * FileUploadInit fileName.
         * @member {string} fileName
         * @memberof proto.FileUploadInit
         * @instance
         */
    FileUploadInit.prototype.fileName = '';

    /**
         * Creates a new FileUploadInit instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadInit
         * @static
         * @param {proto.IFileUploadInit=} [properties] Properties to set
         * @returns {proto.FileUploadInit} FileUploadInit instance
         */
    FileUploadInit.create = function create(properties) {
      return new FileUploadInit(properties);
    };

    /**
         * Encodes the specified FileUploadInit message. Does not implicitly {@link proto.FileUploadInit.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadInit
         * @static
         * @param {proto.FileUploadInit} message FileUploadInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadInit.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.firstBytes != null && message.hasOwnProperty('firstBytes')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.firstBytes);}
      if (message.lastBytes != null && message.hasOwnProperty('lastBytes')) {writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.lastBytes);}
      if (message.size != null && message.hasOwnProperty('size')) {writer.uint32(/* id 4, wireType 0 =*/32).int64(message.size);}
      if (message.fileHash != null && message.hasOwnProperty('fileHash')) {writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.fileHash);}
      if (message.fileName != null && message.hasOwnProperty('fileName')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.fileName);}
      return writer;
    };

    /**
         * Decodes a FileUploadInit message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadInit} FileUploadInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadInit.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadInit();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.firstBytes = reader.bytes();
            break;
          case 3:
            message.lastBytes = reader.bytes();
            break;
          case 4:
            message.size = reader.int64();
            break;
          case 5:
            message.fileHash = reader.bytes();
            break;
          case 6:
            message.fileName = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadInit message.
         * @function verify
         * @memberof proto.FileUploadInit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadInit.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.firstBytes != null && message.hasOwnProperty('firstBytes')) {
        if (!(message.firstBytes && typeof message.firstBytes.length === 'number' || $util.isString(message.firstBytes))) {return 'firstBytes: buffer expected';}
      }
      if (message.lastBytes != null && message.hasOwnProperty('lastBytes')) {
        if (!(message.lastBytes && typeof message.lastBytes.length === 'number' || $util.isString(message.lastBytes))) {return 'lastBytes: buffer expected';}
      }
      if (message.size != null && message.hasOwnProperty('size')) {
        if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high))) {return 'size: integer|Long expected';}
      }
      if (message.fileHash != null && message.hasOwnProperty('fileHash')) {
        if (!(message.fileHash && typeof message.fileHash.length === 'number' || $util.isString(message.fileHash))) {return 'fileHash: buffer expected';}
      }
      if (message.fileName != null && message.hasOwnProperty('fileName')) {
        if (!$util.isString(message.fileName)) {return 'fileName: string expected';}
      }
      return null;
    };

    return FileUploadInit;
  })();

  proto.FileUploadInitResponse = (function() {

    /**
         * Properties of a FileUploadInitResponse.
         * @memberof proto
         * @interface IFileUploadInitResponse
         * @property {proto.Response|null} [response] FileUploadInitResponse response
         * @property {string|null} [token] FileUploadInitResponse token
         * @property {number|null} [progress] FileUploadInitResponse progress
         * @property {Long|null} [offset] FileUploadInitResponse offset
         * @property {number|null} [limit] FileUploadInitResponse limit
         */

    /**
         * Constructs a new FileUploadInitResponse.
         * @memberof proto
         * @classdesc Represents a FileUploadInitResponse.
         * @implements IFileUploadInitResponse
         * @constructor
         * @param {proto.IFileUploadInitResponse=} [properties] Properties to set
         */
    function FileUploadInitResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadInitResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileUploadInitResponse
         * @instance
         */
    FileUploadInitResponse.prototype.response = null;

    /**
         * FileUploadInitResponse token.
         * @member {string} token
         * @memberof proto.FileUploadInitResponse
         * @instance
         */
    FileUploadInitResponse.prototype.token = '';

    /**
         * FileUploadInitResponse progress.
         * @member {number} progress
         * @memberof proto.FileUploadInitResponse
         * @instance
         */
    FileUploadInitResponse.prototype.progress = 0;

    /**
         * FileUploadInitResponse offset.
         * @member {Long} offset
         * @memberof proto.FileUploadInitResponse
         * @instance
         */
    FileUploadInitResponse.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * FileUploadInitResponse limit.
         * @member {number} limit
         * @memberof proto.FileUploadInitResponse
         * @instance
         */
    FileUploadInitResponse.prototype.limit = 0;

    /**
         * Creates a new FileUploadInitResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadInitResponse
         * @static
         * @param {proto.IFileUploadInitResponse=} [properties] Properties to set
         * @returns {proto.FileUploadInitResponse} FileUploadInitResponse instance
         */
    FileUploadInitResponse.create = function create(properties) {
      return new FileUploadInitResponse(properties);
    };

    /**
         * Encodes the specified FileUploadInitResponse message. Does not implicitly {@link proto.FileUploadInitResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadInitResponse
         * @static
         * @param {proto.FileUploadInitResponse} message FileUploadInitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadInitResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.progress != null && message.hasOwnProperty('progress')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.progress);}
      if (message.offset != null && message.hasOwnProperty('offset')) {writer.uint32(/* id 4, wireType 0 =*/32).int64(message.offset);}
      if (message.limit != null && message.hasOwnProperty('limit')) {writer.uint32(/* id 5, wireType 0 =*/40).int32(message.limit);}
      return writer;
    };

    /**
         * Decodes a FileUploadInitResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadInitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadInitResponse} FileUploadInitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadInitResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadInitResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.progress = reader.double();
            break;
          case 4:
            message.offset = reader.int64();
            break;
          case 5:
            message.limit = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadInitResponse message.
         * @function verify
         * @memberof proto.FileUploadInitResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadInitResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.progress != null && message.hasOwnProperty('progress')) {
        if (typeof message.progress !== 'number') {return 'progress: number expected';}
      }
      if (message.offset != null && message.hasOwnProperty('offset')) {
        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))) {return 'offset: integer|Long expected';}
      }
      if (message.limit != null && message.hasOwnProperty('limit')) {
        if (!$util.isInteger(message.limit)) {return 'limit: integer expected';}
      }
      return null;
    };

    return FileUploadInitResponse;
  })();

  proto.FileUploadOption = (function() {

    /**
         * Properties of a FileUploadOption.
         * @memberof proto
         * @interface IFileUploadOption
         * @property {proto.Request|null} [request] FileUploadOption request
         * @property {Long|null} [size] FileUploadOption size
         */

    /**
         * Constructs a new FileUploadOption.
         * @memberof proto
         * @classdesc Represents a FileUploadOption.
         * @implements IFileUploadOption
         * @constructor
         * @param {proto.IFileUploadOption=} [properties] Properties to set
         */
    function FileUploadOption(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadOption request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileUploadOption
         * @instance
         */
    FileUploadOption.prototype.request = null;

    /**
         * FileUploadOption size.
         * @member {Long} size
         * @memberof proto.FileUploadOption
         * @instance
         */
    FileUploadOption.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
         * Creates a new FileUploadOption instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadOption
         * @static
         * @param {proto.IFileUploadOption=} [properties] Properties to set
         * @returns {proto.FileUploadOption} FileUploadOption instance
         */
    FileUploadOption.create = function create(properties) {
      return new FileUploadOption(properties);
    };

    /**
         * Encodes the specified FileUploadOption message. Does not implicitly {@link proto.FileUploadOption.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadOption
         * @static
         * @param {proto.FileUploadOption} message FileUploadOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadOption.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.size != null && message.hasOwnProperty('size')) {writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);}
      return writer;
    };

    /**
         * Decodes a FileUploadOption message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadOption} FileUploadOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadOption.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadOption();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.size = reader.int64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadOption message.
         * @function verify
         * @memberof proto.FileUploadOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadOption.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.size != null && message.hasOwnProperty('size')) {
        if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high))) {return 'size: integer|Long expected';}
      }
      return null;
    };

    return FileUploadOption;
  })();

  proto.FileUploadOptionResponse = (function() {

    /**
         * Properties of a FileUploadOptionResponse.
         * @memberof proto
         * @interface IFileUploadOptionResponse
         * @property {proto.Response|null} [response] FileUploadOptionResponse response
         * @property {number|null} [firstBytesLimit] FileUploadOptionResponse firstBytesLimit
         * @property {number|null} [lastBytesLimit] FileUploadOptionResponse lastBytesLimit
         * @property {number|null} [maxConnection] FileUploadOptionResponse maxConnection
         */

    /**
         * Constructs a new FileUploadOptionResponse.
         * @memberof proto
         * @classdesc Represents a FileUploadOptionResponse.
         * @implements IFileUploadOptionResponse
         * @constructor
         * @param {proto.IFileUploadOptionResponse=} [properties] Properties to set
         */
    function FileUploadOptionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadOptionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileUploadOptionResponse
         * @instance
         */
    FileUploadOptionResponse.prototype.response = null;

    /**
         * FileUploadOptionResponse firstBytesLimit.
         * @member {number} firstBytesLimit
         * @memberof proto.FileUploadOptionResponse
         * @instance
         */
    FileUploadOptionResponse.prototype.firstBytesLimit = 0;

    /**
         * FileUploadOptionResponse lastBytesLimit.
         * @member {number} lastBytesLimit
         * @memberof proto.FileUploadOptionResponse
         * @instance
         */
    FileUploadOptionResponse.prototype.lastBytesLimit = 0;

    /**
         * FileUploadOptionResponse maxConnection.
         * @member {number} maxConnection
         * @memberof proto.FileUploadOptionResponse
         * @instance
         */
    FileUploadOptionResponse.prototype.maxConnection = 0;

    /**
         * Creates a new FileUploadOptionResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadOptionResponse
         * @static
         * @param {proto.IFileUploadOptionResponse=} [properties] Properties to set
         * @returns {proto.FileUploadOptionResponse} FileUploadOptionResponse instance
         */
    FileUploadOptionResponse.create = function create(properties) {
      return new FileUploadOptionResponse(properties);
    };

    /**
         * Encodes the specified FileUploadOptionResponse message. Does not implicitly {@link proto.FileUploadOptionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadOptionResponse
         * @static
         * @param {proto.FileUploadOptionResponse} message FileUploadOptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadOptionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.firstBytesLimit != null && message.hasOwnProperty('firstBytesLimit')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.firstBytesLimit);}
      if (message.lastBytesLimit != null && message.hasOwnProperty('lastBytesLimit')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lastBytesLimit);}
      if (message.maxConnection != null && message.hasOwnProperty('maxConnection')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxConnection);}
      return writer;
    };

    /**
         * Decodes a FileUploadOptionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadOptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadOptionResponse} FileUploadOptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadOptionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadOptionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.firstBytesLimit = reader.int32();
            break;
          case 3:
            message.lastBytesLimit = reader.int32();
            break;
          case 4:
            message.maxConnection = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadOptionResponse message.
         * @function verify
         * @memberof proto.FileUploadOptionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadOptionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.firstBytesLimit != null && message.hasOwnProperty('firstBytesLimit')) {
        if (!$util.isInteger(message.firstBytesLimit)) {return 'firstBytesLimit: integer expected';}
      }
      if (message.lastBytesLimit != null && message.hasOwnProperty('lastBytesLimit')) {
        if (!$util.isInteger(message.lastBytesLimit)) {return 'lastBytesLimit: integer expected';}
      }
      if (message.maxConnection != null && message.hasOwnProperty('maxConnection')) {
        if (!$util.isInteger(message.maxConnection)) {return 'maxConnection: integer expected';}
      }
      return null;
    };

    return FileUploadOptionResponse;
  })();

  proto.FileUploadStatus = (function() {

    /**
         * Properties of a FileUploadStatus.
         * @memberof proto
         * @interface IFileUploadStatus
         * @property {proto.Request|null} [request] FileUploadStatus request
         * @property {string|null} [token] FileUploadStatus token
         */

    /**
         * Constructs a new FileUploadStatus.
         * @memberof proto
         * @classdesc Represents a FileUploadStatus.
         * @implements IFileUploadStatus
         * @constructor
         * @param {proto.IFileUploadStatus=} [properties] Properties to set
         */
    function FileUploadStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.FileUploadStatus
         * @instance
         */
    FileUploadStatus.prototype.request = null;

    /**
         * FileUploadStatus token.
         * @member {string} token
         * @memberof proto.FileUploadStatus
         * @instance
         */
    FileUploadStatus.prototype.token = '';

    /**
         * Creates a new FileUploadStatus instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadStatus
         * @static
         * @param {proto.IFileUploadStatus=} [properties] Properties to set
         * @returns {proto.FileUploadStatus} FileUploadStatus instance
         */
    FileUploadStatus.create = function create(properties) {
      return new FileUploadStatus(properties);
    };

    /**
         * Encodes the specified FileUploadStatus message. Does not implicitly {@link proto.FileUploadStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadStatus
         * @static
         * @param {proto.FileUploadStatus} message FileUploadStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a FileUploadStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadStatus} FileUploadStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadStatus message.
         * @function verify
         * @memberof proto.FileUploadStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return FileUploadStatus;
  })();

  proto.FileUploadStatusResponse = (function() {

    /**
         * Properties of a FileUploadStatusResponse.
         * @memberof proto
         * @interface IFileUploadStatusResponse
         * @property {proto.Response|null} [response] FileUploadStatusResponse response
         * @property {proto.FileUploadStatusResponse.Status|null} [status] FileUploadStatusResponse status
         * @property {number|null} [progress] FileUploadStatusResponse progress
         * @property {number|null} [recheckDelayMs] FileUploadStatusResponse recheckDelayMs
         */

    /**
         * Constructs a new FileUploadStatusResponse.
         * @memberof proto
         * @classdesc Represents a FileUploadStatusResponse.
         * @implements IFileUploadStatusResponse
         * @constructor
         * @param {proto.IFileUploadStatusResponse=} [properties] Properties to set
         */
    function FileUploadStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * FileUploadStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.FileUploadStatusResponse
         * @instance
         */
    FileUploadStatusResponse.prototype.response = null;

    /**
         * FileUploadStatusResponse status.
         * @member {proto.FileUploadStatusResponse.Status} status
         * @memberof proto.FileUploadStatusResponse
         * @instance
         */
    FileUploadStatusResponse.prototype.status = 0;

    /**
         * FileUploadStatusResponse progress.
         * @member {number} progress
         * @memberof proto.FileUploadStatusResponse
         * @instance
         */
    FileUploadStatusResponse.prototype.progress = 0;

    /**
         * FileUploadStatusResponse recheckDelayMs.
         * @member {number} recheckDelayMs
         * @memberof proto.FileUploadStatusResponse
         * @instance
         */
    FileUploadStatusResponse.prototype.recheckDelayMs = 0;

    /**
         * Creates a new FileUploadStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileUploadStatusResponse
         * @static
         * @param {proto.IFileUploadStatusResponse=} [properties] Properties to set
         * @returns {proto.FileUploadStatusResponse} FileUploadStatusResponse instance
         */
    FileUploadStatusResponse.create = function create(properties) {
      return new FileUploadStatusResponse(properties);
    };

    /**
         * Encodes the specified FileUploadStatusResponse message. Does not implicitly {@link proto.FileUploadStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUploadStatusResponse
         * @static
         * @param {proto.FileUploadStatusResponse} message FileUploadStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    FileUploadStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      if (message.progress != null && message.hasOwnProperty('progress')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.progress);}
      if (message.recheckDelayMs != null && message.hasOwnProperty('recheckDelayMs')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.recheckDelayMs);}
      return writer;
    };

    /**
         * Decodes a FileUploadStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUploadStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileUploadStatusResponse} FileUploadStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    FileUploadStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileUploadStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          case 3:
            message.progress = reader.double();
            break;
          case 4:
            message.recheckDelayMs = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a FileUploadStatusResponse message.
         * @function verify
         * @memberof proto.FileUploadStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    FileUploadStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.progress != null && message.hasOwnProperty('progress')) {
        if (typeof message.progress !== 'number') {return 'progress: number expected';}
      }
      if (message.recheckDelayMs != null && message.hasOwnProperty('recheckDelayMs')) {
        if (!$util.isInteger(message.recheckDelayMs)) {return 'recheckDelayMs: integer expected';}
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.FileUploadStatusResponse.Status
         * @enum {string}
         * @property {number} UPLOADING=0 UPLOADING value
         * @property {number} PROCESSING=1 PROCESSING value
         * @property {number} PROCESSED=2 PROCESSED value
         * @property {number} CORRUPTED=3 CORRUPTED value
         */
    FileUploadStatusResponse.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'UPLOADING'] = 0;
      values[valuesById[1] = 'PROCESSING'] = 1;
      values[valuesById[2] = 'PROCESSED'] = 2;
      values[valuesById[3] = 'CORRUPTED'] = 3;
      return values;
    })();

    return FileUploadStatusResponse;
  })();

  proto.GeoGetComment = (function() {

    /**
         * Properties of a GeoGetComment.
         * @memberof proto
         * @interface IGeoGetComment
         * @property {proto.Request|null} [request] GeoGetComment request
         * @property {Long|null} [userId] GeoGetComment userId
         */

    /**
         * Constructs a new GeoGetComment.
         * @memberof proto
         * @classdesc Represents a GeoGetComment.
         * @implements IGeoGetComment
         * @constructor
         * @param {proto.IGeoGetComment=} [properties] Properties to set
         */
    function GeoGetComment(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetComment request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoGetComment
         * @instance
         */
    GeoGetComment.prototype.request = null;

    /**
         * GeoGetComment userId.
         * @member {Long} userId
         * @memberof proto.GeoGetComment
         * @instance
         */
    GeoGetComment.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GeoGetComment instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetComment
         * @static
         * @param {proto.IGeoGetComment=} [properties] Properties to set
         * @returns {proto.GeoGetComment} GeoGetComment instance
         */
    GeoGetComment.create = function create(properties) {
      return new GeoGetComment(properties);
    };

    /**
         * Encodes the specified GeoGetComment message. Does not implicitly {@link proto.GeoGetComment.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetComment
         * @static
         * @param {proto.GeoGetComment} message GeoGetComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetComment.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a GeoGetComment message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetComment} GeoGetComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetComment.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetComment();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetComment message.
         * @function verify
         * @memberof proto.GeoGetComment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetComment.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return GeoGetComment;
  })();

  proto.GeoGetCommentResponse = (function() {

    /**
         * Properties of a GeoGetCommentResponse.
         * @memberof proto
         * @interface IGeoGetCommentResponse
         * @property {proto.Response|null} [response] GeoGetCommentResponse response
         * @property {string|null} [comment] GeoGetCommentResponse comment
         */

    /**
         * Constructs a new GeoGetCommentResponse.
         * @memberof proto
         * @classdesc Represents a GeoGetCommentResponse.
         * @implements IGeoGetCommentResponse
         * @constructor
         * @param {proto.IGeoGetCommentResponse=} [properties] Properties to set
         */
    function GeoGetCommentResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetCommentResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoGetCommentResponse
         * @instance
         */
    GeoGetCommentResponse.prototype.response = null;

    /**
         * GeoGetCommentResponse comment.
         * @member {string} comment
         * @memberof proto.GeoGetCommentResponse
         * @instance
         */
    GeoGetCommentResponse.prototype.comment = '';

    /**
         * Creates a new GeoGetCommentResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetCommentResponse
         * @static
         * @param {proto.IGeoGetCommentResponse=} [properties] Properties to set
         * @returns {proto.GeoGetCommentResponse} GeoGetCommentResponse instance
         */
    GeoGetCommentResponse.create = function create(properties) {
      return new GeoGetCommentResponse(properties);
    };

    /**
         * Encodes the specified GeoGetCommentResponse message. Does not implicitly {@link proto.GeoGetCommentResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetCommentResponse
         * @static
         * @param {proto.GeoGetCommentResponse} message GeoGetCommentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetCommentResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.comment != null && message.hasOwnProperty('comment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.comment);}
      return writer;
    };

    /**
         * Decodes a GeoGetCommentResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetCommentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetCommentResponse} GeoGetCommentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetCommentResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetCommentResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.comment = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetCommentResponse message.
         * @function verify
         * @memberof proto.GeoGetCommentResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetCommentResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.comment != null && message.hasOwnProperty('comment')) {
        if (!$util.isString(message.comment)) {return 'comment: string expected';}
      }
      return null;
    };

    return GeoGetCommentResponse;
  })();

  proto.GeoGetConfiguration = (function() {

    /**
         * Properties of a GeoGetConfiguration.
         * @memberof proto
         * @interface IGeoGetConfiguration
         * @property {proto.Request|null} [request] GeoGetConfiguration request
         */

    /**
         * Constructs a new GeoGetConfiguration.
         * @memberof proto
         * @classdesc Represents a GeoGetConfiguration.
         * @implements IGeoGetConfiguration
         * @constructor
         * @param {proto.IGeoGetConfiguration=} [properties] Properties to set
         */
    function GeoGetConfiguration(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetConfiguration request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoGetConfiguration
         * @instance
         */
    GeoGetConfiguration.prototype.request = null;

    /**
         * Creates a new GeoGetConfiguration instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetConfiguration
         * @static
         * @param {proto.IGeoGetConfiguration=} [properties] Properties to set
         * @returns {proto.GeoGetConfiguration} GeoGetConfiguration instance
         */
    GeoGetConfiguration.create = function create(properties) {
      return new GeoGetConfiguration(properties);
    };

    /**
         * Encodes the specified GeoGetConfiguration message. Does not implicitly {@link proto.GeoGetConfiguration.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetConfiguration
         * @static
         * @param {proto.GeoGetConfiguration} message GeoGetConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetConfiguration.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GeoGetConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetConfiguration} GeoGetConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetConfiguration.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetConfiguration();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetConfiguration message.
         * @function verify
         * @memberof proto.GeoGetConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetConfiguration.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return GeoGetConfiguration;
  })();

  proto.GeoGetConfigurationResponse = (function() {

    /**
         * Properties of a GeoGetConfigurationResponse.
         * @memberof proto
         * @interface IGeoGetConfigurationResponse
         * @property {proto.Response|null} [response] GeoGetConfigurationResponse response
         * @property {Array.<proto.GeoGetConfigurationResponse.TileServer>|null} [tileServer] GeoGetConfigurationResponse tileServer
         * @property {string|null} [cacheId] GeoGetConfigurationResponse cacheId
         */

    /**
         * Constructs a new GeoGetConfigurationResponse.
         * @memberof proto
         * @classdesc Represents a GeoGetConfigurationResponse.
         * @implements IGeoGetConfigurationResponse
         * @constructor
         * @param {proto.IGeoGetConfigurationResponse=} [properties] Properties to set
         */
    function GeoGetConfigurationResponse(properties) {
      this.tileServer = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetConfigurationResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoGetConfigurationResponse
         * @instance
         */
    GeoGetConfigurationResponse.prototype.response = null;

    /**
         * GeoGetConfigurationResponse tileServer.
         * @member {Array.<proto.GeoGetConfigurationResponse.TileServer>} tileServer
         * @memberof proto.GeoGetConfigurationResponse
         * @instance
         */
    GeoGetConfigurationResponse.prototype.tileServer = $util.emptyArray;

    /**
         * GeoGetConfigurationResponse cacheId.
         * @member {string} cacheId
         * @memberof proto.GeoGetConfigurationResponse
         * @instance
         */
    GeoGetConfigurationResponse.prototype.cacheId = '';

    /**
         * Creates a new GeoGetConfigurationResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetConfigurationResponse
         * @static
         * @param {proto.IGeoGetConfigurationResponse=} [properties] Properties to set
         * @returns {proto.GeoGetConfigurationResponse} GeoGetConfigurationResponse instance
         */
    GeoGetConfigurationResponse.create = function create(properties) {
      return new GeoGetConfigurationResponse(properties);
    };

    /**
         * Encodes the specified GeoGetConfigurationResponse message. Does not implicitly {@link proto.GeoGetConfigurationResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetConfigurationResponse
         * @static
         * @param {proto.GeoGetConfigurationResponse} message GeoGetConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetConfigurationResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.tileServer != null && message.tileServer.length) {
        for (let i = 0; i < message.tileServer.length; ++i) {$root.proto.GeoGetConfigurationResponse.TileServer.encode(message.tileServer[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.cacheId);}
      return writer;
    };

    /**
         * Decodes a GeoGetConfigurationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetConfigurationResponse} GeoGetConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetConfigurationResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetConfigurationResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.tileServer && message.tileServer.length)) {message.tileServer = [];}
            message.tileServer.push($root.proto.GeoGetConfigurationResponse.TileServer.decode(reader, reader.uint32()));
            break;
          case 3:
            message.cacheId = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetConfigurationResponse message.
         * @function verify
         * @memberof proto.GeoGetConfigurationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetConfigurationResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.tileServer != null && message.hasOwnProperty('tileServer')) {
        if (!Array.isArray(message.tileServer)) {return 'tileServer: array expected';}
        for (let i = 0; i < message.tileServer.length; ++i) {
          let error = $root.proto.GeoGetConfigurationResponse.TileServer.verify(message.tileServer[i]);
          if (error) {return 'tileServer.' + error;}
        }
      }
      if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
        if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
      }
      return null;
    };

    GeoGetConfigurationResponse.TileServer = (function() {

      /**
             * Properties of a TileServer.
             * @memberof proto.GeoGetConfigurationResponse
             * @interface ITileServer
             * @property {string|null} [baseUrl] TileServer baseUrl
             */

      /**
             * Constructs a new TileServer.
             * @memberof proto.GeoGetConfigurationResponse
             * @classdesc Represents a TileServer.
             * @implements ITileServer
             * @constructor
             * @param {proto.GeoGetConfigurationResponse.ITileServer=} [properties] Properties to set
             */
      function TileServer(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * TileServer baseUrl.
             * @member {string} baseUrl
             * @memberof proto.GeoGetConfigurationResponse.TileServer
             * @instance
             */
      TileServer.prototype.baseUrl = '';

      /**
             * Creates a new TileServer instance using the specified properties.
             * @function create
             * @memberof proto.GeoGetConfigurationResponse.TileServer
             * @static
             * @param {proto.GeoGetConfigurationResponse.ITileServer=} [properties] Properties to set
             * @returns {proto.GeoGetConfigurationResponse.TileServer} TileServer instance
             */
      TileServer.create = function create(properties) {
        return new TileServer(properties);
      };

      /**
             * Encodes the specified TileServer message. Does not implicitly {@link proto.GeoGetConfigurationResponse.TileServer.verify|verify} messages.
             * @function encode
             * @memberof proto.GeoGetConfigurationResponse.TileServer
             * @static
             * @param {proto.GeoGetConfigurationResponse.TileServer} message TileServer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      TileServer.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.baseUrl != null && message.hasOwnProperty('baseUrl')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.baseUrl);}
        return writer;
      };

      /**
             * Decodes a TileServer message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GeoGetConfigurationResponse.TileServer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GeoGetConfigurationResponse.TileServer} TileServer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      TileServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetConfigurationResponse.TileServer();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a TileServer message.
             * @function verify
             * @memberof proto.GeoGetConfigurationResponse.TileServer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      TileServer.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.baseUrl != null && message.hasOwnProperty('baseUrl')) {
          if (!$util.isString(message.baseUrl)) {return 'baseUrl: string expected';}
        }
        return null;
      };

      return TileServer;
    })();

    return GeoGetConfigurationResponse;
  })();

  proto.GeoGetNearbyCoordinate = (function() {

    /**
         * Properties of a GeoGetNearbyCoordinate.
         * @memberof proto
         * @interface IGeoGetNearbyCoordinate
         * @property {proto.Request|null} [request] GeoGetNearbyCoordinate request
         * @property {number|null} [lat] GeoGetNearbyCoordinate lat
         * @property {number|null} [lon] GeoGetNearbyCoordinate lon
         */

    /**
         * Constructs a new GeoGetNearbyCoordinate.
         * @memberof proto
         * @classdesc Represents a GeoGetNearbyCoordinate.
         * @implements IGeoGetNearbyCoordinate
         * @constructor
         * @param {proto.IGeoGetNearbyCoordinate=} [properties] Properties to set
         */
    function GeoGetNearbyCoordinate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetNearbyCoordinate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoGetNearbyCoordinate
         * @instance
         */
    GeoGetNearbyCoordinate.prototype.request = null;

    /**
         * GeoGetNearbyCoordinate lat.
         * @member {number} lat
         * @memberof proto.GeoGetNearbyCoordinate
         * @instance
         */
    GeoGetNearbyCoordinate.prototype.lat = 0;

    /**
         * GeoGetNearbyCoordinate lon.
         * @member {number} lon
         * @memberof proto.GeoGetNearbyCoordinate
         * @instance
         */
    GeoGetNearbyCoordinate.prototype.lon = 0;

    /**
         * Creates a new GeoGetNearbyCoordinate instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetNearbyCoordinate
         * @static
         * @param {proto.IGeoGetNearbyCoordinate=} [properties] Properties to set
         * @returns {proto.GeoGetNearbyCoordinate} GeoGetNearbyCoordinate instance
         */
    GeoGetNearbyCoordinate.create = function create(properties) {
      return new GeoGetNearbyCoordinate(properties);
    };

    /**
         * Encodes the specified GeoGetNearbyCoordinate message. Does not implicitly {@link proto.GeoGetNearbyCoordinate.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetNearbyCoordinate
         * @static
         * @param {proto.GeoGetNearbyCoordinate} message GeoGetNearbyCoordinate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetNearbyCoordinate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.lat != null && message.hasOwnProperty('lat')) {writer.uint32(/* id 2, wireType 1 =*/17).double(message.lat);}
      if (message.lon != null && message.hasOwnProperty('lon')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.lon);}
      return writer;
    };

    /**
         * Decodes a GeoGetNearbyCoordinate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetNearbyCoordinate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetNearbyCoordinate} GeoGetNearbyCoordinate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetNearbyCoordinate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyCoordinate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.lat = reader.double();
            break;
          case 3:
            message.lon = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetNearbyCoordinate message.
         * @function verify
         * @memberof proto.GeoGetNearbyCoordinate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetNearbyCoordinate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.lat != null && message.hasOwnProperty('lat')) {
        if (typeof message.lat !== 'number') {return 'lat: number expected';}
      }
      if (message.lon != null && message.hasOwnProperty('lon')) {
        if (typeof message.lon !== 'number') {return 'lon: number expected';}
      }
      return null;
    };

    return GeoGetNearbyCoordinate;
  })();

  proto.GeoGetNearbyCoordinateResponse = (function() {

    /**
         * Properties of a GeoGetNearbyCoordinateResponse.
         * @memberof proto
         * @interface IGeoGetNearbyCoordinateResponse
         * @property {proto.Response|null} [response] GeoGetNearbyCoordinateResponse response
         * @property {Array.<proto.GeoGetNearbyCoordinateResponse.Result>|null} [result] GeoGetNearbyCoordinateResponse result
         */

    /**
         * Constructs a new GeoGetNearbyCoordinateResponse.
         * @memberof proto
         * @classdesc Represents a GeoGetNearbyCoordinateResponse.
         * @implements IGeoGetNearbyCoordinateResponse
         * @constructor
         * @param {proto.IGeoGetNearbyCoordinateResponse=} [properties] Properties to set
         */
    function GeoGetNearbyCoordinateResponse(properties) {
      this.result = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetNearbyCoordinateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @instance
         */
    GeoGetNearbyCoordinateResponse.prototype.response = null;

    /**
         * GeoGetNearbyCoordinateResponse result.
         * @member {Array.<proto.GeoGetNearbyCoordinateResponse.Result>} result
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @instance
         */
    GeoGetNearbyCoordinateResponse.prototype.result = $util.emptyArray;

    /**
         * Creates a new GeoGetNearbyCoordinateResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @static
         * @param {proto.IGeoGetNearbyCoordinateResponse=} [properties] Properties to set
         * @returns {proto.GeoGetNearbyCoordinateResponse} GeoGetNearbyCoordinateResponse instance
         */
    GeoGetNearbyCoordinateResponse.create = function create(properties) {
      return new GeoGetNearbyCoordinateResponse(properties);
    };

    /**
         * Encodes the specified GeoGetNearbyCoordinateResponse message. Does not implicitly {@link proto.GeoGetNearbyCoordinateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @static
         * @param {proto.GeoGetNearbyCoordinateResponse} message GeoGetNearbyCoordinateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetNearbyCoordinateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.result != null && message.result.length) {
        for (let i = 0; i < message.result.length; ++i) {$root.proto.GeoGetNearbyCoordinateResponse.Result.encode(message.result[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a GeoGetNearbyCoordinateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetNearbyCoordinateResponse} GeoGetNearbyCoordinateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetNearbyCoordinateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyCoordinateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.result && message.result.length)) {message.result = [];}
            message.result.push($root.proto.GeoGetNearbyCoordinateResponse.Result.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetNearbyCoordinateResponse message.
         * @function verify
         * @memberof proto.GeoGetNearbyCoordinateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetNearbyCoordinateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.result != null && message.hasOwnProperty('result')) {
        if (!Array.isArray(message.result)) {return 'result: array expected';}
        for (let i = 0; i < message.result.length; ++i) {
          let error = $root.proto.GeoGetNearbyCoordinateResponse.Result.verify(message.result[i]);
          if (error) {return 'result.' + error;}
        }
      }
      return null;
    };

    GeoGetNearbyCoordinateResponse.Result = (function() {

      /**
             * Properties of a Result.
             * @memberof proto.GeoGetNearbyCoordinateResponse
             * @interface IResult
             * @property {Long|null} [userId] Result userId
             * @property {boolean|null} [hasComment] Result hasComment
             * @property {number|null} [lat] Result lat
             * @property {number|null} [lon] Result lon
             */

      /**
             * Constructs a new Result.
             * @memberof proto.GeoGetNearbyCoordinateResponse
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {proto.GeoGetNearbyCoordinateResponse.IResult=} [properties] Properties to set
             */
      function Result(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Result userId.
             * @member {Long} userId
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @instance
             */
      Result.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Result hasComment.
             * @member {boolean} hasComment
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @instance
             */
      Result.prototype.hasComment = false;

      /**
             * Result lat.
             * @member {number} lat
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @instance
             */
      Result.prototype.lat = 0;

      /**
             * Result lon.
             * @member {number} lon
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @instance
             */
      Result.prototype.lon = 0;

      /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @static
             * @param {proto.GeoGetNearbyCoordinateResponse.IResult=} [properties] Properties to set
             * @returns {proto.GeoGetNearbyCoordinateResponse.Result} Result instance
             */
      Result.create = function create(properties) {
        return new Result(properties);
      };

      /**
             * Encodes the specified Result message. Does not implicitly {@link proto.GeoGetNearbyCoordinateResponse.Result.verify|verify} messages.
             * @function encode
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @static
             * @param {proto.GeoGetNearbyCoordinateResponse.Result} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Result.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.hasComment != null && message.hasOwnProperty('hasComment')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasComment);}
        if (message.lat != null && message.hasOwnProperty('lat')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.lat);}
        if (message.lon != null && message.hasOwnProperty('lon')) {writer.uint32(/* id 4, wireType 1 =*/33).double(message.lon);}
        return writer;
      };

      /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GeoGetNearbyCoordinateResponse.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Result.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyCoordinateResponse.Result();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.hasComment = reader.bool();
              break;
            case 3:
              message.lat = reader.double();
              break;
            case 4:
              message.lon = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Result message.
             * @function verify
             * @memberof proto.GeoGetNearbyCoordinateResponse.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Result.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.hasComment != null && message.hasOwnProperty('hasComment')) {
          if (typeof message.hasComment !== 'boolean') {return 'hasComment: boolean expected';}
        }
        if (message.lat != null && message.hasOwnProperty('lat')) {
          if (typeof message.lat !== 'number') {return 'lat: number expected';}
        }
        if (message.lon != null && message.hasOwnProperty('lon')) {
          if (typeof message.lon !== 'number') {return 'lon: number expected';}
        }
        return null;
      };

      return Result;
    })();

    return GeoGetNearbyCoordinateResponse;
  })();

  proto.GeoGetNearbyDistance = (function() {

    /**
         * Properties of a GeoGetNearbyDistance.
         * @memberof proto
         * @interface IGeoGetNearbyDistance
         * @property {proto.Request|null} [request] GeoGetNearbyDistance request
         * @property {number|null} [lat] GeoGetNearbyDistance lat
         * @property {number|null} [lon] GeoGetNearbyDistance lon
         */

    /**
         * Constructs a new GeoGetNearbyDistance.
         * @memberof proto
         * @classdesc Represents a GeoGetNearbyDistance.
         * @implements IGeoGetNearbyDistance
         * @constructor
         * @param {proto.IGeoGetNearbyDistance=} [properties] Properties to set
         */
    function GeoGetNearbyDistance(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetNearbyDistance request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoGetNearbyDistance
         * @instance
         */
    GeoGetNearbyDistance.prototype.request = null;

    /**
         * GeoGetNearbyDistance lat.
         * @member {number} lat
         * @memberof proto.GeoGetNearbyDistance
         * @instance
         */
    GeoGetNearbyDistance.prototype.lat = 0;

    /**
         * GeoGetNearbyDistance lon.
         * @member {number} lon
         * @memberof proto.GeoGetNearbyDistance
         * @instance
         */
    GeoGetNearbyDistance.prototype.lon = 0;

    /**
         * Creates a new GeoGetNearbyDistance instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetNearbyDistance
         * @static
         * @param {proto.IGeoGetNearbyDistance=} [properties] Properties to set
         * @returns {proto.GeoGetNearbyDistance} GeoGetNearbyDistance instance
         */
    GeoGetNearbyDistance.create = function create(properties) {
      return new GeoGetNearbyDistance(properties);
    };

    /**
         * Encodes the specified GeoGetNearbyDistance message. Does not implicitly {@link proto.GeoGetNearbyDistance.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetNearbyDistance
         * @static
         * @param {proto.GeoGetNearbyDistance} message GeoGetNearbyDistance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetNearbyDistance.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.lat != null && message.hasOwnProperty('lat')) {writer.uint32(/* id 2, wireType 1 =*/17).double(message.lat);}
      if (message.lon != null && message.hasOwnProperty('lon')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.lon);}
      return writer;
    };

    /**
         * Decodes a GeoGetNearbyDistance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetNearbyDistance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetNearbyDistance} GeoGetNearbyDistance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetNearbyDistance.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyDistance();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.lat = reader.double();
            break;
          case 3:
            message.lon = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetNearbyDistance message.
         * @function verify
         * @memberof proto.GeoGetNearbyDistance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetNearbyDistance.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.lat != null && message.hasOwnProperty('lat')) {
        if (typeof message.lat !== 'number') {return 'lat: number expected';}
      }
      if (message.lon != null && message.hasOwnProperty('lon')) {
        if (typeof message.lon !== 'number') {return 'lon: number expected';}
      }
      return null;
    };

    return GeoGetNearbyDistance;
  })();

  proto.GeoGetNearbyDistanceResponse = (function() {

    /**
         * Properties of a GeoGetNearbyDistanceResponse.
         * @memberof proto
         * @interface IGeoGetNearbyDistanceResponse
         * @property {proto.Response|null} [response] GeoGetNearbyDistanceResponse response
         * @property {Array.<proto.GeoGetNearbyDistanceResponse.Result>|null} [result] GeoGetNearbyDistanceResponse result
         */

    /**
         * Constructs a new GeoGetNearbyDistanceResponse.
         * @memberof proto
         * @classdesc Represents a GeoGetNearbyDistanceResponse.
         * @implements IGeoGetNearbyDistanceResponse
         * @constructor
         * @param {proto.IGeoGetNearbyDistanceResponse=} [properties] Properties to set
         */
    function GeoGetNearbyDistanceResponse(properties) {
      this.result = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetNearbyDistanceResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @instance
         */
    GeoGetNearbyDistanceResponse.prototype.response = null;

    /**
         * GeoGetNearbyDistanceResponse result.
         * @member {Array.<proto.GeoGetNearbyDistanceResponse.Result>} result
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @instance
         */
    GeoGetNearbyDistanceResponse.prototype.result = $util.emptyArray;

    /**
         * Creates a new GeoGetNearbyDistanceResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @static
         * @param {proto.IGeoGetNearbyDistanceResponse=} [properties] Properties to set
         * @returns {proto.GeoGetNearbyDistanceResponse} GeoGetNearbyDistanceResponse instance
         */
    GeoGetNearbyDistanceResponse.create = function create(properties) {
      return new GeoGetNearbyDistanceResponse(properties);
    };

    /**
         * Encodes the specified GeoGetNearbyDistanceResponse message. Does not implicitly {@link proto.GeoGetNearbyDistanceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @static
         * @param {proto.GeoGetNearbyDistanceResponse} message GeoGetNearbyDistanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetNearbyDistanceResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.result != null && message.result.length) {
        for (let i = 0; i < message.result.length; ++i) {$root.proto.GeoGetNearbyDistanceResponse.Result.encode(message.result[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a GeoGetNearbyDistanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetNearbyDistanceResponse} GeoGetNearbyDistanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetNearbyDistanceResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyDistanceResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.result && message.result.length)) {message.result = [];}
            message.result.push($root.proto.GeoGetNearbyDistanceResponse.Result.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetNearbyDistanceResponse message.
         * @function verify
         * @memberof proto.GeoGetNearbyDistanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetNearbyDistanceResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.result != null && message.hasOwnProperty('result')) {
        if (!Array.isArray(message.result)) {return 'result: array expected';}
        for (let i = 0; i < message.result.length; ++i) {
          let error = $root.proto.GeoGetNearbyDistanceResponse.Result.verify(message.result[i]);
          if (error) {return 'result.' + error;}
        }
      }
      return null;
    };

    GeoGetNearbyDistanceResponse.Result = (function() {

      /**
             * Properties of a Result.
             * @memberof proto.GeoGetNearbyDistanceResponse
             * @interface IResult
             * @property {Long|null} [userId] Result userId
             * @property {boolean|null} [hasComment] Result hasComment
             * @property {number|null} [distance] Result distance
             */

      /**
             * Constructs a new Result.
             * @memberof proto.GeoGetNearbyDistanceResponse
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {proto.GeoGetNearbyDistanceResponse.IResult=} [properties] Properties to set
             */
      function Result(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Result userId.
             * @member {Long} userId
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @instance
             */
      Result.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Result hasComment.
             * @member {boolean} hasComment
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @instance
             */
      Result.prototype.hasComment = false;

      /**
             * Result distance.
             * @member {number} distance
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @instance
             */
      Result.prototype.distance = 0;

      /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @static
             * @param {proto.GeoGetNearbyDistanceResponse.IResult=} [properties] Properties to set
             * @returns {proto.GeoGetNearbyDistanceResponse.Result} Result instance
             */
      Result.create = function create(properties) {
        return new Result(properties);
      };

      /**
             * Encodes the specified Result message. Does not implicitly {@link proto.GeoGetNearbyDistanceResponse.Result.verify|verify} messages.
             * @function encode
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @static
             * @param {proto.GeoGetNearbyDistanceResponse.Result} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Result.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.hasComment != null && message.hasOwnProperty('hasComment')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasComment);}
        if (message.distance != null && message.hasOwnProperty('distance')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.distance);}
        return writer;
      };

      /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GeoGetNearbyDistanceResponse.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Result.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetNearbyDistanceResponse.Result();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.hasComment = reader.bool();
              break;
            case 3:
              message.distance = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Result message.
             * @function verify
             * @memberof proto.GeoGetNearbyDistanceResponse.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Result.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.hasComment != null && message.hasOwnProperty('hasComment')) {
          if (typeof message.hasComment !== 'boolean') {return 'hasComment: boolean expected';}
        }
        if (message.distance != null && message.hasOwnProperty('distance')) {
          if (!$util.isInteger(message.distance)) {return 'distance: integer expected';}
        }
        return null;
      };

      return Result;
    })();

    return GeoGetNearbyDistanceResponse;
  })();

  proto.GeoGetRegisterStatus = (function() {

    /**
         * Properties of a GeoGetRegisterStatus.
         * @memberof proto
         * @interface IGeoGetRegisterStatus
         * @property {proto.Request|null} [request] GeoGetRegisterStatus request
         */

    /**
         * Constructs a new GeoGetRegisterStatus.
         * @memberof proto
         * @classdesc Represents a GeoGetRegisterStatus.
         * @implements IGeoGetRegisterStatus
         * @constructor
         * @param {proto.IGeoGetRegisterStatus=} [properties] Properties to set
         */
    function GeoGetRegisterStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetRegisterStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoGetRegisterStatus
         * @instance
         */
    GeoGetRegisterStatus.prototype.request = null;

    /**
         * Creates a new GeoGetRegisterStatus instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetRegisterStatus
         * @static
         * @param {proto.IGeoGetRegisterStatus=} [properties] Properties to set
         * @returns {proto.GeoGetRegisterStatus} GeoGetRegisterStatus instance
         */
    GeoGetRegisterStatus.create = function create(properties) {
      return new GeoGetRegisterStatus(properties);
    };

    /**
         * Encodes the specified GeoGetRegisterStatus message. Does not implicitly {@link proto.GeoGetRegisterStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetRegisterStatus
         * @static
         * @param {proto.GeoGetRegisterStatus} message GeoGetRegisterStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetRegisterStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GeoGetRegisterStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetRegisterStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetRegisterStatus} GeoGetRegisterStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetRegisterStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetRegisterStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetRegisterStatus message.
         * @function verify
         * @memberof proto.GeoGetRegisterStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetRegisterStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return GeoGetRegisterStatus;
  })();

  proto.GeoGetRegisterStatusResponse = (function() {

    /**
         * Properties of a GeoGetRegisterStatusResponse.
         * @memberof proto
         * @interface IGeoGetRegisterStatusResponse
         * @property {proto.Response|null} [response] GeoGetRegisterStatusResponse response
         * @property {boolean|null} [enable] GeoGetRegisterStatusResponse enable
         */

    /**
         * Constructs a new GeoGetRegisterStatusResponse.
         * @memberof proto
         * @classdesc Represents a GeoGetRegisterStatusResponse.
         * @implements IGeoGetRegisterStatusResponse
         * @constructor
         * @param {proto.IGeoGetRegisterStatusResponse=} [properties] Properties to set
         */
    function GeoGetRegisterStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoGetRegisterStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoGetRegisterStatusResponse
         * @instance
         */
    GeoGetRegisterStatusResponse.prototype.response = null;

    /**
         * GeoGetRegisterStatusResponse enable.
         * @member {boolean} enable
         * @memberof proto.GeoGetRegisterStatusResponse
         * @instance
         */
    GeoGetRegisterStatusResponse.prototype.enable = false;

    /**
         * Creates a new GeoGetRegisterStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoGetRegisterStatusResponse
         * @static
         * @param {proto.IGeoGetRegisterStatusResponse=} [properties] Properties to set
         * @returns {proto.GeoGetRegisterStatusResponse} GeoGetRegisterStatusResponse instance
         */
    GeoGetRegisterStatusResponse.create = function create(properties) {
      return new GeoGetRegisterStatusResponse(properties);
    };

    /**
         * Encodes the specified GeoGetRegisterStatusResponse message. Does not implicitly {@link proto.GeoGetRegisterStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoGetRegisterStatusResponse
         * @static
         * @param {proto.GeoGetRegisterStatusResponse} message GeoGetRegisterStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoGetRegisterStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.enable != null && message.hasOwnProperty('enable')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enable);}
      return writer;
    };

    /**
         * Decodes a GeoGetRegisterStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoGetRegisterStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoGetRegisterStatusResponse} GeoGetRegisterStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoGetRegisterStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoGetRegisterStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.enable = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoGetRegisterStatusResponse message.
         * @function verify
         * @memberof proto.GeoGetRegisterStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoGetRegisterStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.enable != null && message.hasOwnProperty('enable')) {
        if (typeof message.enable !== 'boolean') {return 'enable: boolean expected';}
      }
      return null;
    };

    return GeoGetRegisterStatusResponse;
  })();

  proto.GeoRegister = (function() {

    /**
         * Properties of a GeoRegister.
         * @memberof proto
         * @interface IGeoRegister
         * @property {proto.Request|null} [request] GeoRegister request
         * @property {boolean|null} [enable] GeoRegister enable
         */

    /**
         * Constructs a new GeoRegister.
         * @memberof proto
         * @classdesc Represents a GeoRegister.
         * @implements IGeoRegister
         * @constructor
         * @param {proto.IGeoRegister=} [properties] Properties to set
         */
    function GeoRegister(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoRegister request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoRegister
         * @instance
         */
    GeoRegister.prototype.request = null;

    /**
         * GeoRegister enable.
         * @member {boolean} enable
         * @memberof proto.GeoRegister
         * @instance
         */
    GeoRegister.prototype.enable = false;

    /**
         * Creates a new GeoRegister instance using the specified properties.
         * @function create
         * @memberof proto.GeoRegister
         * @static
         * @param {proto.IGeoRegister=} [properties] Properties to set
         * @returns {proto.GeoRegister} GeoRegister instance
         */
    GeoRegister.create = function create(properties) {
      return new GeoRegister(properties);
    };

    /**
         * Encodes the specified GeoRegister message. Does not implicitly {@link proto.GeoRegister.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoRegister
         * @static
         * @param {proto.GeoRegister} message GeoRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoRegister.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.enable != null && message.hasOwnProperty('enable')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enable);}
      return writer;
    };

    /**
         * Decodes a GeoRegister message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoRegister} GeoRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoRegister.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoRegister();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.enable = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoRegister message.
         * @function verify
         * @memberof proto.GeoRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoRegister.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.enable != null && message.hasOwnProperty('enable')) {
        if (typeof message.enable !== 'boolean') {return 'enable: boolean expected';}
      }
      return null;
    };

    return GeoRegister;
  })();

  proto.GeoRegisterResponse = (function() {

    /**
         * Properties of a GeoRegisterResponse.
         * @memberof proto
         * @interface IGeoRegisterResponse
         * @property {proto.Response|null} [response] GeoRegisterResponse response
         * @property {boolean|null} [enable] GeoRegisterResponse enable
         */

    /**
         * Constructs a new GeoRegisterResponse.
         * @memberof proto
         * @classdesc Represents a GeoRegisterResponse.
         * @implements IGeoRegisterResponse
         * @constructor
         * @param {proto.IGeoRegisterResponse=} [properties] Properties to set
         */
    function GeoRegisterResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoRegisterResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoRegisterResponse
         * @instance
         */
    GeoRegisterResponse.prototype.response = null;

    /**
         * GeoRegisterResponse enable.
         * @member {boolean} enable
         * @memberof proto.GeoRegisterResponse
         * @instance
         */
    GeoRegisterResponse.prototype.enable = false;

    /**
         * Creates a new GeoRegisterResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoRegisterResponse
         * @static
         * @param {proto.IGeoRegisterResponse=} [properties] Properties to set
         * @returns {proto.GeoRegisterResponse} GeoRegisterResponse instance
         */
    GeoRegisterResponse.create = function create(properties) {
      return new GeoRegisterResponse(properties);
    };

    /**
         * Encodes the specified GeoRegisterResponse message. Does not implicitly {@link proto.GeoRegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoRegisterResponse
         * @static
         * @param {proto.GeoRegisterResponse} message GeoRegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoRegisterResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.enable != null && message.hasOwnProperty('enable')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enable);}
      return writer;
    };

    /**
         * Decodes a GeoRegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoRegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoRegisterResponse} GeoRegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoRegisterResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoRegisterResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.enable = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoRegisterResponse message.
         * @function verify
         * @memberof proto.GeoRegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoRegisterResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.enable != null && message.hasOwnProperty('enable')) {
        if (typeof message.enable !== 'boolean') {return 'enable: boolean expected';}
      }
      return null;
    };

    return GeoRegisterResponse;
  })();

  proto.GeoUpdateComment = (function() {

    /**
         * Properties of a GeoUpdateComment.
         * @memberof proto
         * @interface IGeoUpdateComment
         * @property {proto.Request|null} [request] GeoUpdateComment request
         * @property {string|null} [comment] GeoUpdateComment comment
         */

    /**
         * Constructs a new GeoUpdateComment.
         * @memberof proto
         * @classdesc Represents a GeoUpdateComment.
         * @implements IGeoUpdateComment
         * @constructor
         * @param {proto.IGeoUpdateComment=} [properties] Properties to set
         */
    function GeoUpdateComment(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoUpdateComment request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoUpdateComment
         * @instance
         */
    GeoUpdateComment.prototype.request = null;

    /**
         * GeoUpdateComment comment.
         * @member {string} comment
         * @memberof proto.GeoUpdateComment
         * @instance
         */
    GeoUpdateComment.prototype.comment = '';

    /**
         * Creates a new GeoUpdateComment instance using the specified properties.
         * @function create
         * @memberof proto.GeoUpdateComment
         * @static
         * @param {proto.IGeoUpdateComment=} [properties] Properties to set
         * @returns {proto.GeoUpdateComment} GeoUpdateComment instance
         */
    GeoUpdateComment.create = function create(properties) {
      return new GeoUpdateComment(properties);
    };

    /**
         * Encodes the specified GeoUpdateComment message. Does not implicitly {@link proto.GeoUpdateComment.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoUpdateComment
         * @static
         * @param {proto.GeoUpdateComment} message GeoUpdateComment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoUpdateComment.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.comment != null && message.hasOwnProperty('comment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.comment);}
      return writer;
    };

    /**
         * Decodes a GeoUpdateComment message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoUpdateComment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoUpdateComment} GeoUpdateComment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoUpdateComment.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoUpdateComment();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.comment = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoUpdateComment message.
         * @function verify
         * @memberof proto.GeoUpdateComment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoUpdateComment.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.comment != null && message.hasOwnProperty('comment')) {
        if (!$util.isString(message.comment)) {return 'comment: string expected';}
      }
      return null;
    };

    return GeoUpdateComment;
  })();

  proto.GeoUpdateCommentResponse = (function() {

    /**
         * Properties of a GeoUpdateCommentResponse.
         * @memberof proto
         * @interface IGeoUpdateCommentResponse
         * @property {proto.Response|null} [response] GeoUpdateCommentResponse response
         * @property {string|null} [comment] GeoUpdateCommentResponse comment
         */

    /**
         * Constructs a new GeoUpdateCommentResponse.
         * @memberof proto
         * @classdesc Represents a GeoUpdateCommentResponse.
         * @implements IGeoUpdateCommentResponse
         * @constructor
         * @param {proto.IGeoUpdateCommentResponse=} [properties] Properties to set
         */
    function GeoUpdateCommentResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoUpdateCommentResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoUpdateCommentResponse
         * @instance
         */
    GeoUpdateCommentResponse.prototype.response = null;

    /**
         * GeoUpdateCommentResponse comment.
         * @member {string} comment
         * @memberof proto.GeoUpdateCommentResponse
         * @instance
         */
    GeoUpdateCommentResponse.prototype.comment = '';

    /**
         * Creates a new GeoUpdateCommentResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoUpdateCommentResponse
         * @static
         * @param {proto.IGeoUpdateCommentResponse=} [properties] Properties to set
         * @returns {proto.GeoUpdateCommentResponse} GeoUpdateCommentResponse instance
         */
    GeoUpdateCommentResponse.create = function create(properties) {
      return new GeoUpdateCommentResponse(properties);
    };

    /**
         * Encodes the specified GeoUpdateCommentResponse message. Does not implicitly {@link proto.GeoUpdateCommentResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoUpdateCommentResponse
         * @static
         * @param {proto.GeoUpdateCommentResponse} message GeoUpdateCommentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoUpdateCommentResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.comment != null && message.hasOwnProperty('comment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.comment);}
      return writer;
    };

    /**
         * Decodes a GeoUpdateCommentResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoUpdateCommentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoUpdateCommentResponse} GeoUpdateCommentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoUpdateCommentResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoUpdateCommentResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.comment = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoUpdateCommentResponse message.
         * @function verify
         * @memberof proto.GeoUpdateCommentResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoUpdateCommentResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.comment != null && message.hasOwnProperty('comment')) {
        if (!$util.isString(message.comment)) {return 'comment: string expected';}
      }
      return null;
    };

    return GeoUpdateCommentResponse;
  })();

  proto.GeoUpdatePosition = (function() {

    /**
         * Properties of a GeoUpdatePosition.
         * @memberof proto
         * @interface IGeoUpdatePosition
         * @property {proto.Request|null} [request] GeoUpdatePosition request
         * @property {number|null} [lat] GeoUpdatePosition lat
         * @property {number|null} [lon] GeoUpdatePosition lon
         */

    /**
         * Constructs a new GeoUpdatePosition.
         * @memberof proto
         * @classdesc Represents a GeoUpdatePosition.
         * @implements IGeoUpdatePosition
         * @constructor
         * @param {proto.IGeoUpdatePosition=} [properties] Properties to set
         */
    function GeoUpdatePosition(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoUpdatePosition request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GeoUpdatePosition
         * @instance
         */
    GeoUpdatePosition.prototype.request = null;

    /**
         * GeoUpdatePosition lat.
         * @member {number} lat
         * @memberof proto.GeoUpdatePosition
         * @instance
         */
    GeoUpdatePosition.prototype.lat = 0;

    /**
         * GeoUpdatePosition lon.
         * @member {number} lon
         * @memberof proto.GeoUpdatePosition
         * @instance
         */
    GeoUpdatePosition.prototype.lon = 0;

    /**
         * Creates a new GeoUpdatePosition instance using the specified properties.
         * @function create
         * @memberof proto.GeoUpdatePosition
         * @static
         * @param {proto.IGeoUpdatePosition=} [properties] Properties to set
         * @returns {proto.GeoUpdatePosition} GeoUpdatePosition instance
         */
    GeoUpdatePosition.create = function create(properties) {
      return new GeoUpdatePosition(properties);
    };

    /**
         * Encodes the specified GeoUpdatePosition message. Does not implicitly {@link proto.GeoUpdatePosition.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoUpdatePosition
         * @static
         * @param {proto.GeoUpdatePosition} message GeoUpdatePosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoUpdatePosition.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.lat != null && message.hasOwnProperty('lat')) {writer.uint32(/* id 2, wireType 1 =*/17).double(message.lat);}
      if (message.lon != null && message.hasOwnProperty('lon')) {writer.uint32(/* id 3, wireType 1 =*/25).double(message.lon);}
      return writer;
    };

    /**
         * Decodes a GeoUpdatePosition message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoUpdatePosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoUpdatePosition} GeoUpdatePosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoUpdatePosition.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoUpdatePosition();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.lat = reader.double();
            break;
          case 3:
            message.lon = reader.double();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoUpdatePosition message.
         * @function verify
         * @memberof proto.GeoUpdatePosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoUpdatePosition.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.lat != null && message.hasOwnProperty('lat')) {
        if (typeof message.lat !== 'number') {return 'lat: number expected';}
      }
      if (message.lon != null && message.hasOwnProperty('lon')) {
        if (typeof message.lon !== 'number') {return 'lon: number expected';}
      }
      return null;
    };

    return GeoUpdatePosition;
  })();

  proto.GeoUpdatePositionResponse = (function() {

    /**
         * Properties of a GeoUpdatePositionResponse.
         * @memberof proto
         * @interface IGeoUpdatePositionResponse
         * @property {proto.Response|null} [response] GeoUpdatePositionResponse response
         */

    /**
         * Constructs a new GeoUpdatePositionResponse.
         * @memberof proto
         * @classdesc Represents a GeoUpdatePositionResponse.
         * @implements IGeoUpdatePositionResponse
         * @constructor
         * @param {proto.IGeoUpdatePositionResponse=} [properties] Properties to set
         */
    function GeoUpdatePositionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GeoUpdatePositionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GeoUpdatePositionResponse
         * @instance
         */
    GeoUpdatePositionResponse.prototype.response = null;

    /**
         * Creates a new GeoUpdatePositionResponse instance using the specified properties.
         * @function create
         * @memberof proto.GeoUpdatePositionResponse
         * @static
         * @param {proto.IGeoUpdatePositionResponse=} [properties] Properties to set
         * @returns {proto.GeoUpdatePositionResponse} GeoUpdatePositionResponse instance
         */
    GeoUpdatePositionResponse.create = function create(properties) {
      return new GeoUpdatePositionResponse(properties);
    };

    /**
         * Encodes the specified GeoUpdatePositionResponse message. Does not implicitly {@link proto.GeoUpdatePositionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GeoUpdatePositionResponse
         * @static
         * @param {proto.GeoUpdatePositionResponse} message GeoUpdatePositionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GeoUpdatePositionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GeoUpdatePositionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GeoUpdatePositionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GeoUpdatePositionResponse} GeoUpdatePositionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GeoUpdatePositionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GeoUpdatePositionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GeoUpdatePositionResponse message.
         * @function verify
         * @memberof proto.GeoUpdatePositionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GeoUpdatePositionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return GeoUpdatePositionResponse;
  })();

  proto.GroupAddAdmin = (function() {

    /**
         * Properties of a GroupAddAdmin.
         * @memberof proto
         * @interface IGroupAddAdmin
         * @property {proto.Request|null} [request] GroupAddAdmin request
         * @property {Long|null} [roomId] GroupAddAdmin roomId
         * @property {Long|null} [memberId] GroupAddAdmin memberId
         */

    /**
         * Constructs a new GroupAddAdmin.
         * @memberof proto
         * @classdesc Represents a GroupAddAdmin.
         * @implements IGroupAddAdmin
         * @constructor
         * @param {proto.IGroupAddAdmin=} [properties] Properties to set
         */
    function GroupAddAdmin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddAdmin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAddAdmin
         * @instance
         */
    GroupAddAdmin.prototype.request = null;

    /**
         * GroupAddAdmin roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddAdmin
         * @instance
         */
    GroupAddAdmin.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddAdmin memberId.
         * @member {Long} memberId
         * @memberof proto.GroupAddAdmin
         * @instance
         */
    GroupAddAdmin.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAddAdmin instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddAdmin
         * @static
         * @param {proto.IGroupAddAdmin=} [properties] Properties to set
         * @returns {proto.GroupAddAdmin} GroupAddAdmin instance
         */
    GroupAddAdmin.create = function create(properties) {
      return new GroupAddAdmin(properties);
    };

    /**
         * Encodes the specified GroupAddAdmin message. Does not implicitly {@link proto.GroupAddAdmin.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddAdmin
         * @static
         * @param {proto.GroupAddAdmin} message GroupAddAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddAdmin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupAddAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddAdmin} GroupAddAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddAdmin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddAdmin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddAdmin message.
         * @function verify
         * @memberof proto.GroupAddAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddAdmin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupAddAdmin;
  })();

  proto.GroupAddAdminResponse = (function() {

    /**
         * Properties of a GroupAddAdminResponse.
         * @memberof proto
         * @interface IGroupAddAdminResponse
         * @property {proto.Response|null} [response] GroupAddAdminResponse response
         * @property {Long|null} [roomId] GroupAddAdminResponse roomId
         * @property {Long|null} [memberId] GroupAddAdminResponse memberId
         */

    /**
         * Constructs a new GroupAddAdminResponse.
         * @memberof proto
         * @classdesc Represents a GroupAddAdminResponse.
         * @implements IGroupAddAdminResponse
         * @constructor
         * @param {proto.IGroupAddAdminResponse=} [properties] Properties to set
         */
    function GroupAddAdminResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddAdminResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAddAdminResponse
         * @instance
         */
    GroupAddAdminResponse.prototype.response = null;

    /**
         * GroupAddAdminResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddAdminResponse
         * @instance
         */
    GroupAddAdminResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddAdminResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupAddAdminResponse
         * @instance
         */
    GroupAddAdminResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAddAdminResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddAdminResponse
         * @static
         * @param {proto.IGroupAddAdminResponse=} [properties] Properties to set
         * @returns {proto.GroupAddAdminResponse} GroupAddAdminResponse instance
         */
    GroupAddAdminResponse.create = function create(properties) {
      return new GroupAddAdminResponse(properties);
    };

    /**
         * Encodes the specified GroupAddAdminResponse message. Does not implicitly {@link proto.GroupAddAdminResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddAdminResponse
         * @static
         * @param {proto.GroupAddAdminResponse} message GroupAddAdminResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddAdminResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupAddAdminResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddAdminResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddAdminResponse} GroupAddAdminResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddAdminResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddAdminResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddAdminResponse message.
         * @function verify
         * @memberof proto.GroupAddAdminResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddAdminResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupAddAdminResponse;
  })();

  proto.GroupAddMember = (function() {

    /**
         * Properties of a GroupAddMember.
         * @memberof proto
         * @interface IGroupAddMember
         * @property {proto.Request|null} [request] GroupAddMember request
         * @property {Long|null} [roomId] GroupAddMember roomId
         * @property {proto.GroupAddMember.Member|null} [member] GroupAddMember member
         */

    /**
         * Constructs a new GroupAddMember.
         * @memberof proto
         * @classdesc Represents a GroupAddMember.
         * @implements IGroupAddMember
         * @constructor
         * @param {proto.IGroupAddMember=} [properties] Properties to set
         */
    function GroupAddMember(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddMember request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAddMember
         * @instance
         */
    GroupAddMember.prototype.request = null;

    /**
         * GroupAddMember roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddMember
         * @instance
         */
    GroupAddMember.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddMember member.
         * @member {proto.GroupAddMember.Member|null|undefined} member
         * @memberof proto.GroupAddMember
         * @instance
         */
    GroupAddMember.prototype.member = null;

    /**
         * Creates a new GroupAddMember instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddMember
         * @static
         * @param {proto.IGroupAddMember=} [properties] Properties to set
         * @returns {proto.GroupAddMember} GroupAddMember instance
         */
    GroupAddMember.create = function create(properties) {
      return new GroupAddMember(properties);
    };

    /**
         * Encodes the specified GroupAddMember message. Does not implicitly {@link proto.GroupAddMember.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddMember
         * @static
         * @param {proto.GroupAddMember} message GroupAddMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddMember.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.member != null && message.hasOwnProperty('member')) {$root.proto.GroupAddMember.Member.encode(message.member, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupAddMember message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddMember} GroupAddMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddMember.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddMember();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.member = $root.proto.GroupAddMember.Member.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddMember message.
         * @function verify
         * @memberof proto.GroupAddMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddMember.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.member != null && message.hasOwnProperty('member')) {
        let error = $root.proto.GroupAddMember.Member.verify(message.member);
        if (error) {return 'member.' + error;}
      }
      return null;
    };

    GroupAddMember.Member = (function() {

      /**
             * Properties of a Member.
             * @memberof proto.GroupAddMember
             * @interface IMember
             * @property {Long|null} [userId] Member userId
             * @property {Long|null} [startMessageId] Member startMessageId
             */

      /**
             * Constructs a new Member.
             * @memberof proto.GroupAddMember
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {proto.GroupAddMember.IMember=} [properties] Properties to set
             */
      function Member(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Member userId.
             * @member {Long} userId
             * @memberof proto.GroupAddMember.Member
             * @instance
             */
      Member.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Member startMessageId.
             * @member {Long} startMessageId
             * @memberof proto.GroupAddMember.Member
             * @instance
             */
      Member.prototype.startMessageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof proto.GroupAddMember.Member
             * @static
             * @param {proto.GroupAddMember.IMember=} [properties] Properties to set
             * @returns {proto.GroupAddMember.Member} Member instance
             */
      Member.create = function create(properties) {
        return new Member(properties);
      };

      /**
             * Encodes the specified Member message. Does not implicitly {@link proto.GroupAddMember.Member.verify|verify} messages.
             * @function encode
             * @memberof proto.GroupAddMember.Member
             * @static
             * @param {proto.GroupAddMember.Member} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Member.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.startMessageId != null && message.hasOwnProperty('startMessageId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.startMessageId);}
        return writer;
      };

      /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GroupAddMember.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GroupAddMember.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Member.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddMember.Member();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.startMessageId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Member message.
             * @function verify
             * @memberof proto.GroupAddMember.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Member.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.startMessageId != null && message.hasOwnProperty('startMessageId')) {
          if (!$util.isInteger(message.startMessageId) && !(message.startMessageId && $util.isInteger(message.startMessageId.low) && $util.isInteger(message.startMessageId.high))) {return 'startMessageId: integer|Long expected';}
        }
        return null;
      };

      return Member;
    })();

    return GroupAddMember;
  })();

  proto.GroupAddMemberResponse = (function() {

    /**
         * Properties of a GroupAddMemberResponse.
         * @memberof proto
         * @interface IGroupAddMemberResponse
         * @property {proto.Response|null} [response] GroupAddMemberResponse response
         * @property {Long|null} [roomId] GroupAddMemberResponse roomId
         * @property {Long|null} [userId] GroupAddMemberResponse userId
         * @property {proto.GroupRoom.Role|null} [role] GroupAddMemberResponse role
         */

    /**
         * Constructs a new GroupAddMemberResponse.
         * @memberof proto
         * @classdesc Represents a GroupAddMemberResponse.
         * @implements IGroupAddMemberResponse
         * @constructor
         * @param {proto.IGroupAddMemberResponse=} [properties] Properties to set
         */
    function GroupAddMemberResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddMemberResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAddMemberResponse
         * @instance
         */
    GroupAddMemberResponse.prototype.response = null;

    /**
         * GroupAddMemberResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddMemberResponse
         * @instance
         */
    GroupAddMemberResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddMemberResponse userId.
         * @member {Long} userId
         * @memberof proto.GroupAddMemberResponse
         * @instance
         */
    GroupAddMemberResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddMemberResponse role.
         * @member {proto.GroupRoom.Role} role
         * @memberof proto.GroupAddMemberResponse
         * @instance
         */
    GroupAddMemberResponse.prototype.role = 0;

    /**
         * Creates a new GroupAddMemberResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddMemberResponse
         * @static
         * @param {proto.IGroupAddMemberResponse=} [properties] Properties to set
         * @returns {proto.GroupAddMemberResponse} GroupAddMemberResponse instance
         */
    GroupAddMemberResponse.create = function create(properties) {
      return new GroupAddMemberResponse(properties);
    };

    /**
         * Encodes the specified GroupAddMemberResponse message. Does not implicitly {@link proto.GroupAddMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddMemberResponse
         * @static
         * @param {proto.GroupAddMemberResponse} message GroupAddMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddMemberResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.role);}
      return writer;
    };

    /**
         * Decodes a GroupAddMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddMemberResponse} GroupAddMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddMemberResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddMemberResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          case 4:
            message.role = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddMemberResponse message.
         * @function verify
         * @memberof proto.GroupAddMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddMemberResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.role != null && message.hasOwnProperty('role')) {
        switch (message.role) {
          default:
            return 'role: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    return GroupAddMemberResponse;
  })();

  proto.GroupAddModerator = (function() {

    /**
         * Properties of a GroupAddModerator.
         * @memberof proto
         * @interface IGroupAddModerator
         * @property {proto.Request|null} [request] GroupAddModerator request
         * @property {Long|null} [roomId] GroupAddModerator roomId
         * @property {Long|null} [memberId] GroupAddModerator memberId
         */

    /**
         * Constructs a new GroupAddModerator.
         * @memberof proto
         * @classdesc Represents a GroupAddModerator.
         * @implements IGroupAddModerator
         * @constructor
         * @param {proto.IGroupAddModerator=} [properties] Properties to set
         */
    function GroupAddModerator(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddModerator request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAddModerator
         * @instance
         */
    GroupAddModerator.prototype.request = null;

    /**
         * GroupAddModerator roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddModerator
         * @instance
         */
    GroupAddModerator.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddModerator memberId.
         * @member {Long} memberId
         * @memberof proto.GroupAddModerator
         * @instance
         */
    GroupAddModerator.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAddModerator instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddModerator
         * @static
         * @param {proto.IGroupAddModerator=} [properties] Properties to set
         * @returns {proto.GroupAddModerator} GroupAddModerator instance
         */
    GroupAddModerator.create = function create(properties) {
      return new GroupAddModerator(properties);
    };

    /**
         * Encodes the specified GroupAddModerator message. Does not implicitly {@link proto.GroupAddModerator.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddModerator
         * @static
         * @param {proto.GroupAddModerator} message GroupAddModerator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddModerator.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupAddModerator message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddModerator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddModerator} GroupAddModerator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddModerator.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddModerator();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddModerator message.
         * @function verify
         * @memberof proto.GroupAddModerator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddModerator.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupAddModerator;
  })();

  proto.GroupAddModeratorResponse = (function() {

    /**
         * Properties of a GroupAddModeratorResponse.
         * @memberof proto
         * @interface IGroupAddModeratorResponse
         * @property {proto.Response|null} [response] GroupAddModeratorResponse response
         * @property {Long|null} [roomId] GroupAddModeratorResponse roomId
         * @property {Long|null} [memberId] GroupAddModeratorResponse memberId
         */

    /**
         * Constructs a new GroupAddModeratorResponse.
         * @memberof proto
         * @classdesc Represents a GroupAddModeratorResponse.
         * @implements IGroupAddModeratorResponse
         * @constructor
         * @param {proto.IGroupAddModeratorResponse=} [properties] Properties to set
         */
    function GroupAddModeratorResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAddModeratorResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAddModeratorResponse
         * @instance
         */
    GroupAddModeratorResponse.prototype.response = null;

    /**
         * GroupAddModeratorResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAddModeratorResponse
         * @instance
         */
    GroupAddModeratorResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAddModeratorResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupAddModeratorResponse
         * @instance
         */
    GroupAddModeratorResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAddModeratorResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAddModeratorResponse
         * @static
         * @param {proto.IGroupAddModeratorResponse=} [properties] Properties to set
         * @returns {proto.GroupAddModeratorResponse} GroupAddModeratorResponse instance
         */
    GroupAddModeratorResponse.create = function create(properties) {
      return new GroupAddModeratorResponse(properties);
    };

    /**
         * Encodes the specified GroupAddModeratorResponse message. Does not implicitly {@link proto.GroupAddModeratorResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAddModeratorResponse
         * @static
         * @param {proto.GroupAddModeratorResponse} message GroupAddModeratorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAddModeratorResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupAddModeratorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAddModeratorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAddModeratorResponse} GroupAddModeratorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAddModeratorResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAddModeratorResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAddModeratorResponse message.
         * @function verify
         * @memberof proto.GroupAddModeratorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAddModeratorResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupAddModeratorResponse;
  })();

  proto.GroupAvatarAdd = (function() {

    /**
         * Properties of a GroupAvatarAdd.
         * @memberof proto
         * @interface IGroupAvatarAdd
         * @property {proto.Request|null} [request] GroupAvatarAdd request
         * @property {string|null} [attachment] GroupAvatarAdd attachment
         * @property {Long|null} [roomId] GroupAvatarAdd roomId
         */

    /**
         * Constructs a new GroupAvatarAdd.
         * @memberof proto
         * @classdesc Represents a GroupAvatarAdd.
         * @implements IGroupAvatarAdd
         * @constructor
         * @param {proto.IGroupAvatarAdd=} [properties] Properties to set
         */
    function GroupAvatarAdd(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarAdd request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAvatarAdd
         * @instance
         */
    GroupAvatarAdd.prototype.request = null;

    /**
         * GroupAvatarAdd attachment.
         * @member {string} attachment
         * @memberof proto.GroupAvatarAdd
         * @instance
         */
    GroupAvatarAdd.prototype.attachment = '';

    /**
         * GroupAvatarAdd roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAvatarAdd
         * @instance
         */
    GroupAvatarAdd.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAvatarAdd instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarAdd
         * @static
         * @param {proto.IGroupAvatarAdd=} [properties] Properties to set
         * @returns {proto.GroupAvatarAdd} GroupAvatarAdd instance
         */
    GroupAvatarAdd.create = function create(properties) {
      return new GroupAvatarAdd(properties);
    };

    /**
         * Encodes the specified GroupAvatarAdd message. Does not implicitly {@link proto.GroupAvatarAdd.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarAdd
         * @static
         * @param {proto.GroupAvatarAdd} message GroupAvatarAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarAdd.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.attachment);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupAvatarAdd message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarAdd} GroupAvatarAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarAdd.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarAdd();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.attachment = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarAdd message.
         * @function verify
         * @memberof proto.GroupAvatarAdd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarAdd.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupAvatarAdd;
  })();

  proto.GroupAvatarAddResponse = (function() {

    /**
         * Properties of a GroupAvatarAddResponse.
         * @memberof proto
         * @interface IGroupAvatarAddResponse
         * @property {proto.Response|null} [response] GroupAvatarAddResponse response
         * @property {proto.Avatar|null} [avatar] GroupAvatarAddResponse avatar
         * @property {Long|null} [roomId] GroupAvatarAddResponse roomId
         */

    /**
         * Constructs a new GroupAvatarAddResponse.
         * @memberof proto
         * @classdesc Represents a GroupAvatarAddResponse.
         * @implements IGroupAvatarAddResponse
         * @constructor
         * @param {proto.IGroupAvatarAddResponse=} [properties] Properties to set
         */
    function GroupAvatarAddResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarAddResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAvatarAddResponse
         * @instance
         */
    GroupAvatarAddResponse.prototype.response = null;

    /**
         * GroupAvatarAddResponse avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.GroupAvatarAddResponse
         * @instance
         */
    GroupAvatarAddResponse.prototype.avatar = null;

    /**
         * GroupAvatarAddResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAvatarAddResponse
         * @instance
         */
    GroupAvatarAddResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAvatarAddResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarAddResponse
         * @static
         * @param {proto.IGroupAvatarAddResponse=} [properties] Properties to set
         * @returns {proto.GroupAvatarAddResponse} GroupAvatarAddResponse instance
         */
    GroupAvatarAddResponse.create = function create(properties) {
      return new GroupAvatarAddResponse(properties);
    };

    /**
         * Encodes the specified GroupAvatarAddResponse message. Does not implicitly {@link proto.GroupAvatarAddResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarAddResponse
         * @static
         * @param {proto.GroupAvatarAddResponse} message GroupAvatarAddResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarAddResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupAvatarAddResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarAddResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarAddResponse} GroupAvatarAddResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarAddResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarAddResponse message.
         * @function verify
         * @memberof proto.GroupAvatarAddResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarAddResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupAvatarAddResponse;
  })();

  proto.GroupAvatarDelete = (function() {

    /**
         * Properties of a GroupAvatarDelete.
         * @memberof proto
         * @interface IGroupAvatarDelete
         * @property {proto.Request|null} [request] GroupAvatarDelete request
         * @property {Long|null} [id] GroupAvatarDelete id
         * @property {Long|null} [roomId] GroupAvatarDelete roomId
         */

    /**
         * Constructs a new GroupAvatarDelete.
         * @memberof proto
         * @classdesc Represents a GroupAvatarDelete.
         * @implements IGroupAvatarDelete
         * @constructor
         * @param {proto.IGroupAvatarDelete=} [properties] Properties to set
         */
    function GroupAvatarDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAvatarDelete
         * @instance
         */
    GroupAvatarDelete.prototype.request = null;

    /**
         * GroupAvatarDelete id.
         * @member {Long} id
         * @memberof proto.GroupAvatarDelete
         * @instance
         */
    GroupAvatarDelete.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAvatarDelete roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAvatarDelete
         * @instance
         */
    GroupAvatarDelete.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAvatarDelete instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarDelete
         * @static
         * @param {proto.IGroupAvatarDelete=} [properties] Properties to set
         * @returns {proto.GroupAvatarDelete} GroupAvatarDelete instance
         */
    GroupAvatarDelete.create = function create(properties) {
      return new GroupAvatarDelete(properties);
    };

    /**
         * Encodes the specified GroupAvatarDelete message. Does not implicitly {@link proto.GroupAvatarDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarDelete
         * @static
         * @param {proto.GroupAvatarDelete} message GroupAvatarDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupAvatarDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarDelete} GroupAvatarDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarDelete message.
         * @function verify
         * @memberof proto.GroupAvatarDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupAvatarDelete;
  })();

  proto.GroupAvatarDeleteResponse = (function() {

    /**
         * Properties of a GroupAvatarDeleteResponse.
         * @memberof proto
         * @interface IGroupAvatarDeleteResponse
         * @property {proto.Response|null} [response] GroupAvatarDeleteResponse response
         * @property {Long|null} [id] GroupAvatarDeleteResponse id
         * @property {Long|null} [roomId] GroupAvatarDeleteResponse roomId
         */

    /**
         * Constructs a new GroupAvatarDeleteResponse.
         * @memberof proto
         * @classdesc Represents a GroupAvatarDeleteResponse.
         * @implements IGroupAvatarDeleteResponse
         * @constructor
         * @param {proto.IGroupAvatarDeleteResponse=} [properties] Properties to set
         */
    function GroupAvatarDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAvatarDeleteResponse
         * @instance
         */
    GroupAvatarDeleteResponse.prototype.response = null;

    /**
         * GroupAvatarDeleteResponse id.
         * @member {Long} id
         * @memberof proto.GroupAvatarDeleteResponse
         * @instance
         */
    GroupAvatarDeleteResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupAvatarDeleteResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAvatarDeleteResponse
         * @instance
         */
    GroupAvatarDeleteResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAvatarDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarDeleteResponse
         * @static
         * @param {proto.IGroupAvatarDeleteResponse=} [properties] Properties to set
         * @returns {proto.GroupAvatarDeleteResponse} GroupAvatarDeleteResponse instance
         */
    GroupAvatarDeleteResponse.create = function create(properties) {
      return new GroupAvatarDeleteResponse(properties);
    };

    /**
         * Encodes the specified GroupAvatarDeleteResponse message. Does not implicitly {@link proto.GroupAvatarDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarDeleteResponse
         * @static
         * @param {proto.GroupAvatarDeleteResponse} message GroupAvatarDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupAvatarDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarDeleteResponse} GroupAvatarDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarDeleteResponse message.
         * @function verify
         * @memberof proto.GroupAvatarDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupAvatarDeleteResponse;
  })();

  proto.GroupAvatarGetList = (function() {

    /**
         * Properties of a GroupAvatarGetList.
         * @memberof proto
         * @interface IGroupAvatarGetList
         * @property {proto.Request|null} [request] GroupAvatarGetList request
         * @property {Long|null} [roomId] GroupAvatarGetList roomId
         */

    /**
         * Constructs a new GroupAvatarGetList.
         * @memberof proto
         * @classdesc Represents a GroupAvatarGetList.
         * @implements IGroupAvatarGetList
         * @constructor
         * @param {proto.IGroupAvatarGetList=} [properties] Properties to set
         */
    function GroupAvatarGetList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarGetList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupAvatarGetList
         * @instance
         */
    GroupAvatarGetList.prototype.request = null;

    /**
         * GroupAvatarGetList roomId.
         * @member {Long} roomId
         * @memberof proto.GroupAvatarGetList
         * @instance
         */
    GroupAvatarGetList.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupAvatarGetList instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarGetList
         * @static
         * @param {proto.IGroupAvatarGetList=} [properties] Properties to set
         * @returns {proto.GroupAvatarGetList} GroupAvatarGetList instance
         */
    GroupAvatarGetList.create = function create(properties) {
      return new GroupAvatarGetList(properties);
    };

    /**
         * Encodes the specified GroupAvatarGetList message. Does not implicitly {@link proto.GroupAvatarGetList.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarGetList
         * @static
         * @param {proto.GroupAvatarGetList} message GroupAvatarGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarGetList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupAvatarGetList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarGetList} GroupAvatarGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarGetList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarGetList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarGetList message.
         * @function verify
         * @memberof proto.GroupAvatarGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarGetList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupAvatarGetList;
  })();

  proto.GroupAvatarGetListResponse = (function() {

    /**
         * Properties of a GroupAvatarGetListResponse.
         * @memberof proto
         * @interface IGroupAvatarGetListResponse
         * @property {proto.Response|null} [response] GroupAvatarGetListResponse response
         * @property {Array.<proto.Avatar>|null} [avatar] GroupAvatarGetListResponse avatar
         */

    /**
         * Constructs a new GroupAvatarGetListResponse.
         * @memberof proto
         * @classdesc Represents a GroupAvatarGetListResponse.
         * @implements IGroupAvatarGetListResponse
         * @constructor
         * @param {proto.IGroupAvatarGetListResponse=} [properties] Properties to set
         */
    function GroupAvatarGetListResponse(properties) {
      this.avatar = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupAvatarGetListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupAvatarGetListResponse
         * @instance
         */
    GroupAvatarGetListResponse.prototype.response = null;

    /**
         * GroupAvatarGetListResponse avatar.
         * @member {Array.<proto.Avatar>} avatar
         * @memberof proto.GroupAvatarGetListResponse
         * @instance
         */
    GroupAvatarGetListResponse.prototype.avatar = $util.emptyArray;

    /**
         * Creates a new GroupAvatarGetListResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupAvatarGetListResponse
         * @static
         * @param {proto.IGroupAvatarGetListResponse=} [properties] Properties to set
         * @returns {proto.GroupAvatarGetListResponse} GroupAvatarGetListResponse instance
         */
    GroupAvatarGetListResponse.create = function create(properties) {
      return new GroupAvatarGetListResponse(properties);
    };

    /**
         * Encodes the specified GroupAvatarGetListResponse message. Does not implicitly {@link proto.GroupAvatarGetListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupAvatarGetListResponse
         * @static
         * @param {proto.GroupAvatarGetListResponse} message GroupAvatarGetListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupAvatarGetListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.avatar.length) {
        for (let i = 0; i < message.avatar.length; ++i) {$root.proto.Avatar.encode(message.avatar[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a GroupAvatarGetListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupAvatarGetListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupAvatarGetListResponse} GroupAvatarGetListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupAvatarGetListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupAvatarGetListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.avatar && message.avatar.length)) {message.avatar = [];}
            message.avatar.push($root.proto.Avatar.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupAvatarGetListResponse message.
         * @function verify
         * @memberof proto.GroupAvatarGetListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupAvatarGetListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        if (!Array.isArray(message.avatar)) {return 'avatar: array expected';}
        for (let i = 0; i < message.avatar.length; ++i) {
          let error = $root.proto.Avatar.verify(message.avatar[i]);
          if (error) {return 'avatar.' + error;}
        }
      }
      return null;
    };

    return GroupAvatarGetListResponse;
  })();

  proto.GroupCheckUsername = (function() {

    /**
         * Properties of a GroupCheckUsername.
         * @memberof proto
         * @interface IGroupCheckUsername
         * @property {proto.Request|null} [request] GroupCheckUsername request
         * @property {string|null} [username] GroupCheckUsername username
         * @property {Long|null} [roomId] GroupCheckUsername roomId
         */

    /**
         * Constructs a new GroupCheckUsername.
         * @memberof proto
         * @classdesc Represents a GroupCheckUsername.
         * @implements IGroupCheckUsername
         * @constructor
         * @param {proto.IGroupCheckUsername=} [properties] Properties to set
         */
    function GroupCheckUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupCheckUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupCheckUsername
         * @instance
         */
    GroupCheckUsername.prototype.request = null;

    /**
         * GroupCheckUsername username.
         * @member {string} username
         * @memberof proto.GroupCheckUsername
         * @instance
         */
    GroupCheckUsername.prototype.username = '';

    /**
         * GroupCheckUsername roomId.
         * @member {Long} roomId
         * @memberof proto.GroupCheckUsername
         * @instance
         */
    GroupCheckUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupCheckUsername instance using the specified properties.
         * @function create
         * @memberof proto.GroupCheckUsername
         * @static
         * @param {proto.IGroupCheckUsername=} [properties] Properties to set
         * @returns {proto.GroupCheckUsername} GroupCheckUsername instance
         */
    GroupCheckUsername.create = function create(properties) {
      return new GroupCheckUsername(properties);
    };

    /**
         * Encodes the specified GroupCheckUsername message. Does not implicitly {@link proto.GroupCheckUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupCheckUsername
         * @static
         * @param {proto.GroupCheckUsername} message GroupCheckUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupCheckUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupCheckUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupCheckUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupCheckUsername} GroupCheckUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupCheckUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupCheckUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupCheckUsername message.
         * @function verify
         * @memberof proto.GroupCheckUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupCheckUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupCheckUsername;
  })();

  proto.GroupCheckUsernameResponse = (function() {

    /**
         * Properties of a GroupCheckUsernameResponse.
         * @memberof proto
         * @interface IGroupCheckUsernameResponse
         * @property {proto.Response|null} [response] GroupCheckUsernameResponse response
         * @property {proto.GroupCheckUsernameResponse.Status|null} [status] GroupCheckUsernameResponse status
         */

    /**
         * Constructs a new GroupCheckUsernameResponse.
         * @memberof proto
         * @classdesc Represents a GroupCheckUsernameResponse.
         * @implements IGroupCheckUsernameResponse
         * @constructor
         * @param {proto.IGroupCheckUsernameResponse=} [properties] Properties to set
         */
    function GroupCheckUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupCheckUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupCheckUsernameResponse
         * @instance
         */
    GroupCheckUsernameResponse.prototype.response = null;

    /**
         * GroupCheckUsernameResponse status.
         * @member {proto.GroupCheckUsernameResponse.Status} status
         * @memberof proto.GroupCheckUsernameResponse
         * @instance
         */
    GroupCheckUsernameResponse.prototype.status = 0;

    /**
         * Creates a new GroupCheckUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupCheckUsernameResponse
         * @static
         * @param {proto.IGroupCheckUsernameResponse=} [properties] Properties to set
         * @returns {proto.GroupCheckUsernameResponse} GroupCheckUsernameResponse instance
         */
    GroupCheckUsernameResponse.create = function create(properties) {
      return new GroupCheckUsernameResponse(properties);
    };

    /**
         * Encodes the specified GroupCheckUsernameResponse message. Does not implicitly {@link proto.GroupCheckUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupCheckUsernameResponse
         * @static
         * @param {proto.GroupCheckUsernameResponse} message GroupCheckUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupCheckUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a GroupCheckUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupCheckUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupCheckUsernameResponse} GroupCheckUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupCheckUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupCheckUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupCheckUsernameResponse message.
         * @function verify
         * @memberof proto.GroupCheckUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupCheckUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.GroupCheckUsernameResponse.Status
         * @enum {string}
         * @property {number} INVALID=0 INVALID value
         * @property {number} TAKEN=1 TAKEN value
         * @property {number} AVAILABLE=2 AVAILABLE value
         * @property {number} OCCUPYING_LIMIT_EXCEEDED=3 OCCUPYING_LIMIT_EXCEEDED value
         */
    GroupCheckUsernameResponse.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'INVALID'] = 0;
      values[valuesById[1] = 'TAKEN'] = 1;
      values[valuesById[2] = 'AVAILABLE'] = 2;
      values[valuesById[3] = 'OCCUPYING_LIMIT_EXCEEDED'] = 3;
      return values;
    })();

    return GroupCheckUsernameResponse;
  })();

  proto.GroupClearMessage = (function() {

    /**
         * Properties of a GroupClearMessage.
         * @memberof proto
         * @interface IGroupClearMessage
         * @property {proto.Request|null} [request] GroupClearMessage request
         * @property {Long|null} [roomId] GroupClearMessage roomId
         * @property {Long|null} [clearId] GroupClearMessage clearId
         */

    /**
         * Constructs a new GroupClearMessage.
         * @memberof proto
         * @classdesc Represents a GroupClearMessage.
         * @implements IGroupClearMessage
         * @constructor
         * @param {proto.IGroupClearMessage=} [properties] Properties to set
         */
    function GroupClearMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupClearMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupClearMessage
         * @instance
         */
    GroupClearMessage.prototype.request = null;

    /**
         * GroupClearMessage roomId.
         * @member {Long} roomId
         * @memberof proto.GroupClearMessage
         * @instance
         */
    GroupClearMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupClearMessage clearId.
         * @member {Long} clearId
         * @memberof proto.GroupClearMessage
         * @instance
         */
    GroupClearMessage.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupClearMessage instance using the specified properties.
         * @function create
         * @memberof proto.GroupClearMessage
         * @static
         * @param {proto.IGroupClearMessage=} [properties] Properties to set
         * @returns {proto.GroupClearMessage} GroupClearMessage instance
         */
    GroupClearMessage.create = function create(properties) {
      return new GroupClearMessage(properties);
    };

    /**
         * Encodes the specified GroupClearMessage message. Does not implicitly {@link proto.GroupClearMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupClearMessage
         * @static
         * @param {proto.GroupClearMessage} message GroupClearMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupClearMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a GroupClearMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupClearMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupClearMessage} GroupClearMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupClearMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupClearMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupClearMessage message.
         * @function verify
         * @memberof proto.GroupClearMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupClearMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return GroupClearMessage;
  })();

  proto.GroupClearMessageResponse = (function() {

    /**
         * Properties of a GroupClearMessageResponse.
         * @memberof proto
         * @interface IGroupClearMessageResponse
         * @property {proto.Response|null} [response] GroupClearMessageResponse response
         * @property {Long|null} [roomId] GroupClearMessageResponse roomId
         * @property {Long|null} [clearId] GroupClearMessageResponse clearId
         */

    /**
         * Constructs a new GroupClearMessageResponse.
         * @memberof proto
         * @classdesc Represents a GroupClearMessageResponse.
         * @implements IGroupClearMessageResponse
         * @constructor
         * @param {proto.IGroupClearMessageResponse=} [properties] Properties to set
         */
    function GroupClearMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupClearMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupClearMessageResponse
         * @instance
         */
    GroupClearMessageResponse.prototype.response = null;

    /**
         * GroupClearMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupClearMessageResponse
         * @instance
         */
    GroupClearMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupClearMessageResponse clearId.
         * @member {Long} clearId
         * @memberof proto.GroupClearMessageResponse
         * @instance
         */
    GroupClearMessageResponse.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupClearMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupClearMessageResponse
         * @static
         * @param {proto.IGroupClearMessageResponse=} [properties] Properties to set
         * @returns {proto.GroupClearMessageResponse} GroupClearMessageResponse instance
         */
    GroupClearMessageResponse.create = function create(properties) {
      return new GroupClearMessageResponse(properties);
    };

    /**
         * Encodes the specified GroupClearMessageResponse message. Does not implicitly {@link proto.GroupClearMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupClearMessageResponse
         * @static
         * @param {proto.GroupClearMessageResponse} message GroupClearMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupClearMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a GroupClearMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupClearMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupClearMessageResponse} GroupClearMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupClearMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupClearMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupClearMessageResponse message.
         * @function verify
         * @memberof proto.GroupClearMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupClearMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return GroupClearMessageResponse;
  })();

  proto.GroupCreate = (function() {

    /**
         * Properties of a GroupCreate.
         * @memberof proto
         * @interface IGroupCreate
         * @property {proto.Request|null} [request] GroupCreate request
         * @property {string|null} [name] GroupCreate name
         * @property {string|null} [description] GroupCreate description
         */

    /**
         * Constructs a new GroupCreate.
         * @memberof proto
         * @classdesc Represents a GroupCreate.
         * @implements IGroupCreate
         * @constructor
         * @param {proto.IGroupCreate=} [properties] Properties to set
         */
    function GroupCreate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupCreate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupCreate
         * @instance
         */
    GroupCreate.prototype.request = null;

    /**
         * GroupCreate name.
         * @member {string} name
         * @memberof proto.GroupCreate
         * @instance
         */
    GroupCreate.prototype.name = '';

    /**
         * GroupCreate description.
         * @member {string} description
         * @memberof proto.GroupCreate
         * @instance
         */
    GroupCreate.prototype.description = '';

    /**
         * Creates a new GroupCreate instance using the specified properties.
         * @function create
         * @memberof proto.GroupCreate
         * @static
         * @param {proto.IGroupCreate=} [properties] Properties to set
         * @returns {proto.GroupCreate} GroupCreate instance
         */
    GroupCreate.create = function create(properties) {
      return new GroupCreate(properties);
    };

    /**
         * Encodes the specified GroupCreate message. Does not implicitly {@link proto.GroupCreate.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupCreate
         * @static
         * @param {proto.GroupCreate} message GroupCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupCreate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);}
      return writer;
    };

    /**
         * Decodes a GroupCreate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupCreate} GroupCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupCreate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupCreate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupCreate message.
         * @function verify
         * @memberof proto.GroupCreate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupCreate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return GroupCreate;
  })();

  proto.GroupCreateResponse = (function() {

    /**
         * Properties of a GroupCreateResponse.
         * @memberof proto
         * @interface IGroupCreateResponse
         * @property {proto.Response|null} [response] GroupCreateResponse response
         * @property {Long|null} [roomId] GroupCreateResponse roomId
         * @property {string|null} [inviteLink] GroupCreateResponse inviteLink
         */

    /**
         * Constructs a new GroupCreateResponse.
         * @memberof proto
         * @classdesc Represents a GroupCreateResponse.
         * @implements IGroupCreateResponse
         * @constructor
         * @param {proto.IGroupCreateResponse=} [properties] Properties to set
         */
    function GroupCreateResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupCreateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupCreateResponse
         * @instance
         */
    GroupCreateResponse.prototype.response = null;

    /**
         * GroupCreateResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupCreateResponse
         * @instance
         */
    GroupCreateResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupCreateResponse inviteLink.
         * @member {string} inviteLink
         * @memberof proto.GroupCreateResponse
         * @instance
         */
    GroupCreateResponse.prototype.inviteLink = '';

    /**
         * Creates a new GroupCreateResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupCreateResponse
         * @static
         * @param {proto.IGroupCreateResponse=} [properties] Properties to set
         * @returns {proto.GroupCreateResponse} GroupCreateResponse instance
         */
    GroupCreateResponse.create = function create(properties) {
      return new GroupCreateResponse(properties);
    };

    /**
         * Encodes the specified GroupCreateResponse message. Does not implicitly {@link proto.GroupCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupCreateResponse
         * @static
         * @param {proto.GroupCreateResponse} message GroupCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupCreateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.inviteLink);}
      return writer;
    };

    /**
         * Decodes a GroupCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupCreateResponse} GroupCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupCreateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupCreateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.inviteLink = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupCreateResponse message.
         * @function verify
         * @memberof proto.GroupCreateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupCreateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
        if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
      }
      return null;
    };

    return GroupCreateResponse;
  })();

  proto.GroupDelete = (function() {

    /**
         * Properties of a GroupDelete.
         * @memberof proto
         * @interface IGroupDelete
         * @property {proto.Request|null} [request] GroupDelete request
         * @property {Long|null} [roomId] GroupDelete roomId
         */

    /**
         * Constructs a new GroupDelete.
         * @memberof proto
         * @classdesc Represents a GroupDelete.
         * @implements IGroupDelete
         * @constructor
         * @param {proto.IGroupDelete=} [properties] Properties to set
         */
    function GroupDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupDelete
         * @instance
         */
    GroupDelete.prototype.request = null;

    /**
         * GroupDelete roomId.
         * @member {Long} roomId
         * @memberof proto.GroupDelete
         * @instance
         */
    GroupDelete.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupDelete instance using the specified properties.
         * @function create
         * @memberof proto.GroupDelete
         * @static
         * @param {proto.IGroupDelete=} [properties] Properties to set
         * @returns {proto.GroupDelete} GroupDelete instance
         */
    GroupDelete.create = function create(properties) {
      return new GroupDelete(properties);
    };

    /**
         * Encodes the specified GroupDelete message. Does not implicitly {@link proto.GroupDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupDelete
         * @static
         * @param {proto.GroupDelete} message GroupDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupDelete} GroupDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupDelete message.
         * @function verify
         * @memberof proto.GroupDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupDelete;
  })();

  proto.GroupDeleteResponse = (function() {

    /**
         * Properties of a GroupDeleteResponse.
         * @memberof proto
         * @interface IGroupDeleteResponse
         * @property {proto.Response|null} [response] GroupDeleteResponse response
         * @property {Long|null} [roomId] GroupDeleteResponse roomId
         */

    /**
         * Constructs a new GroupDeleteResponse.
         * @memberof proto
         * @classdesc Represents a GroupDeleteResponse.
         * @implements IGroupDeleteResponse
         * @constructor
         * @param {proto.IGroupDeleteResponse=} [properties] Properties to set
         */
    function GroupDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupDeleteResponse
         * @instance
         */
    GroupDeleteResponse.prototype.response = null;

    /**
         * GroupDeleteResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupDeleteResponse
         * @instance
         */
    GroupDeleteResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupDeleteResponse
         * @static
         * @param {proto.IGroupDeleteResponse=} [properties] Properties to set
         * @returns {proto.GroupDeleteResponse} GroupDeleteResponse instance
         */
    GroupDeleteResponse.create = function create(properties) {
      return new GroupDeleteResponse(properties);
    };

    /**
         * Encodes the specified GroupDeleteResponse message. Does not implicitly {@link proto.GroupDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupDeleteResponse
         * @static
         * @param {proto.GroupDeleteResponse} message GroupDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupDeleteResponse} GroupDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupDeleteResponse message.
         * @function verify
         * @memberof proto.GroupDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupDeleteResponse;
  })();

  proto.GroupDeleteMessage = (function() {

    /**
         * Properties of a GroupDeleteMessage.
         * @memberof proto
         * @interface IGroupDeleteMessage
         * @property {proto.Request|null} [request] GroupDeleteMessage request
         * @property {Long|null} [roomId] GroupDeleteMessage roomId
         * @property {Long|null} [messageId] GroupDeleteMessage messageId
         */

    /**
         * Constructs a new GroupDeleteMessage.
         * @memberof proto
         * @classdesc Represents a GroupDeleteMessage.
         * @implements IGroupDeleteMessage
         * @constructor
         * @param {proto.IGroupDeleteMessage=} [properties] Properties to set
         */
    function GroupDeleteMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupDeleteMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupDeleteMessage
         * @instance
         */
    GroupDeleteMessage.prototype.request = null;

    /**
         * GroupDeleteMessage roomId.
         * @member {Long} roomId
         * @memberof proto.GroupDeleteMessage
         * @instance
         */
    GroupDeleteMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupDeleteMessage messageId.
         * @member {Long} messageId
         * @memberof proto.GroupDeleteMessage
         * @instance
         */
    GroupDeleteMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupDeleteMessage instance using the specified properties.
         * @function create
         * @memberof proto.GroupDeleteMessage
         * @static
         * @param {proto.IGroupDeleteMessage=} [properties] Properties to set
         * @returns {proto.GroupDeleteMessage} GroupDeleteMessage instance
         */
    GroupDeleteMessage.create = function create(properties) {
      return new GroupDeleteMessage(properties);
    };

    /**
         * Encodes the specified GroupDeleteMessage message. Does not implicitly {@link proto.GroupDeleteMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupDeleteMessage
         * @static
         * @param {proto.GroupDeleteMessage} message GroupDeleteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupDeleteMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a GroupDeleteMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupDeleteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupDeleteMessage} GroupDeleteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupDeleteMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupDeleteMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupDeleteMessage message.
         * @function verify
         * @memberof proto.GroupDeleteMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupDeleteMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return GroupDeleteMessage;
  })();

  proto.GroupDeleteMessageResponse = (function() {

    /**
         * Properties of a GroupDeleteMessageResponse.
         * @memberof proto
         * @interface IGroupDeleteMessageResponse
         * @property {proto.Response|null} [response] GroupDeleteMessageResponse response
         * @property {Long|null} [roomId] GroupDeleteMessageResponse roomId
         * @property {Long|null} [messageId] GroupDeleteMessageResponse messageId
         * @property {Long|null} [deleteVersion] GroupDeleteMessageResponse deleteVersion
         */

    /**
         * Constructs a new GroupDeleteMessageResponse.
         * @memberof proto
         * @classdesc Represents a GroupDeleteMessageResponse.
         * @implements IGroupDeleteMessageResponse
         * @constructor
         * @param {proto.IGroupDeleteMessageResponse=} [properties] Properties to set
         */
    function GroupDeleteMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupDeleteMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupDeleteMessageResponse
         * @instance
         */
    GroupDeleteMessageResponse.prototype.response = null;

    /**
         * GroupDeleteMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupDeleteMessageResponse
         * @instance
         */
    GroupDeleteMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupDeleteMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.GroupDeleteMessageResponse
         * @instance
         */
    GroupDeleteMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupDeleteMessageResponse deleteVersion.
         * @member {Long} deleteVersion
         * @memberof proto.GroupDeleteMessageResponse
         * @instance
         */
    GroupDeleteMessageResponse.prototype.deleteVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupDeleteMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupDeleteMessageResponse
         * @static
         * @param {proto.IGroupDeleteMessageResponse=} [properties] Properties to set
         * @returns {proto.GroupDeleteMessageResponse} GroupDeleteMessageResponse instance
         */
    GroupDeleteMessageResponse.create = function create(properties) {
      return new GroupDeleteMessageResponse(properties);
    };

    /**
         * Encodes the specified GroupDeleteMessageResponse message. Does not implicitly {@link proto.GroupDeleteMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupDeleteMessageResponse
         * @static
         * @param {proto.GroupDeleteMessageResponse} message GroupDeleteMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupDeleteMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.deleteVersion);}
      return writer;
    };

    /**
         * Decodes a GroupDeleteMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupDeleteMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupDeleteMessageResponse} GroupDeleteMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupDeleteMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupDeleteMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.deleteVersion = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupDeleteMessageResponse message.
         * @function verify
         * @memberof proto.GroupDeleteMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupDeleteMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.deleteVersion != null && message.hasOwnProperty('deleteVersion')) {
        if (!$util.isInteger(message.deleteVersion) && !(message.deleteVersion && $util.isInteger(message.deleteVersion.low) && $util.isInteger(message.deleteVersion.high))) {return 'deleteVersion: integer|Long expected';}
      }
      return null;
    };

    return GroupDeleteMessageResponse;
  })();

  proto.GroupEdit = (function() {

    /**
         * Properties of a GroupEdit.
         * @memberof proto
         * @interface IGroupEdit
         * @property {proto.Request|null} [request] GroupEdit request
         * @property {Long|null} [roomId] GroupEdit roomId
         * @property {string|null} [name] GroupEdit name
         * @property {string|null} [description] GroupEdit description
         */

    /**
         * Constructs a new GroupEdit.
         * @memberof proto
         * @classdesc Represents a GroupEdit.
         * @implements IGroupEdit
         * @constructor
         * @param {proto.IGroupEdit=} [properties] Properties to set
         */
    function GroupEdit(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupEdit request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupEdit
         * @instance
         */
    GroupEdit.prototype.request = null;

    /**
         * GroupEdit roomId.
         * @member {Long} roomId
         * @memberof proto.GroupEdit
         * @instance
         */
    GroupEdit.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEdit name.
         * @member {string} name
         * @memberof proto.GroupEdit
         * @instance
         */
    GroupEdit.prototype.name = '';

    /**
         * GroupEdit description.
         * @member {string} description
         * @memberof proto.GroupEdit
         * @instance
         */
    GroupEdit.prototype.description = '';

    /**
         * Creates a new GroupEdit instance using the specified properties.
         * @function create
         * @memberof proto.GroupEdit
         * @static
         * @param {proto.IGroupEdit=} [properties] Properties to set
         * @returns {proto.GroupEdit} GroupEdit instance
         */
    GroupEdit.create = function create(properties) {
      return new GroupEdit(properties);
    };

    /**
         * Encodes the specified GroupEdit message. Does not implicitly {@link proto.GroupEdit.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupEdit
         * @static
         * @param {proto.GroupEdit} message GroupEdit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupEdit.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a GroupEdit message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupEdit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupEdit} GroupEdit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupEdit.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupEdit();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupEdit message.
         * @function verify
         * @memberof proto.GroupEdit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupEdit.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return GroupEdit;
  })();

  proto.GroupEditResponse = (function() {

    /**
         * Properties of a GroupEditResponse.
         * @memberof proto
         * @interface IGroupEditResponse
         * @property {proto.Response|null} [response] GroupEditResponse response
         * @property {Long|null} [roomId] GroupEditResponse roomId
         * @property {string|null} [name] GroupEditResponse name
         * @property {string|null} [description] GroupEditResponse description
         */

    /**
         * Constructs a new GroupEditResponse.
         * @memberof proto
         * @classdesc Represents a GroupEditResponse.
         * @implements IGroupEditResponse
         * @constructor
         * @param {proto.IGroupEditResponse=} [properties] Properties to set
         */
    function GroupEditResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupEditResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupEditResponse
         * @instance
         */
    GroupEditResponse.prototype.response = null;

    /**
         * GroupEditResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupEditResponse
         * @instance
         */
    GroupEditResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditResponse name.
         * @member {string} name
         * @memberof proto.GroupEditResponse
         * @instance
         */
    GroupEditResponse.prototype.name = '';

    /**
         * GroupEditResponse description.
         * @member {string} description
         * @memberof proto.GroupEditResponse
         * @instance
         */
    GroupEditResponse.prototype.description = '';

    /**
         * Creates a new GroupEditResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupEditResponse
         * @static
         * @param {proto.IGroupEditResponse=} [properties] Properties to set
         * @returns {proto.GroupEditResponse} GroupEditResponse instance
         */
    GroupEditResponse.create = function create(properties) {
      return new GroupEditResponse(properties);
    };

    /**
         * Encodes the specified GroupEditResponse message. Does not implicitly {@link proto.GroupEditResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupEditResponse
         * @static
         * @param {proto.GroupEditResponse} message GroupEditResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupEditResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a GroupEditResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupEditResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupEditResponse} GroupEditResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupEditResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupEditResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupEditResponse message.
         * @function verify
         * @memberof proto.GroupEditResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupEditResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    return GroupEditResponse;
  })();

  proto.GroupEditMessage = (function() {

    /**
         * Properties of a GroupEditMessage.
         * @memberof proto
         * @interface IGroupEditMessage
         * @property {proto.Request|null} [request] GroupEditMessage request
         * @property {Long|null} [roomId] GroupEditMessage roomId
         * @property {Long|null} [messageId] GroupEditMessage messageId
         * @property {string|null} [message] GroupEditMessage message
         */

    /**
         * Constructs a new GroupEditMessage.
         * @memberof proto
         * @classdesc Represents a GroupEditMessage.
         * @implements IGroupEditMessage
         * @constructor
         * @param {proto.IGroupEditMessage=} [properties] Properties to set
         */
    function GroupEditMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupEditMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupEditMessage
         * @instance
         */
    GroupEditMessage.prototype.request = null;

    /**
         * GroupEditMessage roomId.
         * @member {Long} roomId
         * @memberof proto.GroupEditMessage
         * @instance
         */
    GroupEditMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditMessage messageId.
         * @member {Long} messageId
         * @memberof proto.GroupEditMessage
         * @instance
         */
    GroupEditMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditMessage message.
         * @member {string} message
         * @memberof proto.GroupEditMessage
         * @instance
         */
    GroupEditMessage.prototype.message = '';

    /**
         * Creates a new GroupEditMessage instance using the specified properties.
         * @function create
         * @memberof proto.GroupEditMessage
         * @static
         * @param {proto.IGroupEditMessage=} [properties] Properties to set
         * @returns {proto.GroupEditMessage} GroupEditMessage instance
         */
    GroupEditMessage.create = function create(properties) {
      return new GroupEditMessage(properties);
    };

    /**
         * Encodes the specified GroupEditMessage message. Does not implicitly {@link proto.GroupEditMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupEditMessage
         * @static
         * @param {proto.GroupEditMessage} message GroupEditMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupEditMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      return writer;
    };

    /**
         * Decodes a GroupEditMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupEditMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupEditMessage} GroupEditMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupEditMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupEditMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupEditMessage message.
         * @function verify
         * @memberof proto.GroupEditMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupEditMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      return null;
    };

    return GroupEditMessage;
  })();

  proto.GroupEditMessageResponse = (function() {

    /**
         * Properties of a GroupEditMessageResponse.
         * @memberof proto
         * @interface IGroupEditMessageResponse
         * @property {proto.Response|null} [response] GroupEditMessageResponse response
         * @property {Long|null} [roomId] GroupEditMessageResponse roomId
         * @property {Long|null} [messageId] GroupEditMessageResponse messageId
         * @property {Long|null} [messageVersion] GroupEditMessageResponse messageVersion
         * @property {string|null} [message] GroupEditMessageResponse message
         * @property {proto.RoomMessageType|null} [messageType] GroupEditMessageResponse messageType
         */

    /**
         * Constructs a new GroupEditMessageResponse.
         * @memberof proto
         * @classdesc Represents a GroupEditMessageResponse.
         * @implements IGroupEditMessageResponse
         * @constructor
         * @param {proto.IGroupEditMessageResponse=} [properties] Properties to set
         */
    function GroupEditMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupEditMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.response = null;

    /**
         * GroupEditMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditMessageResponse messageId.
         * @member {Long} messageId
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditMessageResponse messageVersion.
         * @member {Long} messageVersion
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.messageVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupEditMessageResponse message.
         * @member {string} message
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.message = '';

    /**
         * GroupEditMessageResponse messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.GroupEditMessageResponse
         * @instance
         */
    GroupEditMessageResponse.prototype.messageType = 0;

    /**
         * Creates a new GroupEditMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupEditMessageResponse
         * @static
         * @param {proto.IGroupEditMessageResponse=} [properties] Properties to set
         * @returns {proto.GroupEditMessageResponse} GroupEditMessageResponse instance
         */
    GroupEditMessageResponse.create = function create(properties) {
      return new GroupEditMessageResponse(properties);
    };

    /**
         * Encodes the specified GroupEditMessageResponse message. Does not implicitly {@link proto.GroupEditMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupEditMessageResponse
         * @static
         * @param {proto.GroupEditMessageResponse} message GroupEditMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupEditMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageVersion);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.messageType);}
      return writer;
    };

    /**
         * Decodes a GroupEditMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupEditMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupEditMessageResponse} GroupEditMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupEditMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupEditMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.messageVersion = reader.uint64();
            break;
          case 5:
            message.message = reader.string();
            break;
          case 6:
            message.messageType = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupEditMessageResponse message.
         * @function verify
         * @memberof proto.GroupEditMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupEditMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.messageVersion != null && message.hasOwnProperty('messageVersion')) {
        if (!$util.isInteger(message.messageVersion) && !(message.messageVersion && $util.isInteger(message.messageVersion.low) && $util.isInteger(message.messageVersion.high))) {return 'messageVersion: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      return null;
    };

    return GroupEditMessageResponse;
  })();

  proto.GroupGetDraft = (function() {

    /**
         * Properties of a GroupGetDraft.
         * @memberof proto
         * @interface IGroupGetDraft
         * @property {proto.Request|null} [request] GroupGetDraft request
         * @property {Long|null} [roomId] GroupGetDraft roomId
         */

    /**
         * Constructs a new GroupGetDraft.
         * @memberof proto
         * @classdesc Represents a GroupGetDraft.
         * @implements IGroupGetDraft
         * @constructor
         * @param {proto.IGroupGetDraft=} [properties] Properties to set
         */
    function GroupGetDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupGetDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupGetDraft
         * @instance
         */
    GroupGetDraft.prototype.request = null;

    /**
         * GroupGetDraft roomId.
         * @member {Long} roomId
         * @memberof proto.GroupGetDraft
         * @instance
         */
    GroupGetDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupGetDraft instance using the specified properties.
         * @function create
         * @memberof proto.GroupGetDraft
         * @static
         * @param {proto.IGroupGetDraft=} [properties] Properties to set
         * @returns {proto.GroupGetDraft} GroupGetDraft instance
         */
    GroupGetDraft.create = function create(properties) {
      return new GroupGetDraft(properties);
    };

    /**
         * Encodes the specified GroupGetDraft message. Does not implicitly {@link proto.GroupGetDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupGetDraft
         * @static
         * @param {proto.GroupGetDraft} message GroupGetDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupGetDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupGetDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupGetDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupGetDraft} GroupGetDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupGetDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupGetDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupGetDraft message.
         * @function verify
         * @memberof proto.GroupGetDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupGetDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupGetDraft;
  })();

  proto.GroupGetDraftResponse = (function() {

    /**
         * Properties of a GroupGetDraftResponse.
         * @memberof proto
         * @interface IGroupGetDraftResponse
         * @property {proto.Response|null} [response] GroupGetDraftResponse response
         * @property {proto.RoomDraft|null} [draft] GroupGetDraftResponse draft
         */

    /**
         * Constructs a new GroupGetDraftResponse.
         * @memberof proto
         * @classdesc Represents a GroupGetDraftResponse.
         * @implements IGroupGetDraftResponse
         * @constructor
         * @param {proto.IGroupGetDraftResponse=} [properties] Properties to set
         */
    function GroupGetDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupGetDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupGetDraftResponse
         * @instance
         */
    GroupGetDraftResponse.prototype.response = null;

    /**
         * GroupGetDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.GroupGetDraftResponse
         * @instance
         */
    GroupGetDraftResponse.prototype.draft = null;

    /**
         * Creates a new GroupGetDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupGetDraftResponse
         * @static
         * @param {proto.IGroupGetDraftResponse=} [properties] Properties to set
         * @returns {proto.GroupGetDraftResponse} GroupGetDraftResponse instance
         */
    GroupGetDraftResponse.create = function create(properties) {
      return new GroupGetDraftResponse(properties);
    };

    /**
         * Encodes the specified GroupGetDraftResponse message. Does not implicitly {@link proto.GroupGetDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupGetDraftResponse
         * @static
         * @param {proto.GroupGetDraftResponse} message GroupGetDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupGetDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupGetDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupGetDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupGetDraftResponse} GroupGetDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupGetDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupGetDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupGetDraftResponse message.
         * @function verify
         * @memberof proto.GroupGetDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupGetDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return GroupGetDraftResponse;
  })();

  proto.GroupGetMemberList = (function() {

    /**
         * Properties of a GroupGetMemberList.
         * @memberof proto
         * @interface IGroupGetMemberList
         * @property {proto.Request|null} [request] GroupGetMemberList request
         * @property {Long|null} [roomId] GroupGetMemberList roomId
         * @property {proto.GroupGetMemberList.FilterRole|null} [filterRole] GroupGetMemberList filterRole
         * @property {proto.Pagination|null} [pagination] GroupGetMemberList pagination
         */

    /**
         * Constructs a new GroupGetMemberList.
         * @memberof proto
         * @classdesc Represents a GroupGetMemberList.
         * @implements IGroupGetMemberList
         * @constructor
         * @param {proto.IGroupGetMemberList=} [properties] Properties to set
         */
    function GroupGetMemberList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupGetMemberList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupGetMemberList
         * @instance
         */
    GroupGetMemberList.prototype.request = null;

    /**
         * GroupGetMemberList roomId.
         * @member {Long} roomId
         * @memberof proto.GroupGetMemberList
         * @instance
         */
    GroupGetMemberList.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupGetMemberList filterRole.
         * @member {proto.GroupGetMemberList.FilterRole} filterRole
         * @memberof proto.GroupGetMemberList
         * @instance
         */
    GroupGetMemberList.prototype.filterRole = 0;

    /**
         * GroupGetMemberList pagination.
         * @member {proto.Pagination|null|undefined} pagination
         * @memberof proto.GroupGetMemberList
         * @instance
         */
    GroupGetMemberList.prototype.pagination = null;

    /**
         * Creates a new GroupGetMemberList instance using the specified properties.
         * @function create
         * @memberof proto.GroupGetMemberList
         * @static
         * @param {proto.IGroupGetMemberList=} [properties] Properties to set
         * @returns {proto.GroupGetMemberList} GroupGetMemberList instance
         */
    GroupGetMemberList.create = function create(properties) {
      return new GroupGetMemberList(properties);
    };

    /**
         * Encodes the specified GroupGetMemberList message. Does not implicitly {@link proto.GroupGetMemberList.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupGetMemberList
         * @static
         * @param {proto.GroupGetMemberList} message GroupGetMemberList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupGetMemberList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.filterRole != null && message.hasOwnProperty('filterRole')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterRole);}
      if (message.pagination != null && message.hasOwnProperty('pagination')) {$root.proto.Pagination.encode(message.pagination, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupGetMemberList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupGetMemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupGetMemberList} GroupGetMemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupGetMemberList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupGetMemberList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.filterRole = reader.int32();
            break;
          case 4:
            message.pagination = $root.proto.Pagination.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupGetMemberList message.
         * @function verify
         * @memberof proto.GroupGetMemberList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupGetMemberList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.filterRole != null && message.hasOwnProperty('filterRole')) {
        switch (message.filterRole) {
          default:
            return 'filterRole: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.pagination != null && message.hasOwnProperty('pagination')) {
        let error = $root.proto.Pagination.verify(message.pagination);
        if (error) {return 'pagination.' + error;}
      }
      return null;
    };

    /**
         * FilterRole enum.
         * @name proto.GroupGetMemberList.FilterRole
         * @enum {string}
         * @property {number} ALL=0 ALL value
         * @property {number} MEMBER=1 MEMBER value
         * @property {number} MODERATOR=2 MODERATOR value
         * @property {number} ADMIN=3 ADMIN value
         */
    GroupGetMemberList.FilterRole = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'ALL'] = 0;
      values[valuesById[1] = 'MEMBER'] = 1;
      values[valuesById[2] = 'MODERATOR'] = 2;
      values[valuesById[3] = 'ADMIN'] = 3;
      return values;
    })();

    return GroupGetMemberList;
  })();

  proto.GroupGetMemberListResponse = (function() {

    /**
         * Properties of a GroupGetMemberListResponse.
         * @memberof proto
         * @interface IGroupGetMemberListResponse
         * @property {proto.Response|null} [response] GroupGetMemberListResponse response
         * @property {Array.<proto.GroupGetMemberListResponse.Member>|null} [member] GroupGetMemberListResponse member
         */

    /**
         * Constructs a new GroupGetMemberListResponse.
         * @memberof proto
         * @classdesc Represents a GroupGetMemberListResponse.
         * @implements IGroupGetMemberListResponse
         * @constructor
         * @param {proto.IGroupGetMemberListResponse=} [properties] Properties to set
         */
    function GroupGetMemberListResponse(properties) {
      this.member = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupGetMemberListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupGetMemberListResponse
         * @instance
         */
    GroupGetMemberListResponse.prototype.response = null;

    /**
         * GroupGetMemberListResponse member.
         * @member {Array.<proto.GroupGetMemberListResponse.Member>} member
         * @memberof proto.GroupGetMemberListResponse
         * @instance
         */
    GroupGetMemberListResponse.prototype.member = $util.emptyArray;

    /**
         * Creates a new GroupGetMemberListResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupGetMemberListResponse
         * @static
         * @param {proto.IGroupGetMemberListResponse=} [properties] Properties to set
         * @returns {proto.GroupGetMemberListResponse} GroupGetMemberListResponse instance
         */
    GroupGetMemberListResponse.create = function create(properties) {
      return new GroupGetMemberListResponse(properties);
    };

    /**
         * Encodes the specified GroupGetMemberListResponse message. Does not implicitly {@link proto.GroupGetMemberListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupGetMemberListResponse
         * @static
         * @param {proto.GroupGetMemberListResponse} message GroupGetMemberListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupGetMemberListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.member != null && message.member.length) {
        for (let i = 0; i < message.member.length; ++i) {$root.proto.GroupGetMemberListResponse.Member.encode(message.member[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a GroupGetMemberListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupGetMemberListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupGetMemberListResponse} GroupGetMemberListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupGetMemberListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupGetMemberListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.member && message.member.length)) {message.member = [];}
            message.member.push($root.proto.GroupGetMemberListResponse.Member.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupGetMemberListResponse message.
         * @function verify
         * @memberof proto.GroupGetMemberListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupGetMemberListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.member != null && message.hasOwnProperty('member')) {
        if (!Array.isArray(message.member)) {return 'member: array expected';}
        for (let i = 0; i < message.member.length; ++i) {
          let error = $root.proto.GroupGetMemberListResponse.Member.verify(message.member[i]);
          if (error) {return 'member.' + error;}
        }
      }
      return null;
    };

    GroupGetMemberListResponse.Member = (function() {

      /**
             * Properties of a Member.
             * @memberof proto.GroupGetMemberListResponse
             * @interface IMember
             * @property {Long|null} [userId] Member userId
             * @property {proto.GroupRoom.Role|null} [role] Member role
             */

      /**
             * Constructs a new Member.
             * @memberof proto.GroupGetMemberListResponse
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {proto.GroupGetMemberListResponse.IMember=} [properties] Properties to set
             */
      function Member(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Member userId.
             * @member {Long} userId
             * @memberof proto.GroupGetMemberListResponse.Member
             * @instance
             */
      Member.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Member role.
             * @member {proto.GroupRoom.Role} role
             * @memberof proto.GroupGetMemberListResponse.Member
             * @instance
             */
      Member.prototype.role = 0;

      /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof proto.GroupGetMemberListResponse.Member
             * @static
             * @param {proto.GroupGetMemberListResponse.IMember=} [properties] Properties to set
             * @returns {proto.GroupGetMemberListResponse.Member} Member instance
             */
      Member.create = function create(properties) {
        return new Member(properties);
      };

      /**
             * Encodes the specified Member message. Does not implicitly {@link proto.GroupGetMemberListResponse.Member.verify|verify} messages.
             * @function encode
             * @memberof proto.GroupGetMemberListResponse.Member
             * @static
             * @param {proto.GroupGetMemberListResponse.Member} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Member.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.role != null && message.hasOwnProperty('role')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);}
        return writer;
      };

      /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GroupGetMemberListResponse.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GroupGetMemberListResponse.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Member.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupGetMemberListResponse.Member();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.role = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Member message.
             * @function verify
             * @memberof proto.GroupGetMemberListResponse.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Member.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.role != null && message.hasOwnProperty('role')) {
          switch (message.role) {
            default:
              return 'role: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        }
        return null;
      };

      return Member;
    })();

    return GroupGetMemberListResponse;
  })();

  proto.GroupKickAdmin = (function() {

    /**
         * Properties of a GroupKickAdmin.
         * @memberof proto
         * @interface IGroupKickAdmin
         * @property {proto.Request|null} [request] GroupKickAdmin request
         * @property {Long|null} [roomId] GroupKickAdmin roomId
         * @property {Long|null} [memberId] GroupKickAdmin memberId
         */

    /**
         * Constructs a new GroupKickAdmin.
         * @memberof proto
         * @classdesc Represents a GroupKickAdmin.
         * @implements IGroupKickAdmin
         * @constructor
         * @param {proto.IGroupKickAdmin=} [properties] Properties to set
         */
    function GroupKickAdmin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickAdmin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupKickAdmin
         * @instance
         */
    GroupKickAdmin.prototype.request = null;

    /**
         * GroupKickAdmin roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickAdmin
         * @instance
         */
    GroupKickAdmin.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickAdmin memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickAdmin
         * @instance
         */
    GroupKickAdmin.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickAdmin instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickAdmin
         * @static
         * @param {proto.IGroupKickAdmin=} [properties] Properties to set
         * @returns {proto.GroupKickAdmin} GroupKickAdmin instance
         */
    GroupKickAdmin.create = function create(properties) {
      return new GroupKickAdmin(properties);
    };

    /**
         * Encodes the specified GroupKickAdmin message. Does not implicitly {@link proto.GroupKickAdmin.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickAdmin
         * @static
         * @param {proto.GroupKickAdmin} message GroupKickAdmin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickAdmin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickAdmin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickAdmin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickAdmin} GroupKickAdmin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickAdmin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickAdmin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickAdmin message.
         * @function verify
         * @memberof proto.GroupKickAdmin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickAdmin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickAdmin;
  })();

  proto.GroupKickAdminResponse = (function() {

    /**
         * Properties of a GroupKickAdminResponse.
         * @memberof proto
         * @interface IGroupKickAdminResponse
         * @property {proto.Response|null} [response] GroupKickAdminResponse response
         * @property {Long|null} [roomId] GroupKickAdminResponse roomId
         * @property {Long|null} [memberId] GroupKickAdminResponse memberId
         */

    /**
         * Constructs a new GroupKickAdminResponse.
         * @memberof proto
         * @classdesc Represents a GroupKickAdminResponse.
         * @implements IGroupKickAdminResponse
         * @constructor
         * @param {proto.IGroupKickAdminResponse=} [properties] Properties to set
         */
    function GroupKickAdminResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickAdminResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupKickAdminResponse
         * @instance
         */
    GroupKickAdminResponse.prototype.response = null;

    /**
         * GroupKickAdminResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickAdminResponse
         * @instance
         */
    GroupKickAdminResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickAdminResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickAdminResponse
         * @instance
         */
    GroupKickAdminResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickAdminResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickAdminResponse
         * @static
         * @param {proto.IGroupKickAdminResponse=} [properties] Properties to set
         * @returns {proto.GroupKickAdminResponse} GroupKickAdminResponse instance
         */
    GroupKickAdminResponse.create = function create(properties) {
      return new GroupKickAdminResponse(properties);
    };

    /**
         * Encodes the specified GroupKickAdminResponse message. Does not implicitly {@link proto.GroupKickAdminResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickAdminResponse
         * @static
         * @param {proto.GroupKickAdminResponse} message GroupKickAdminResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickAdminResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickAdminResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickAdminResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickAdminResponse} GroupKickAdminResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickAdminResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickAdminResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickAdminResponse message.
         * @function verify
         * @memberof proto.GroupKickAdminResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickAdminResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickAdminResponse;
  })();

  proto.GroupKickMember = (function() {

    /**
         * Properties of a GroupKickMember.
         * @memberof proto
         * @interface IGroupKickMember
         * @property {proto.Request|null} [request] GroupKickMember request
         * @property {Long|null} [roomId] GroupKickMember roomId
         * @property {Long|null} [memberId] GroupKickMember memberId
         */

    /**
         * Constructs a new GroupKickMember.
         * @memberof proto
         * @classdesc Represents a GroupKickMember.
         * @implements IGroupKickMember
         * @constructor
         * @param {proto.IGroupKickMember=} [properties] Properties to set
         */
    function GroupKickMember(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickMember request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupKickMember
         * @instance
         */
    GroupKickMember.prototype.request = null;

    /**
         * GroupKickMember roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickMember
         * @instance
         */
    GroupKickMember.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickMember memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickMember
         * @instance
         */
    GroupKickMember.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickMember instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickMember
         * @static
         * @param {proto.IGroupKickMember=} [properties] Properties to set
         * @returns {proto.GroupKickMember} GroupKickMember instance
         */
    GroupKickMember.create = function create(properties) {
      return new GroupKickMember(properties);
    };

    /**
         * Encodes the specified GroupKickMember message. Does not implicitly {@link proto.GroupKickMember.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickMember
         * @static
         * @param {proto.GroupKickMember} message GroupKickMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickMember.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickMember message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickMember} GroupKickMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickMember.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickMember();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickMember message.
         * @function verify
         * @memberof proto.GroupKickMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickMember.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickMember;
  })();

  proto.GroupKickMemberResponse = (function() {

    /**
         * Properties of a GroupKickMemberResponse.
         * @memberof proto
         * @interface IGroupKickMemberResponse
         * @property {proto.Response|null} [response] GroupKickMemberResponse response
         * @property {Long|null} [roomId] GroupKickMemberResponse roomId
         * @property {Long|null} [memberId] GroupKickMemberResponse memberId
         */

    /**
         * Constructs a new GroupKickMemberResponse.
         * @memberof proto
         * @classdesc Represents a GroupKickMemberResponse.
         * @implements IGroupKickMemberResponse
         * @constructor
         * @param {proto.IGroupKickMemberResponse=} [properties] Properties to set
         */
    function GroupKickMemberResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickMemberResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupKickMemberResponse
         * @instance
         */
    GroupKickMemberResponse.prototype.response = null;

    /**
         * GroupKickMemberResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickMemberResponse
         * @instance
         */
    GroupKickMemberResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickMemberResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickMemberResponse
         * @instance
         */
    GroupKickMemberResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickMemberResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickMemberResponse
         * @static
         * @param {proto.IGroupKickMemberResponse=} [properties] Properties to set
         * @returns {proto.GroupKickMemberResponse} GroupKickMemberResponse instance
         */
    GroupKickMemberResponse.create = function create(properties) {
      return new GroupKickMemberResponse(properties);
    };

    /**
         * Encodes the specified GroupKickMemberResponse message. Does not implicitly {@link proto.GroupKickMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickMemberResponse
         * @static
         * @param {proto.GroupKickMemberResponse} message GroupKickMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickMemberResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickMemberResponse} GroupKickMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickMemberResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickMemberResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickMemberResponse message.
         * @function verify
         * @memberof proto.GroupKickMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickMemberResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickMemberResponse;
  })();

  proto.GroupKickModerator = (function() {

    /**
         * Properties of a GroupKickModerator.
         * @memberof proto
         * @interface IGroupKickModerator
         * @property {proto.Request|null} [request] GroupKickModerator request
         * @property {Long|null} [roomId] GroupKickModerator roomId
         * @property {Long|null} [memberId] GroupKickModerator memberId
         */

    /**
         * Constructs a new GroupKickModerator.
         * @memberof proto
         * @classdesc Represents a GroupKickModerator.
         * @implements IGroupKickModerator
         * @constructor
         * @param {proto.IGroupKickModerator=} [properties] Properties to set
         */
    function GroupKickModerator(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickModerator request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupKickModerator
         * @instance
         */
    GroupKickModerator.prototype.request = null;

    /**
         * GroupKickModerator roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickModerator
         * @instance
         */
    GroupKickModerator.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickModerator memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickModerator
         * @instance
         */
    GroupKickModerator.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickModerator instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickModerator
         * @static
         * @param {proto.IGroupKickModerator=} [properties] Properties to set
         * @returns {proto.GroupKickModerator} GroupKickModerator instance
         */
    GroupKickModerator.create = function create(properties) {
      return new GroupKickModerator(properties);
    };

    /**
         * Encodes the specified GroupKickModerator message. Does not implicitly {@link proto.GroupKickModerator.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickModerator
         * @static
         * @param {proto.GroupKickModerator} message GroupKickModerator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickModerator.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickModerator message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickModerator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickModerator} GroupKickModerator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickModerator.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickModerator();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickModerator message.
         * @function verify
         * @memberof proto.GroupKickModerator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickModerator.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickModerator;
  })();

  proto.GroupKickModeratorResponse = (function() {

    /**
         * Properties of a GroupKickModeratorResponse.
         * @memberof proto
         * @interface IGroupKickModeratorResponse
         * @property {proto.Response|null} [response] GroupKickModeratorResponse response
         * @property {Long|null} [roomId] GroupKickModeratorResponse roomId
         * @property {Long|null} [memberId] GroupKickModeratorResponse memberId
         */

    /**
         * Constructs a new GroupKickModeratorResponse.
         * @memberof proto
         * @classdesc Represents a GroupKickModeratorResponse.
         * @implements IGroupKickModeratorResponse
         * @constructor
         * @param {proto.IGroupKickModeratorResponse=} [properties] Properties to set
         */
    function GroupKickModeratorResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupKickModeratorResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupKickModeratorResponse
         * @instance
         */
    GroupKickModeratorResponse.prototype.response = null;

    /**
         * GroupKickModeratorResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupKickModeratorResponse
         * @instance
         */
    GroupKickModeratorResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupKickModeratorResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupKickModeratorResponse
         * @instance
         */
    GroupKickModeratorResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupKickModeratorResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupKickModeratorResponse
         * @static
         * @param {proto.IGroupKickModeratorResponse=} [properties] Properties to set
         * @returns {proto.GroupKickModeratorResponse} GroupKickModeratorResponse instance
         */
    GroupKickModeratorResponse.create = function create(properties) {
      return new GroupKickModeratorResponse(properties);
    };

    /**
         * Encodes the specified GroupKickModeratorResponse message. Does not implicitly {@link proto.GroupKickModeratorResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupKickModeratorResponse
         * @static
         * @param {proto.GroupKickModeratorResponse} message GroupKickModeratorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupKickModeratorResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupKickModeratorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupKickModeratorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupKickModeratorResponse} GroupKickModeratorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupKickModeratorResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupKickModeratorResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupKickModeratorResponse message.
         * @function verify
         * @memberof proto.GroupKickModeratorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupKickModeratorResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupKickModeratorResponse;
  })();

  proto.GroupLeft = (function() {

    /**
         * Properties of a GroupLeft.
         * @memberof proto
         * @interface IGroupLeft
         * @property {proto.Request|null} [request] GroupLeft request
         * @property {Long|null} [roomId] GroupLeft roomId
         */

    /**
         * Constructs a new GroupLeft.
         * @memberof proto
         * @classdesc Represents a GroupLeft.
         * @implements IGroupLeft
         * @constructor
         * @param {proto.IGroupLeft=} [properties] Properties to set
         */
    function GroupLeft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupLeft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupLeft
         * @instance
         */
    GroupLeft.prototype.request = null;

    /**
         * GroupLeft roomId.
         * @member {Long} roomId
         * @memberof proto.GroupLeft
         * @instance
         */
    GroupLeft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupLeft instance using the specified properties.
         * @function create
         * @memberof proto.GroupLeft
         * @static
         * @param {proto.IGroupLeft=} [properties] Properties to set
         * @returns {proto.GroupLeft} GroupLeft instance
         */
    GroupLeft.create = function create(properties) {
      return new GroupLeft(properties);
    };

    /**
         * Encodes the specified GroupLeft message. Does not implicitly {@link proto.GroupLeft.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupLeft
         * @static
         * @param {proto.GroupLeft} message GroupLeft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupLeft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupLeft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupLeft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupLeft} GroupLeft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupLeft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupLeft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupLeft message.
         * @function verify
         * @memberof proto.GroupLeft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupLeft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupLeft;
  })();

  proto.GroupLeftResponse = (function() {

    /**
         * Properties of a GroupLeftResponse.
         * @memberof proto
         * @interface IGroupLeftResponse
         * @property {proto.Response|null} [response] GroupLeftResponse response
         * @property {Long|null} [roomId] GroupLeftResponse roomId
         * @property {Long|null} [memberId] GroupLeftResponse memberId
         */

    /**
         * Constructs a new GroupLeftResponse.
         * @memberof proto
         * @classdesc Represents a GroupLeftResponse.
         * @implements IGroupLeftResponse
         * @constructor
         * @param {proto.IGroupLeftResponse=} [properties] Properties to set
         */
    function GroupLeftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupLeftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupLeftResponse
         * @instance
         */
    GroupLeftResponse.prototype.response = null;

    /**
         * GroupLeftResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupLeftResponse
         * @instance
         */
    GroupLeftResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupLeftResponse memberId.
         * @member {Long} memberId
         * @memberof proto.GroupLeftResponse
         * @instance
         */
    GroupLeftResponse.prototype.memberId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupLeftResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupLeftResponse
         * @static
         * @param {proto.IGroupLeftResponse=} [properties] Properties to set
         * @returns {proto.GroupLeftResponse} GroupLeftResponse instance
         */
    GroupLeftResponse.create = function create(properties) {
      return new GroupLeftResponse(properties);
    };

    /**
         * Encodes the specified GroupLeftResponse message. Does not implicitly {@link proto.GroupLeftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupLeftResponse
         * @static
         * @param {proto.GroupLeftResponse} message GroupLeftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupLeftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.memberId != null && message.hasOwnProperty('memberId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memberId);}
      return writer;
    };

    /**
         * Decodes a GroupLeftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupLeftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupLeftResponse} GroupLeftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupLeftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupLeftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.memberId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupLeftResponse message.
         * @function verify
         * @memberof proto.GroupLeftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupLeftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.memberId != null && message.hasOwnProperty('memberId')) {
        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high))) {return 'memberId: integer|Long expected';}
      }
      return null;
    };

    return GroupLeftResponse;
  })();

  proto.GroupPinMessage = (function() {

    /**
         * Properties of a GroupPinMessage.
         * @memberof proto
         * @interface IGroupPinMessage
         * @property {proto.Request|null} [request] GroupPinMessage request
         * @property {Long|null} [roomId] GroupPinMessage roomId
         * @property {Long|null} [messageId] GroupPinMessage messageId
         */

    /**
         * Constructs a new GroupPinMessage.
         * @memberof proto
         * @classdesc Represents a GroupPinMessage.
         * @implements IGroupPinMessage
         * @constructor
         * @param {proto.IGroupPinMessage=} [properties] Properties to set
         */
    function GroupPinMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupPinMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupPinMessage
         * @instance
         */
    GroupPinMessage.prototype.request = null;

    /**
         * GroupPinMessage roomId.
         * @member {Long} roomId
         * @memberof proto.GroupPinMessage
         * @instance
         */
    GroupPinMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupPinMessage messageId.
         * @member {Long} messageId
         * @memberof proto.GroupPinMessage
         * @instance
         */
    GroupPinMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupPinMessage instance using the specified properties.
         * @function create
         * @memberof proto.GroupPinMessage
         * @static
         * @param {proto.IGroupPinMessage=} [properties] Properties to set
         * @returns {proto.GroupPinMessage} GroupPinMessage instance
         */
    GroupPinMessage.create = function create(properties) {
      return new GroupPinMessage(properties);
    };

    /**
         * Encodes the specified GroupPinMessage message. Does not implicitly {@link proto.GroupPinMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupPinMessage
         * @static
         * @param {proto.GroupPinMessage} message GroupPinMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupPinMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a GroupPinMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupPinMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupPinMessage} GroupPinMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupPinMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupPinMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupPinMessage message.
         * @function verify
         * @memberof proto.GroupPinMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupPinMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return GroupPinMessage;
  })();

  proto.GroupPinMessageResponse = (function() {

    /**
         * Properties of a GroupPinMessageResponse.
         * @memberof proto
         * @interface IGroupPinMessageResponse
         * @property {proto.Response|null} [response] GroupPinMessageResponse response
         * @property {Long|null} [roomId] GroupPinMessageResponse roomId
         * @property {proto.RoomMessage|null} [pinnedMessage] GroupPinMessageResponse pinnedMessage
         */

    /**
         * Constructs a new GroupPinMessageResponse.
         * @memberof proto
         * @classdesc Represents a GroupPinMessageResponse.
         * @implements IGroupPinMessageResponse
         * @constructor
         * @param {proto.IGroupPinMessageResponse=} [properties] Properties to set
         */
    function GroupPinMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupPinMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupPinMessageResponse
         * @instance
         */
    GroupPinMessageResponse.prototype.response = null;

    /**
         * GroupPinMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupPinMessageResponse
         * @instance
         */
    GroupPinMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupPinMessageResponse pinnedMessage.
         * @member {proto.RoomMessage|null|undefined} pinnedMessage
         * @memberof proto.GroupPinMessageResponse
         * @instance
         */
    GroupPinMessageResponse.prototype.pinnedMessage = null;

    /**
         * Creates a new GroupPinMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupPinMessageResponse
         * @static
         * @param {proto.IGroupPinMessageResponse=} [properties] Properties to set
         * @returns {proto.GroupPinMessageResponse} GroupPinMessageResponse instance
         */
    GroupPinMessageResponse.create = function create(properties) {
      return new GroupPinMessageResponse(properties);
    };

    /**
         * Encodes the specified GroupPinMessageResponse message. Does not implicitly {@link proto.GroupPinMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupPinMessageResponse
         * @static
         * @param {proto.GroupPinMessageResponse} message GroupPinMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupPinMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {$root.proto.RoomMessage.encode(message.pinnedMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupPinMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupPinMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupPinMessageResponse} GroupPinMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupPinMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupPinMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.pinnedMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupPinMessageResponse message.
         * @function verify
         * @memberof proto.GroupPinMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupPinMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.pinnedMessage != null && message.hasOwnProperty('pinnedMessage')) {
        let error = $root.proto.RoomMessage.verify(message.pinnedMessage);
        if (error) {return 'pinnedMessage.' + error;}
      }
      return null;
    };

    return GroupPinMessageResponse;
  })();

  proto.GroupRemoveUsername = (function() {

    /**
         * Properties of a GroupRemoveUsername.
         * @memberof proto
         * @interface IGroupRemoveUsername
         * @property {proto.Request|null} [request] GroupRemoveUsername request
         * @property {Long|null} [roomId] GroupRemoveUsername roomId
         */

    /**
         * Constructs a new GroupRemoveUsername.
         * @memberof proto
         * @classdesc Represents a GroupRemoveUsername.
         * @implements IGroupRemoveUsername
         * @constructor
         * @param {proto.IGroupRemoveUsername=} [properties] Properties to set
         */
    function GroupRemoveUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupRemoveUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupRemoveUsername
         * @instance
         */
    GroupRemoveUsername.prototype.request = null;

    /**
         * GroupRemoveUsername roomId.
         * @member {Long} roomId
         * @memberof proto.GroupRemoveUsername
         * @instance
         */
    GroupRemoveUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupRemoveUsername instance using the specified properties.
         * @function create
         * @memberof proto.GroupRemoveUsername
         * @static
         * @param {proto.IGroupRemoveUsername=} [properties] Properties to set
         * @returns {proto.GroupRemoveUsername} GroupRemoveUsername instance
         */
    GroupRemoveUsername.create = function create(properties) {
      return new GroupRemoveUsername(properties);
    };

    /**
         * Encodes the specified GroupRemoveUsername message. Does not implicitly {@link proto.GroupRemoveUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupRemoveUsername
         * @static
         * @param {proto.GroupRemoveUsername} message GroupRemoveUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupRemoveUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupRemoveUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupRemoveUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupRemoveUsername} GroupRemoveUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupRemoveUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRemoveUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupRemoveUsername message.
         * @function verify
         * @memberof proto.GroupRemoveUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupRemoveUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupRemoveUsername;
  })();

  proto.GroupRemoveUsernameResponse = (function() {

    /**
         * Properties of a GroupRemoveUsernameResponse.
         * @memberof proto
         * @interface IGroupRemoveUsernameResponse
         * @property {proto.Response|null} [response] GroupRemoveUsernameResponse response
         * @property {Long|null} [roomId] GroupRemoveUsernameResponse roomId
         */

    /**
         * Constructs a new GroupRemoveUsernameResponse.
         * @memberof proto
         * @classdesc Represents a GroupRemoveUsernameResponse.
         * @implements IGroupRemoveUsernameResponse
         * @constructor
         * @param {proto.IGroupRemoveUsernameResponse=} [properties] Properties to set
         */
    function GroupRemoveUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupRemoveUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupRemoveUsernameResponse
         * @instance
         */
    GroupRemoveUsernameResponse.prototype.response = null;

    /**
         * GroupRemoveUsernameResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupRemoveUsernameResponse
         * @instance
         */
    GroupRemoveUsernameResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupRemoveUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupRemoveUsernameResponse
         * @static
         * @param {proto.IGroupRemoveUsernameResponse=} [properties] Properties to set
         * @returns {proto.GroupRemoveUsernameResponse} GroupRemoveUsernameResponse instance
         */
    GroupRemoveUsernameResponse.create = function create(properties) {
      return new GroupRemoveUsernameResponse(properties);
    };

    /**
         * Encodes the specified GroupRemoveUsernameResponse message. Does not implicitly {@link proto.GroupRemoveUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupRemoveUsernameResponse
         * @static
         * @param {proto.GroupRemoveUsernameResponse} message GroupRemoveUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupRemoveUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupRemoveUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupRemoveUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupRemoveUsernameResponse} GroupRemoveUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupRemoveUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRemoveUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupRemoveUsernameResponse message.
         * @function verify
         * @memberof proto.GroupRemoveUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupRemoveUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupRemoveUsernameResponse;
  })();

  proto.GroupRevokeLink = (function() {

    /**
         * Properties of a GroupRevokeLink.
         * @memberof proto
         * @interface IGroupRevokeLink
         * @property {proto.Request|null} [request] GroupRevokeLink request
         * @property {Long|null} [roomId] GroupRevokeLink roomId
         */

    /**
         * Constructs a new GroupRevokeLink.
         * @memberof proto
         * @classdesc Represents a GroupRevokeLink.
         * @implements IGroupRevokeLink
         * @constructor
         * @param {proto.IGroupRevokeLink=} [properties] Properties to set
         */
    function GroupRevokeLink(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupRevokeLink request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupRevokeLink
         * @instance
         */
    GroupRevokeLink.prototype.request = null;

    /**
         * GroupRevokeLink roomId.
         * @member {Long} roomId
         * @memberof proto.GroupRevokeLink
         * @instance
         */
    GroupRevokeLink.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupRevokeLink instance using the specified properties.
         * @function create
         * @memberof proto.GroupRevokeLink
         * @static
         * @param {proto.IGroupRevokeLink=} [properties] Properties to set
         * @returns {proto.GroupRevokeLink} GroupRevokeLink instance
         */
    GroupRevokeLink.create = function create(properties) {
      return new GroupRevokeLink(properties);
    };

    /**
         * Encodes the specified GroupRevokeLink message. Does not implicitly {@link proto.GroupRevokeLink.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupRevokeLink
         * @static
         * @param {proto.GroupRevokeLink} message GroupRevokeLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupRevokeLink.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupRevokeLink message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupRevokeLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupRevokeLink} GroupRevokeLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupRevokeLink.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRevokeLink();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupRevokeLink message.
         * @function verify
         * @memberof proto.GroupRevokeLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupRevokeLink.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupRevokeLink;
  })();

  proto.GroupRevokeLinkResponse = (function() {

    /**
         * Properties of a GroupRevokeLinkResponse.
         * @memberof proto
         * @interface IGroupRevokeLinkResponse
         * @property {proto.Response|null} [response] GroupRevokeLinkResponse response
         * @property {Long|null} [roomId] GroupRevokeLinkResponse roomId
         * @property {string|null} [inviteLink] GroupRevokeLinkResponse inviteLink
         * @property {string|null} [inviteToken] GroupRevokeLinkResponse inviteToken
         */

    /**
         * Constructs a new GroupRevokeLinkResponse.
         * @memberof proto
         * @classdesc Represents a GroupRevokeLinkResponse.
         * @implements IGroupRevokeLinkResponse
         * @constructor
         * @param {proto.IGroupRevokeLinkResponse=} [properties] Properties to set
         */
    function GroupRevokeLinkResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupRevokeLinkResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupRevokeLinkResponse
         * @instance
         */
    GroupRevokeLinkResponse.prototype.response = null;

    /**
         * GroupRevokeLinkResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupRevokeLinkResponse
         * @instance
         */
    GroupRevokeLinkResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupRevokeLinkResponse inviteLink.
         * @member {string} inviteLink
         * @memberof proto.GroupRevokeLinkResponse
         * @instance
         */
    GroupRevokeLinkResponse.prototype.inviteLink = '';

    /**
         * GroupRevokeLinkResponse inviteToken.
         * @member {string} inviteToken
         * @memberof proto.GroupRevokeLinkResponse
         * @instance
         */
    GroupRevokeLinkResponse.prototype.inviteToken = '';

    /**
         * Creates a new GroupRevokeLinkResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupRevokeLinkResponse
         * @static
         * @param {proto.IGroupRevokeLinkResponse=} [properties] Properties to set
         * @returns {proto.GroupRevokeLinkResponse} GroupRevokeLinkResponse instance
         */
    GroupRevokeLinkResponse.create = function create(properties) {
      return new GroupRevokeLinkResponse(properties);
    };

    /**
         * Encodes the specified GroupRevokeLinkResponse message. Does not implicitly {@link proto.GroupRevokeLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupRevokeLinkResponse
         * @static
         * @param {proto.GroupRevokeLinkResponse} message GroupRevokeLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupRevokeLinkResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.inviteLink);}
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.inviteToken);}
      return writer;
    };

    /**
         * Decodes a GroupRevokeLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupRevokeLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupRevokeLinkResponse} GroupRevokeLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupRevokeLinkResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupRevokeLinkResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.inviteLink = reader.string();
            break;
          case 4:
            message.inviteToken = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupRevokeLinkResponse message.
         * @function verify
         * @memberof proto.GroupRevokeLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupRevokeLinkResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.inviteLink != null && message.hasOwnProperty('inviteLink')) {
        if (!$util.isString(message.inviteLink)) {return 'inviteLink: string expected';}
      }
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
        if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
      }
      return null;
    };

    return GroupRevokeLinkResponse;
  })();

  proto.GroupSendMessage = (function() {

    /**
         * Properties of a GroupSendMessage.
         * @memberof proto
         * @interface IGroupSendMessage
         * @property {proto.Request|null} [request] GroupSendMessage request
         * @property {proto.RoomMessageType|null} [messageType] GroupSendMessage messageType
         * @property {Long|null} [roomId] GroupSendMessage roomId
         * @property {string|null} [message] GroupSendMessage message
         * @property {string|null} [attachment] GroupSendMessage attachment
         * @property {proto.RoomMessageLocation|null} [location] GroupSendMessage location
         * @property {proto.RoomMessageContact|null} [contact] GroupSendMessage contact
         * @property {Long|null} [replyTo] GroupSendMessage replyTo
         * @property {proto.RoomMessageForwardFrom|null} [forwardFrom] GroupSendMessage forwardFrom
         * @property {Long|null} [randomId] GroupSendMessage randomId
         */

    /**
         * Constructs a new GroupSendMessage.
         * @memberof proto
         * @classdesc Represents a GroupSendMessage.
         * @implements IGroupSendMessage
         * @constructor
         * @param {proto.IGroupSendMessage=} [properties] Properties to set
         */
    function GroupSendMessage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupSendMessage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.request = null;

    /**
         * GroupSendMessage messageType.
         * @member {proto.RoomMessageType} messageType
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.messageType = 0;

    /**
         * GroupSendMessage roomId.
         * @member {Long} roomId
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupSendMessage message.
         * @member {string} message
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.message = '';

    /**
         * GroupSendMessage attachment.
         * @member {string} attachment
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.attachment = '';

    /**
         * GroupSendMessage location.
         * @member {proto.RoomMessageLocation|null|undefined} location
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.location = null;

    /**
         * GroupSendMessage contact.
         * @member {proto.RoomMessageContact|null|undefined} contact
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.contact = null;

    /**
         * GroupSendMessage replyTo.
         * @member {Long} replyTo
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.replyTo = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupSendMessage forwardFrom.
         * @member {proto.RoomMessageForwardFrom|null|undefined} forwardFrom
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.forwardFrom = null;

    /**
         * GroupSendMessage randomId.
         * @member {Long} randomId
         * @memberof proto.GroupSendMessage
         * @instance
         */
    GroupSendMessage.prototype.randomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupSendMessage instance using the specified properties.
         * @function create
         * @memberof proto.GroupSendMessage
         * @static
         * @param {proto.IGroupSendMessage=} [properties] Properties to set
         * @returns {proto.GroupSendMessage} GroupSendMessage instance
         */
    GroupSendMessage.create = function create(properties) {
      return new GroupSendMessage(properties);
    };

    /**
         * Encodes the specified GroupSendMessage message. Does not implicitly {@link proto.GroupSendMessage.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupSendMessage
         * @static
         * @param {proto.GroupSendMessage} message GroupSendMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupSendMessage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.messageType != null && message.hasOwnProperty('messageType')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messageType);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      if (message.message != null && message.hasOwnProperty('message')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.attachment);}
      if (message.location != null && message.hasOwnProperty('location')) {$root.proto.RoomMessageLocation.encode(message.location, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();}
      if (message.contact != null && message.hasOwnProperty('contact')) {$root.proto.RoomMessageContact.encode(message.contact, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();}
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.replyTo);}
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {$root.proto.RoomMessageForwardFrom.encode(message.forwardFrom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();}
      if (message.randomId != null && message.hasOwnProperty('randomId')) {writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.randomId);}
      return writer;
    };

    /**
         * Decodes a GroupSendMessage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupSendMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupSendMessage} GroupSendMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupSendMessage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupSendMessage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.messageType = reader.int32();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          case 4:
            message.message = reader.string();
            break;
          case 5:
            message.attachment = reader.string();
            break;
          case 6:
            message.location = $root.proto.RoomMessageLocation.decode(reader, reader.uint32());
            break;
          case 7:
            message.contact = $root.proto.RoomMessageContact.decode(reader, reader.uint32());
            break;
          case 8:
            message.replyTo = reader.uint64();
            break;
          case 9:
            message.forwardFrom = $root.proto.RoomMessageForwardFrom.decode(reader, reader.uint32());
            break;
          case 10:
            message.randomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupSendMessage message.
         * @function verify
         * @memberof proto.GroupSendMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupSendMessage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.messageType != null && message.hasOwnProperty('messageType')) {
        switch (message.messageType) {
          default:
            return 'messageType: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 14:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
            break;
        }
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.message != null && message.hasOwnProperty('message')) {
        if (!$util.isString(message.message)) {return 'message: string expected';}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      if (message.location != null && message.hasOwnProperty('location')) {
        let error = $root.proto.RoomMessageLocation.verify(message.location);
        if (error) {return 'location.' + error;}
      }
      if (message.contact != null && message.hasOwnProperty('contact')) {
        let error = $root.proto.RoomMessageContact.verify(message.contact);
        if (error) {return 'contact.' + error;}
      }
      if (message.replyTo != null && message.hasOwnProperty('replyTo')) {
        if (!$util.isInteger(message.replyTo) && !(message.replyTo && $util.isInteger(message.replyTo.low) && $util.isInteger(message.replyTo.high))) {return 'replyTo: integer|Long expected';}
      }
      if (message.forwardFrom != null && message.hasOwnProperty('forwardFrom')) {
        let error = $root.proto.RoomMessageForwardFrom.verify(message.forwardFrom);
        if (error) {return 'forwardFrom.' + error;}
      }
      if (message.randomId != null && message.hasOwnProperty('randomId')) {
        if (!$util.isInteger(message.randomId) && !(message.randomId && $util.isInteger(message.randomId.low) && $util.isInteger(message.randomId.high))) {return 'randomId: integer|Long expected';}
      }
      return null;
    };

    return GroupSendMessage;
  })();

  proto.GroupSendMessageResponse = (function() {

    /**
         * Properties of a GroupSendMessageResponse.
         * @memberof proto
         * @interface IGroupSendMessageResponse
         * @property {proto.Response|null} [response] GroupSendMessageResponse response
         * @property {Long|null} [roomId] GroupSendMessageResponse roomId
         * @property {proto.RoomMessage|null} [roomMessage] GroupSendMessageResponse roomMessage
         */

    /**
         * Constructs a new GroupSendMessageResponse.
         * @memberof proto
         * @classdesc Represents a GroupSendMessageResponse.
         * @implements IGroupSendMessageResponse
         * @constructor
         * @param {proto.IGroupSendMessageResponse=} [properties] Properties to set
         */
    function GroupSendMessageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupSendMessageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupSendMessageResponse
         * @instance
         */
    GroupSendMessageResponse.prototype.response = null;

    /**
         * GroupSendMessageResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupSendMessageResponse
         * @instance
         */
    GroupSendMessageResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupSendMessageResponse roomMessage.
         * @member {proto.RoomMessage|null|undefined} roomMessage
         * @memberof proto.GroupSendMessageResponse
         * @instance
         */
    GroupSendMessageResponse.prototype.roomMessage = null;

    /**
         * Creates a new GroupSendMessageResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupSendMessageResponse
         * @static
         * @param {proto.IGroupSendMessageResponse=} [properties] Properties to set
         * @returns {proto.GroupSendMessageResponse} GroupSendMessageResponse instance
         */
    GroupSendMessageResponse.create = function create(properties) {
      return new GroupSendMessageResponse(properties);
    };

    /**
         * Encodes the specified GroupSendMessageResponse message. Does not implicitly {@link proto.GroupSendMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupSendMessageResponse
         * @static
         * @param {proto.GroupSendMessageResponse} message GroupSendMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupSendMessageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {$root.proto.RoomMessage.encode(message.roomMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupSendMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupSendMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupSendMessageResponse} GroupSendMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupSendMessageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupSendMessageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.roomMessage = $root.proto.RoomMessage.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupSendMessageResponse message.
         * @function verify
         * @memberof proto.GroupSendMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupSendMessageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.roomMessage != null && message.hasOwnProperty('roomMessage')) {
        let error = $root.proto.RoomMessage.verify(message.roomMessage);
        if (error) {return 'roomMessage.' + error;}
      }
      return null;
    };

    return GroupSendMessageResponse;
  })();

  proto.GroupSetAction = (function() {

    /**
         * Properties of a GroupSetAction.
         * @memberof proto
         * @interface IGroupSetAction
         * @property {proto.Request|null} [request] GroupSetAction request
         * @property {Long|null} [roomId] GroupSetAction roomId
         * @property {proto.ClientAction|null} [action] GroupSetAction action
         * @property {number|null} [actionId] GroupSetAction actionId
         */

    /**
         * Constructs a new GroupSetAction.
         * @memberof proto
         * @classdesc Represents a GroupSetAction.
         * @implements IGroupSetAction
         * @constructor
         * @param {proto.IGroupSetAction=} [properties] Properties to set
         */
    function GroupSetAction(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupSetAction request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupSetAction
         * @instance
         */
    GroupSetAction.prototype.request = null;

    /**
         * GroupSetAction roomId.
         * @member {Long} roomId
         * @memberof proto.GroupSetAction
         * @instance
         */
    GroupSetAction.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupSetAction action.
         * @member {proto.ClientAction} action
         * @memberof proto.GroupSetAction
         * @instance
         */
    GroupSetAction.prototype.action = 0;

    /**
         * GroupSetAction actionId.
         * @member {number} actionId
         * @memberof proto.GroupSetAction
         * @instance
         */
    GroupSetAction.prototype.actionId = 0;

    /**
         * Creates a new GroupSetAction instance using the specified properties.
         * @function create
         * @memberof proto.GroupSetAction
         * @static
         * @param {proto.IGroupSetAction=} [properties] Properties to set
         * @returns {proto.GroupSetAction} GroupSetAction instance
         */
    GroupSetAction.create = function create(properties) {
      return new GroupSetAction(properties);
    };

    /**
         * Encodes the specified GroupSetAction message. Does not implicitly {@link proto.GroupSetAction.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupSetAction
         * @static
         * @param {proto.GroupSetAction} message GroupSetAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupSetAction.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.actionId != null && message.hasOwnProperty('actionId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.actionId);}
      return writer;
    };

    /**
         * Decodes a GroupSetAction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupSetAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupSetAction} GroupSetAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupSetAction.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupSetAction();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.actionId = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupSetAction message.
         * @function verify
         * @memberof proto.GroupSetAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupSetAction.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.actionId != null && message.hasOwnProperty('actionId')) {
        if (!$util.isInteger(message.actionId)) {return 'actionId: integer expected';}
      }
      return null;
    };

    return GroupSetAction;
  })();

  proto.GroupSetActionResponse = (function() {

    /**
         * Properties of a GroupSetActionResponse.
         * @memberof proto
         * @interface IGroupSetActionResponse
         * @property {proto.Response|null} [response] GroupSetActionResponse response
         * @property {Long|null} [roomId] GroupSetActionResponse roomId
         * @property {proto.ClientAction|null} [action] GroupSetActionResponse action
         * @property {Long|null} [userId] GroupSetActionResponse userId
         */

    /**
         * Constructs a new GroupSetActionResponse.
         * @memberof proto
         * @classdesc Represents a GroupSetActionResponse.
         * @implements IGroupSetActionResponse
         * @constructor
         * @param {proto.IGroupSetActionResponse=} [properties] Properties to set
         */
    function GroupSetActionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupSetActionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupSetActionResponse
         * @instance
         */
    GroupSetActionResponse.prototype.response = null;

    /**
         * GroupSetActionResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupSetActionResponse
         * @instance
         */
    GroupSetActionResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupSetActionResponse action.
         * @member {proto.ClientAction} action
         * @memberof proto.GroupSetActionResponse
         * @instance
         */
    GroupSetActionResponse.prototype.action = 0;

    /**
         * GroupSetActionResponse userId.
         * @member {Long} userId
         * @memberof proto.GroupSetActionResponse
         * @instance
         */
    GroupSetActionResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupSetActionResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupSetActionResponse
         * @static
         * @param {proto.IGroupSetActionResponse=} [properties] Properties to set
         * @returns {proto.GroupSetActionResponse} GroupSetActionResponse instance
         */
    GroupSetActionResponse.create = function create(properties) {
      return new GroupSetActionResponse(properties);
    };

    /**
         * Encodes the specified GroupSetActionResponse message. Does not implicitly {@link proto.GroupSetActionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupSetActionResponse
         * @static
         * @param {proto.GroupSetActionResponse} message GroupSetActionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupSetActionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.action != null && message.hasOwnProperty('action')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a GroupSetActionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupSetActionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupSetActionResponse} GroupSetActionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupSetActionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupSetActionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.action = reader.int32();
            break;
          case 4:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupSetActionResponse message.
         * @function verify
         * @memberof proto.GroupSetActionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupSetActionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.action != null && message.hasOwnProperty('action')) {
        switch (message.action) {
          default:
            return 'action: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
        }
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return GroupSetActionResponse;
  })();

  proto.GroupUpdateDraft = (function() {

    /**
         * Properties of a GroupUpdateDraft.
         * @memberof proto
         * @interface IGroupUpdateDraft
         * @property {proto.Request|null} [request] GroupUpdateDraft request
         * @property {Long|null} [roomId] GroupUpdateDraft roomId
         * @property {proto.RoomDraft|null} [draft] GroupUpdateDraft draft
         */

    /**
         * Constructs a new GroupUpdateDraft.
         * @memberof proto
         * @classdesc Represents a GroupUpdateDraft.
         * @implements IGroupUpdateDraft
         * @constructor
         * @param {proto.IGroupUpdateDraft=} [properties] Properties to set
         */
    function GroupUpdateDraft(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateDraft request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupUpdateDraft
         * @instance
         */
    GroupUpdateDraft.prototype.request = null;

    /**
         * GroupUpdateDraft roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateDraft
         * @instance
         */
    GroupUpdateDraft.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateDraft draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.GroupUpdateDraft
         * @instance
         */
    GroupUpdateDraft.prototype.draft = null;

    /**
         * Creates a new GroupUpdateDraft instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateDraft
         * @static
         * @param {proto.IGroupUpdateDraft=} [properties] Properties to set
         * @returns {proto.GroupUpdateDraft} GroupUpdateDraft instance
         */
    GroupUpdateDraft.create = function create(properties) {
      return new GroupUpdateDraft(properties);
    };

    /**
         * Encodes the specified GroupUpdateDraft message. Does not implicitly {@link proto.GroupUpdateDraft.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateDraft
         * @static
         * @param {proto.GroupUpdateDraft} message GroupUpdateDraft message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateDraft.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupUpdateDraft message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateDraft
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateDraft} GroupUpdateDraft
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateDraft.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateDraft();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateDraft message.
         * @function verify
         * @memberof proto.GroupUpdateDraft
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateDraft.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return GroupUpdateDraft;
  })();

  proto.GroupUpdateDraftResponse = (function() {

    /**
         * Properties of a GroupUpdateDraftResponse.
         * @memberof proto
         * @interface IGroupUpdateDraftResponse
         * @property {proto.Response|null} [response] GroupUpdateDraftResponse response
         * @property {Long|null} [roomId] GroupUpdateDraftResponse roomId
         * @property {proto.RoomDraft|null} [draft] GroupUpdateDraftResponse draft
         */

    /**
         * Constructs a new GroupUpdateDraftResponse.
         * @memberof proto
         * @classdesc Represents a GroupUpdateDraftResponse.
         * @implements IGroupUpdateDraftResponse
         * @constructor
         * @param {proto.IGroupUpdateDraftResponse=} [properties] Properties to set
         */
    function GroupUpdateDraftResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateDraftResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupUpdateDraftResponse
         * @instance
         */
    GroupUpdateDraftResponse.prototype.response = null;

    /**
         * GroupUpdateDraftResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateDraftResponse
         * @instance
         */
    GroupUpdateDraftResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateDraftResponse draft.
         * @member {proto.RoomDraft|null|undefined} draft
         * @memberof proto.GroupUpdateDraftResponse
         * @instance
         */
    GroupUpdateDraftResponse.prototype.draft = null;

    /**
         * Creates a new GroupUpdateDraftResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateDraftResponse
         * @static
         * @param {proto.IGroupUpdateDraftResponse=} [properties] Properties to set
         * @returns {proto.GroupUpdateDraftResponse} GroupUpdateDraftResponse instance
         */
    GroupUpdateDraftResponse.create = function create(properties) {
      return new GroupUpdateDraftResponse(properties);
    };

    /**
         * Encodes the specified GroupUpdateDraftResponse message. Does not implicitly {@link proto.GroupUpdateDraftResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateDraftResponse
         * @static
         * @param {proto.GroupUpdateDraftResponse} message GroupUpdateDraftResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateDraftResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.draft != null && message.hasOwnProperty('draft')) {$root.proto.RoomDraft.encode(message.draft, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a GroupUpdateDraftResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateDraftResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateDraftResponse} GroupUpdateDraftResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateDraftResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateDraftResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.draft = $root.proto.RoomDraft.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateDraftResponse message.
         * @function verify
         * @memberof proto.GroupUpdateDraftResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateDraftResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.draft != null && message.hasOwnProperty('draft')) {
        let error = $root.proto.RoomDraft.verify(message.draft);
        if (error) {return 'draft.' + error;}
      }
      return null;
    };

    return GroupUpdateDraftResponse;
  })();

  proto.GroupUpdateStatus = (function() {

    /**
         * Properties of a GroupUpdateStatus.
         * @memberof proto
         * @interface IGroupUpdateStatus
         * @property {proto.Request|null} [request] GroupUpdateStatus request
         * @property {Long|null} [roomId] GroupUpdateStatus roomId
         * @property {Long|null} [messageId] GroupUpdateStatus messageId
         * @property {proto.RoomMessageStatus|null} [status] GroupUpdateStatus status
         */

    /**
         * Constructs a new GroupUpdateStatus.
         * @memberof proto
         * @classdesc Represents a GroupUpdateStatus.
         * @implements IGroupUpdateStatus
         * @constructor
         * @param {proto.IGroupUpdateStatus=} [properties] Properties to set
         */
    function GroupUpdateStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupUpdateStatus
         * @instance
         */
    GroupUpdateStatus.prototype.request = null;

    /**
         * GroupUpdateStatus roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateStatus
         * @instance
         */
    GroupUpdateStatus.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateStatus messageId.
         * @member {Long} messageId
         * @memberof proto.GroupUpdateStatus
         * @instance
         */
    GroupUpdateStatus.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateStatus status.
         * @member {proto.RoomMessageStatus} status
         * @memberof proto.GroupUpdateStatus
         * @instance
         */
    GroupUpdateStatus.prototype.status = 0;

    /**
         * Creates a new GroupUpdateStatus instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateStatus
         * @static
         * @param {proto.IGroupUpdateStatus=} [properties] Properties to set
         * @returns {proto.GroupUpdateStatus} GroupUpdateStatus instance
         */
    GroupUpdateStatus.create = function create(properties) {
      return new GroupUpdateStatus(properties);
    };

    /**
         * Encodes the specified GroupUpdateStatus message. Does not implicitly {@link proto.GroupUpdateStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateStatus
         * @static
         * @param {proto.GroupUpdateStatus} message GroupUpdateStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a GroupUpdateStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateStatus} GroupUpdateStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateStatus message.
         * @function verify
         * @memberof proto.GroupUpdateStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      return null;
    };

    return GroupUpdateStatus;
  })();

  proto.GroupUpdateStatusResponse = (function() {

    /**
         * Properties of a GroupUpdateStatusResponse.
         * @memberof proto
         * @interface IGroupUpdateStatusResponse
         * @property {proto.Response|null} [response] GroupUpdateStatusResponse response
         * @property {Long|null} [roomId] GroupUpdateStatusResponse roomId
         * @property {Long|null} [messageId] GroupUpdateStatusResponse messageId
         * @property {proto.RoomMessageStatus|null} [status] GroupUpdateStatusResponse status
         * @property {Long|null} [statusVersion] GroupUpdateStatusResponse statusVersion
         * @property {string|null} [updaterAuthorHash] GroupUpdateStatusResponse updaterAuthorHash
         */

    /**
         * Constructs a new GroupUpdateStatusResponse.
         * @memberof proto
         * @classdesc Represents a GroupUpdateStatusResponse.
         * @implements IGroupUpdateStatusResponse
         * @constructor
         * @param {proto.IGroupUpdateStatusResponse=} [properties] Properties to set
         */
    function GroupUpdateStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.response = null;

    /**
         * GroupUpdateStatusResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateStatusResponse messageId.
         * @member {Long} messageId
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateStatusResponse status.
         * @member {proto.RoomMessageStatus} status
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.status = 0;

    /**
         * GroupUpdateStatusResponse statusVersion.
         * @member {Long} statusVersion
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.statusVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * GroupUpdateStatusResponse updaterAuthorHash.
         * @member {string} updaterAuthorHash
         * @memberof proto.GroupUpdateStatusResponse
         * @instance
         */
    GroupUpdateStatusResponse.prototype.updaterAuthorHash = '';

    /**
         * Creates a new GroupUpdateStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateStatusResponse
         * @static
         * @param {proto.IGroupUpdateStatusResponse=} [properties] Properties to set
         * @returns {proto.GroupUpdateStatusResponse} GroupUpdateStatusResponse instance
         */
    GroupUpdateStatusResponse.create = function create(properties) {
      return new GroupUpdateStatusResponse(properties);
    };

    /**
         * Encodes the specified GroupUpdateStatusResponse message. Does not implicitly {@link proto.GroupUpdateStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateStatusResponse
         * @static
         * @param {proto.GroupUpdateStatusResponse} message GroupUpdateStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roomId);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);}
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.statusVersion);}
      if (message.updaterAuthorHash != null && message.hasOwnProperty('updaterAuthorHash')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.updaterAuthorHash);}
      return writer;
    };

    /**
         * Decodes a GroupUpdateStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateStatusResponse} GroupUpdateStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.roomId = reader.uint64();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          case 4:
            message.status = reader.int32();
            break;
          case 5:
            message.statusVersion = reader.uint64();
            break;
          case 6:
            message.updaterAuthorHash = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateStatusResponse message.
         * @function verify
         * @memberof proto.GroupUpdateStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      if (message.statusVersion != null && message.hasOwnProperty('statusVersion')) {
        if (!$util.isInteger(message.statusVersion) && !(message.statusVersion && $util.isInteger(message.statusVersion.low) && $util.isInteger(message.statusVersion.high))) {return 'statusVersion: integer|Long expected';}
      }
      if (message.updaterAuthorHash != null && message.hasOwnProperty('updaterAuthorHash')) {
        if (!$util.isString(message.updaterAuthorHash)) {return 'updaterAuthorHash: string expected';}
      }
      return null;
    };

    return GroupUpdateStatusResponse;
  })();

  proto.GroupUpdateUsername = (function() {

    /**
         * Properties of a GroupUpdateUsername.
         * @memberof proto
         * @interface IGroupUpdateUsername
         * @property {proto.Request|null} [request] GroupUpdateUsername request
         * @property {string|null} [username] GroupUpdateUsername username
         * @property {Long|null} [roomId] GroupUpdateUsername roomId
         */

    /**
         * Constructs a new GroupUpdateUsername.
         * @memberof proto
         * @classdesc Represents a GroupUpdateUsername.
         * @implements IGroupUpdateUsername
         * @constructor
         * @param {proto.IGroupUpdateUsername=} [properties] Properties to set
         */
    function GroupUpdateUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.GroupUpdateUsername
         * @instance
         */
    GroupUpdateUsername.prototype.request = null;

    /**
         * GroupUpdateUsername username.
         * @member {string} username
         * @memberof proto.GroupUpdateUsername
         * @instance
         */
    GroupUpdateUsername.prototype.username = '';

    /**
         * GroupUpdateUsername roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateUsername
         * @instance
         */
    GroupUpdateUsername.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupUpdateUsername instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateUsername
         * @static
         * @param {proto.IGroupUpdateUsername=} [properties] Properties to set
         * @returns {proto.GroupUpdateUsername} GroupUpdateUsername instance
         */
    GroupUpdateUsername.create = function create(properties) {
      return new GroupUpdateUsername(properties);
    };

    /**
         * Encodes the specified GroupUpdateUsername message. Does not implicitly {@link proto.GroupUpdateUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateUsername
         * @static
         * @param {proto.GroupUpdateUsername} message GroupUpdateUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupUpdateUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateUsername} GroupUpdateUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateUsername message.
         * @function verify
         * @memberof proto.GroupUpdateUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupUpdateUsername;
  })();

  proto.GroupUpdateUsernameResponse = (function() {

    /**
         * Properties of a GroupUpdateUsernameResponse.
         * @memberof proto
         * @interface IGroupUpdateUsernameResponse
         * @property {proto.Response|null} [response] GroupUpdateUsernameResponse response
         * @property {string|null} [username] GroupUpdateUsernameResponse username
         * @property {Long|null} [roomId] GroupUpdateUsernameResponse roomId
         */

    /**
         * Constructs a new GroupUpdateUsernameResponse.
         * @memberof proto
         * @classdesc Represents a GroupUpdateUsernameResponse.
         * @implements IGroupUpdateUsernameResponse
         * @constructor
         * @param {proto.IGroupUpdateUsernameResponse=} [properties] Properties to set
         */
    function GroupUpdateUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * GroupUpdateUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.GroupUpdateUsernameResponse
         * @instance
         */
    GroupUpdateUsernameResponse.prototype.response = null;

    /**
         * GroupUpdateUsernameResponse username.
         * @member {string} username
         * @memberof proto.GroupUpdateUsernameResponse
         * @instance
         */
    GroupUpdateUsernameResponse.prototype.username = '';

    /**
         * GroupUpdateUsernameResponse roomId.
         * @member {Long} roomId
         * @memberof proto.GroupUpdateUsernameResponse
         * @instance
         */
    GroupUpdateUsernameResponse.prototype.roomId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new GroupUpdateUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.GroupUpdateUsernameResponse
         * @static
         * @param {proto.IGroupUpdateUsernameResponse=} [properties] Properties to set
         * @returns {proto.GroupUpdateUsernameResponse} GroupUpdateUsernameResponse instance
         */
    GroupUpdateUsernameResponse.create = function create(properties) {
      return new GroupUpdateUsernameResponse(properties);
    };

    /**
         * Encodes the specified GroupUpdateUsernameResponse message. Does not implicitly {@link proto.GroupUpdateUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GroupUpdateUsernameResponse
         * @static
         * @param {proto.GroupUpdateUsernameResponse} message GroupUpdateUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    GroupUpdateUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.roomId != null && message.hasOwnProperty('roomId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.roomId);}
      return writer;
    };

    /**
         * Decodes a GroupUpdateUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GroupUpdateUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GroupUpdateUsernameResponse} GroupUpdateUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    GroupUpdateUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GroupUpdateUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.roomId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a GroupUpdateUsernameResponse message.
         * @function verify
         * @memberof proto.GroupUpdateUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    GroupUpdateUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.roomId != null && message.hasOwnProperty('roomId')) {
        if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high))) {return 'roomId: integer|Long expected';}
      }
      return null;
    };

    return GroupUpdateUsernameResponse;
  })();

  proto.Heartbeat = (function() {

    /**
         * Properties of a Heartbeat.
         * @memberof proto
         * @interface IHeartbeat
         * @property {proto.Request|null} [request] Heartbeat request
         */

    /**
         * Constructs a new Heartbeat.
         * @memberof proto
         * @classdesc Represents a Heartbeat.
         * @implements IHeartbeat
         * @constructor
         * @param {proto.IHeartbeat=} [properties] Properties to set
         */
    function Heartbeat(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * Heartbeat request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.Heartbeat
         * @instance
         */
    Heartbeat.prototype.request = null;

    /**
         * Creates a new Heartbeat instance using the specified properties.
         * @function create
         * @memberof proto.Heartbeat
         * @static
         * @param {proto.IHeartbeat=} [properties] Properties to set
         * @returns {proto.Heartbeat} Heartbeat instance
         */
    Heartbeat.create = function create(properties) {
      return new Heartbeat(properties);
    };

    /**
         * Encodes the specified Heartbeat message. Does not implicitly {@link proto.Heartbeat.verify|verify} messages.
         * @function encode
         * @memberof proto.Heartbeat
         * @static
         * @param {proto.Heartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    Heartbeat.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a Heartbeat message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    Heartbeat.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Heartbeat();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a Heartbeat message.
         * @function verify
         * @memberof proto.Heartbeat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    Heartbeat.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return Heartbeat;
  })();

  proto.HeartbeatResponse = (function() {

    /**
         * Properties of a HeartbeatResponse.
         * @memberof proto
         * @interface IHeartbeatResponse
         * @property {proto.Response|null} [response] HeartbeatResponse response
         */

    /**
         * Constructs a new HeartbeatResponse.
         * @memberof proto
         * @classdesc Represents a HeartbeatResponse.
         * @implements IHeartbeatResponse
         * @constructor
         * @param {proto.IHeartbeatResponse=} [properties] Properties to set
         */
    function HeartbeatResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * HeartbeatResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.HeartbeatResponse
         * @instance
         */
    HeartbeatResponse.prototype.response = null;

    /**
         * Creates a new HeartbeatResponse instance using the specified properties.
         * @function create
         * @memberof proto.HeartbeatResponse
         * @static
         * @param {proto.IHeartbeatResponse=} [properties] Properties to set
         * @returns {proto.HeartbeatResponse} HeartbeatResponse instance
         */
    HeartbeatResponse.create = function create(properties) {
      return new HeartbeatResponse(properties);
    };

    /**
         * Encodes the specified HeartbeatResponse message. Does not implicitly {@link proto.HeartbeatResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.HeartbeatResponse
         * @static
         * @param {proto.HeartbeatResponse} message HeartbeatResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    HeartbeatResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a HeartbeatResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.HeartbeatResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.HeartbeatResponse} HeartbeatResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    HeartbeatResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.HeartbeatResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a HeartbeatResponse message.
         * @function verify
         * @memberof proto.HeartbeatResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    HeartbeatResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return HeartbeatResponse;
  })();

  proto.InfoCountry = (function() {

    /**
         * Properties of an InfoCountry.
         * @memberof proto
         * @interface IInfoCountry
         * @property {proto.Request|null} [request] InfoCountry request
         * @property {string|null} [isoCode] InfoCountry isoCode
         */

    /**
         * Constructs a new InfoCountry.
         * @memberof proto
         * @classdesc Represents an InfoCountry.
         * @implements IInfoCountry
         * @constructor
         * @param {proto.IInfoCountry=} [properties] Properties to set
         */
    function InfoCountry(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoCountry request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.InfoCountry
         * @instance
         */
    InfoCountry.prototype.request = null;

    /**
         * InfoCountry isoCode.
         * @member {string} isoCode
         * @memberof proto.InfoCountry
         * @instance
         */
    InfoCountry.prototype.isoCode = '';

    /**
         * Creates a new InfoCountry instance using the specified properties.
         * @function create
         * @memberof proto.InfoCountry
         * @static
         * @param {proto.IInfoCountry=} [properties] Properties to set
         * @returns {proto.InfoCountry} InfoCountry instance
         */
    InfoCountry.create = function create(properties) {
      return new InfoCountry(properties);
    };

    /**
         * Encodes the specified InfoCountry message. Does not implicitly {@link proto.InfoCountry.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoCountry
         * @static
         * @param {proto.InfoCountry} message InfoCountry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoCountry.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.isoCode != null && message.hasOwnProperty('isoCode')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.isoCode);}
      return writer;
    };

    /**
         * Decodes an InfoCountry message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoCountry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoCountry} InfoCountry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoCountry.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoCountry();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.isoCode = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoCountry message.
         * @function verify
         * @memberof proto.InfoCountry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoCountry.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.isoCode != null && message.hasOwnProperty('isoCode')) {
        if (!$util.isString(message.isoCode)) {return 'isoCode: string expected';}
      }
      return null;
    };

    return InfoCountry;
  })();

  proto.InfoCountryResponse = (function() {

    /**
         * Properties of an InfoCountryResponse.
         * @memberof proto
         * @interface IInfoCountryResponse
         * @property {proto.Response|null} [response] InfoCountryResponse response
         * @property {number|null} [callingCode] InfoCountryResponse callingCode
         * @property {string|null} [name] InfoCountryResponse name
         * @property {string|null} [pattern] InfoCountryResponse pattern
         * @property {string|null} [regex] InfoCountryResponse regex
         */

    /**
         * Constructs a new InfoCountryResponse.
         * @memberof proto
         * @classdesc Represents an InfoCountryResponse.
         * @implements IInfoCountryResponse
         * @constructor
         * @param {proto.IInfoCountryResponse=} [properties] Properties to set
         */
    function InfoCountryResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoCountryResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.InfoCountryResponse
         * @instance
         */
    InfoCountryResponse.prototype.response = null;

    /**
         * InfoCountryResponse callingCode.
         * @member {number} callingCode
         * @memberof proto.InfoCountryResponse
         * @instance
         */
    InfoCountryResponse.prototype.callingCode = 0;

    /**
         * InfoCountryResponse name.
         * @member {string} name
         * @memberof proto.InfoCountryResponse
         * @instance
         */
    InfoCountryResponse.prototype.name = '';

    /**
         * InfoCountryResponse pattern.
         * @member {string} pattern
         * @memberof proto.InfoCountryResponse
         * @instance
         */
    InfoCountryResponse.prototype.pattern = '';

    /**
         * InfoCountryResponse regex.
         * @member {string} regex
         * @memberof proto.InfoCountryResponse
         * @instance
         */
    InfoCountryResponse.prototype.regex = '';

    /**
         * Creates a new InfoCountryResponse instance using the specified properties.
         * @function create
         * @memberof proto.InfoCountryResponse
         * @static
         * @param {proto.IInfoCountryResponse=} [properties] Properties to set
         * @returns {proto.InfoCountryResponse} InfoCountryResponse instance
         */
    InfoCountryResponse.create = function create(properties) {
      return new InfoCountryResponse(properties);
    };

    /**
         * Encodes the specified InfoCountryResponse message. Does not implicitly {@link proto.InfoCountryResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoCountryResponse
         * @static
         * @param {proto.InfoCountryResponse} message InfoCountryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoCountryResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.callingCode != null && message.hasOwnProperty('callingCode')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.callingCode);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);}
      if (message.pattern != null && message.hasOwnProperty('pattern')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.pattern);}
      if (message.regex != null && message.hasOwnProperty('regex')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.regex);}
      return writer;
    };

    /**
         * Decodes an InfoCountryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoCountryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoCountryResponse} InfoCountryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoCountryResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoCountryResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.callingCode = reader.uint32();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.pattern = reader.string();
            break;
          case 5:
            message.regex = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoCountryResponse message.
         * @function verify
         * @memberof proto.InfoCountryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoCountryResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.callingCode != null && message.hasOwnProperty('callingCode')) {
        if (!$util.isInteger(message.callingCode)) {return 'callingCode: integer expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.pattern != null && message.hasOwnProperty('pattern')) {
        if (!$util.isString(message.pattern)) {return 'pattern: string expected';}
      }
      if (message.regex != null && message.hasOwnProperty('regex')) {
        if (!$util.isString(message.regex)) {return 'regex: string expected';}
      }
      return null;
    };

    return InfoCountryResponse;
  })();

  proto.InfoLocation = (function() {

    /**
         * Properties of an InfoLocation.
         * @memberof proto
         * @interface IInfoLocation
         * @property {proto.Request|null} [request] InfoLocation request
         */

    /**
         * Constructs a new InfoLocation.
         * @memberof proto
         * @classdesc Represents an InfoLocation.
         * @implements IInfoLocation
         * @constructor
         * @param {proto.IInfoLocation=} [properties] Properties to set
         */
    function InfoLocation(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoLocation request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.InfoLocation
         * @instance
         */
    InfoLocation.prototype.request = null;

    /**
         * Creates a new InfoLocation instance using the specified properties.
         * @function create
         * @memberof proto.InfoLocation
         * @static
         * @param {proto.IInfoLocation=} [properties] Properties to set
         * @returns {proto.InfoLocation} InfoLocation instance
         */
    InfoLocation.create = function create(properties) {
      return new InfoLocation(properties);
    };

    /**
         * Encodes the specified InfoLocation message. Does not implicitly {@link proto.InfoLocation.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoLocation
         * @static
         * @param {proto.InfoLocation} message InfoLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoLocation.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes an InfoLocation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoLocation} InfoLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoLocation.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoLocation();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoLocation message.
         * @function verify
         * @memberof proto.InfoLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoLocation.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return InfoLocation;
  })();

  proto.InfoLocationResponse = (function() {

    /**
         * Properties of an InfoLocationResponse.
         * @memberof proto
         * @interface IInfoLocationResponse
         * @property {proto.Response|null} [response] InfoLocationResponse response
         * @property {string|null} [isoCode] InfoLocationResponse isoCode
         * @property {number|null} [callingCode] InfoLocationResponse callingCode
         * @property {string|null} [name] InfoLocationResponse name
         * @property {string|null} [pattern] InfoLocationResponse pattern
         * @property {string|null} [regex] InfoLocationResponse regex
         */

    /**
         * Constructs a new InfoLocationResponse.
         * @memberof proto
         * @classdesc Represents an InfoLocationResponse.
         * @implements IInfoLocationResponse
         * @constructor
         * @param {proto.IInfoLocationResponse=} [properties] Properties to set
         */
    function InfoLocationResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoLocationResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.response = null;

    /**
         * InfoLocationResponse isoCode.
         * @member {string} isoCode
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.isoCode = '';

    /**
         * InfoLocationResponse callingCode.
         * @member {number} callingCode
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.callingCode = 0;

    /**
         * InfoLocationResponse name.
         * @member {string} name
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.name = '';

    /**
         * InfoLocationResponse pattern.
         * @member {string} pattern
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.pattern = '';

    /**
         * InfoLocationResponse regex.
         * @member {string} regex
         * @memberof proto.InfoLocationResponse
         * @instance
         */
    InfoLocationResponse.prototype.regex = '';

    /**
         * Creates a new InfoLocationResponse instance using the specified properties.
         * @function create
         * @memberof proto.InfoLocationResponse
         * @static
         * @param {proto.IInfoLocationResponse=} [properties] Properties to set
         * @returns {proto.InfoLocationResponse} InfoLocationResponse instance
         */
    InfoLocationResponse.create = function create(properties) {
      return new InfoLocationResponse(properties);
    };

    /**
         * Encodes the specified InfoLocationResponse message. Does not implicitly {@link proto.InfoLocationResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoLocationResponse
         * @static
         * @param {proto.InfoLocationResponse} message InfoLocationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoLocationResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.isoCode != null && message.hasOwnProperty('isoCode')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.isoCode);}
      if (message.callingCode != null && message.hasOwnProperty('callingCode')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.callingCode);}
      if (message.name != null && message.hasOwnProperty('name')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);}
      if (message.pattern != null && message.hasOwnProperty('pattern')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.pattern);}
      if (message.regex != null && message.hasOwnProperty('regex')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.regex);}
      return writer;
    };

    /**
         * Decodes an InfoLocationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoLocationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoLocationResponse} InfoLocationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoLocationResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoLocationResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.isoCode = reader.string();
            break;
          case 3:
            message.callingCode = reader.uint32();
            break;
          case 4:
            message.name = reader.string();
            break;
          case 5:
            message.pattern = reader.string();
            break;
          case 6:
            message.regex = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoLocationResponse message.
         * @function verify
         * @memberof proto.InfoLocationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoLocationResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.isoCode != null && message.hasOwnProperty('isoCode')) {
        if (!$util.isString(message.isoCode)) {return 'isoCode: string expected';}
      }
      if (message.callingCode != null && message.hasOwnProperty('callingCode')) {
        if (!$util.isInteger(message.callingCode)) {return 'callingCode: integer expected';}
      }
      if (message.name != null && message.hasOwnProperty('name')) {
        if (!$util.isString(message.name)) {return 'name: string expected';}
      }
      if (message.pattern != null && message.hasOwnProperty('pattern')) {
        if (!$util.isString(message.pattern)) {return 'pattern: string expected';}
      }
      if (message.regex != null && message.hasOwnProperty('regex')) {
        if (!$util.isString(message.regex)) {return 'regex: string expected';}
      }
      return null;
    };

    return InfoLocationResponse;
  })();

  proto.InfoPage = (function() {

    /**
         * Properties of an InfoPage.
         * @memberof proto
         * @interface IInfoPage
         * @property {proto.Request|null} [request] InfoPage request
         * @property {string|null} [id] InfoPage id
         */

    /**
         * Constructs a new InfoPage.
         * @memberof proto
         * @classdesc Represents an InfoPage.
         * @implements IInfoPage
         * @constructor
         * @param {proto.IInfoPage=} [properties] Properties to set
         */
    function InfoPage(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoPage request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.InfoPage
         * @instance
         */
    InfoPage.prototype.request = null;

    /**
         * InfoPage id.
         * @member {string} id
         * @memberof proto.InfoPage
         * @instance
         */
    InfoPage.prototype.id = '';

    /**
         * Creates a new InfoPage instance using the specified properties.
         * @function create
         * @memberof proto.InfoPage
         * @static
         * @param {proto.IInfoPage=} [properties] Properties to set
         * @returns {proto.InfoPage} InfoPage instance
         */
    InfoPage.create = function create(properties) {
      return new InfoPage(properties);
    };

    /**
         * Encodes the specified InfoPage message. Does not implicitly {@link proto.InfoPage.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoPage
         * @static
         * @param {proto.InfoPage} message InfoPage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoPage.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);}
      return writer;
    };

    /**
         * Decodes an InfoPage message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoPage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoPage} InfoPage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoPage.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoPage();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoPage message.
         * @function verify
         * @memberof proto.InfoPage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoPage.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isString(message.id)) {return 'id: string expected';}
      }
      return null;
    };

    return InfoPage;
  })();

  proto.InfoPageResponse = (function() {

    /**
         * Properties of an InfoPageResponse.
         * @memberof proto
         * @interface IInfoPageResponse
         * @property {proto.Response|null} [response] InfoPageResponse response
         * @property {string|null} [body] InfoPageResponse body
         */

    /**
         * Constructs a new InfoPageResponse.
         * @memberof proto
         * @classdesc Represents an InfoPageResponse.
         * @implements IInfoPageResponse
         * @constructor
         * @param {proto.IInfoPageResponse=} [properties] Properties to set
         */
    function InfoPageResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoPageResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.InfoPageResponse
         * @instance
         */
    InfoPageResponse.prototype.response = null;

    /**
         * InfoPageResponse body.
         * @member {string} body
         * @memberof proto.InfoPageResponse
         * @instance
         */
    InfoPageResponse.prototype.body = '';

    /**
         * Creates a new InfoPageResponse instance using the specified properties.
         * @function create
         * @memberof proto.InfoPageResponse
         * @static
         * @param {proto.IInfoPageResponse=} [properties] Properties to set
         * @returns {proto.InfoPageResponse} InfoPageResponse instance
         */
    InfoPageResponse.create = function create(properties) {
      return new InfoPageResponse(properties);
    };

    /**
         * Encodes the specified InfoPageResponse message. Does not implicitly {@link proto.InfoPageResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoPageResponse
         * @static
         * @param {proto.InfoPageResponse} message InfoPageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoPageResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.body != null && message.hasOwnProperty('body')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);}
      return writer;
    };

    /**
         * Decodes an InfoPageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoPageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoPageResponse} InfoPageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoPageResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoPageResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.body = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoPageResponse message.
         * @function verify
         * @memberof proto.InfoPageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoPageResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.body != null && message.hasOwnProperty('body')) {
        if (!$util.isString(message.body)) {return 'body: string expected';}
      }
      return null;
    };

    return InfoPageResponse;
  })();

  proto.InfoTime = (function() {

    /**
         * Properties of an InfoTime.
         * @memberof proto
         * @interface IInfoTime
         * @property {proto.Request|null} [request] InfoTime request
         */

    /**
         * Constructs a new InfoTime.
         * @memberof proto
         * @classdesc Represents an InfoTime.
         * @implements IInfoTime
         * @constructor
         * @param {proto.IInfoTime=} [properties] Properties to set
         */
    function InfoTime(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoTime request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.InfoTime
         * @instance
         */
    InfoTime.prototype.request = null;

    /**
         * Creates a new InfoTime instance using the specified properties.
         * @function create
         * @memberof proto.InfoTime
         * @static
         * @param {proto.IInfoTime=} [properties] Properties to set
         * @returns {proto.InfoTime} InfoTime instance
         */
    InfoTime.create = function create(properties) {
      return new InfoTime(properties);
    };

    /**
         * Encodes the specified InfoTime message. Does not implicitly {@link proto.InfoTime.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoTime
         * @static
         * @param {proto.InfoTime} message InfoTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoTime.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes an InfoTime message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoTime} InfoTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoTime.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoTime();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoTime message.
         * @function verify
         * @memberof proto.InfoTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoTime.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return InfoTime;
  })();

  proto.InfoTimeResponse = (function() {

    /**
         * Properties of an InfoTimeResponse.
         * @memberof proto
         * @interface IInfoTimeResponse
         * @property {proto.Response|null} [response] InfoTimeResponse response
         * @property {number|null} [timestamp] InfoTimeResponse timestamp
         */

    /**
         * Constructs a new InfoTimeResponse.
         * @memberof proto
         * @classdesc Represents an InfoTimeResponse.
         * @implements IInfoTimeResponse
         * @constructor
         * @param {proto.IInfoTimeResponse=} [properties] Properties to set
         */
    function InfoTimeResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoTimeResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.InfoTimeResponse
         * @instance
         */
    InfoTimeResponse.prototype.response = null;

    /**
         * InfoTimeResponse timestamp.
         * @member {number} timestamp
         * @memberof proto.InfoTimeResponse
         * @instance
         */
    InfoTimeResponse.prototype.timestamp = 0;

    /**
         * Creates a new InfoTimeResponse instance using the specified properties.
         * @function create
         * @memberof proto.InfoTimeResponse
         * @static
         * @param {proto.IInfoTimeResponse=} [properties] Properties to set
         * @returns {proto.InfoTimeResponse} InfoTimeResponse instance
         */
    InfoTimeResponse.create = function create(properties) {
      return new InfoTimeResponse(properties);
    };

    /**
         * Encodes the specified InfoTimeResponse message. Does not implicitly {@link proto.InfoTimeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoTimeResponse
         * @static
         * @param {proto.InfoTimeResponse} message InfoTimeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoTimeResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.timestamp != null && message.hasOwnProperty('timestamp')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp);}
      return writer;
    };

    /**
         * Decodes an InfoTimeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoTimeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoTimeResponse} InfoTimeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoTimeResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoTimeResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.timestamp = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoTimeResponse message.
         * @function verify
         * @memberof proto.InfoTimeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoTimeResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.timestamp != null && message.hasOwnProperty('timestamp')) {
        if (!$util.isInteger(message.timestamp)) {return 'timestamp: integer expected';}
      }
      return null;
    };

    return InfoTimeResponse;
  })();

  proto.InfoWallpaper = (function() {

    /**
         * Properties of an InfoWallpaper.
         * @memberof proto
         * @interface IInfoWallpaper
         * @property {proto.Request|null} [request] InfoWallpaper request
         * @property {proto.InfoWallpaper.Fit|null} [fit] InfoWallpaper fit
         */

    /**
         * Constructs a new InfoWallpaper.
         * @memberof proto
         * @classdesc Represents an InfoWallpaper.
         * @implements IInfoWallpaper
         * @constructor
         * @param {proto.IInfoWallpaper=} [properties] Properties to set
         */
    function InfoWallpaper(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoWallpaper request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.InfoWallpaper
         * @instance
         */
    InfoWallpaper.prototype.request = null;

    /**
         * InfoWallpaper fit.
         * @member {proto.InfoWallpaper.Fit} fit
         * @memberof proto.InfoWallpaper
         * @instance
         */
    InfoWallpaper.prototype.fit = 0;

    /**
         * Creates a new InfoWallpaper instance using the specified properties.
         * @function create
         * @memberof proto.InfoWallpaper
         * @static
         * @param {proto.IInfoWallpaper=} [properties] Properties to set
         * @returns {proto.InfoWallpaper} InfoWallpaper instance
         */
    InfoWallpaper.create = function create(properties) {
      return new InfoWallpaper(properties);
    };

    /**
         * Encodes the specified InfoWallpaper message. Does not implicitly {@link proto.InfoWallpaper.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoWallpaper
         * @static
         * @param {proto.InfoWallpaper} message InfoWallpaper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoWallpaper.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.fit != null && message.hasOwnProperty('fit')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fit);}
      return writer;
    };

    /**
         * Decodes an InfoWallpaper message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoWallpaper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoWallpaper} InfoWallpaper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoWallpaper.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoWallpaper();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.fit = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoWallpaper message.
         * @function verify
         * @memberof proto.InfoWallpaper
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoWallpaper.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.fit != null && message.hasOwnProperty('fit')) {
        switch (message.fit) {
          default:
            return 'fit: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    /**
         * Fit enum.
         * @name proto.InfoWallpaper.Fit
         * @enum {string}
         * @property {number} PHONE=0 PHONE value
         * @property {number} TABLET=1 TABLET value
         * @property {number} DESKTOP=2 DESKTOP value
         */
    InfoWallpaper.Fit = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'PHONE'] = 0;
      values[valuesById[1] = 'TABLET'] = 1;
      values[valuesById[2] = 'DESKTOP'] = 2;
      return values;
    })();

    return InfoWallpaper;
  })();

  proto.InfoWallpaperResponse = (function() {

    /**
         * Properties of an InfoWallpaperResponse.
         * @memberof proto
         * @interface IInfoWallpaperResponse
         * @property {proto.Response|null} [response] InfoWallpaperResponse response
         * @property {Array.<proto.Wallpaper>|null} [wallpaper] InfoWallpaperResponse wallpaper
         */

    /**
         * Constructs a new InfoWallpaperResponse.
         * @memberof proto
         * @classdesc Represents an InfoWallpaperResponse.
         * @implements IInfoWallpaperResponse
         * @constructor
         * @param {proto.IInfoWallpaperResponse=} [properties] Properties to set
         */
    function InfoWallpaperResponse(properties) {
      this.wallpaper = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * InfoWallpaperResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.InfoWallpaperResponse
         * @instance
         */
    InfoWallpaperResponse.prototype.response = null;

    /**
         * InfoWallpaperResponse wallpaper.
         * @member {Array.<proto.Wallpaper>} wallpaper
         * @memberof proto.InfoWallpaperResponse
         * @instance
         */
    InfoWallpaperResponse.prototype.wallpaper = $util.emptyArray;

    /**
         * Creates a new InfoWallpaperResponse instance using the specified properties.
         * @function create
         * @memberof proto.InfoWallpaperResponse
         * @static
         * @param {proto.IInfoWallpaperResponse=} [properties] Properties to set
         * @returns {proto.InfoWallpaperResponse} InfoWallpaperResponse instance
         */
    InfoWallpaperResponse.create = function create(properties) {
      return new InfoWallpaperResponse(properties);
    };

    /**
         * Encodes the specified InfoWallpaperResponse message. Does not implicitly {@link proto.InfoWallpaperResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.InfoWallpaperResponse
         * @static
         * @param {proto.InfoWallpaperResponse} message InfoWallpaperResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    InfoWallpaperResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.wallpaper != null && message.wallpaper.length) {
        for (let i = 0; i < message.wallpaper.length; ++i) {$root.proto.Wallpaper.encode(message.wallpaper[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes an InfoWallpaperResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.InfoWallpaperResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.InfoWallpaperResponse} InfoWallpaperResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    InfoWallpaperResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.InfoWallpaperResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.wallpaper && message.wallpaper.length)) {message.wallpaper = [];}
            message.wallpaper.push($root.proto.Wallpaper.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies an InfoWallpaperResponse message.
         * @function verify
         * @memberof proto.InfoWallpaperResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    InfoWallpaperResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.wallpaper != null && message.hasOwnProperty('wallpaper')) {
        if (!Array.isArray(message.wallpaper)) {return 'wallpaper: array expected';}
        for (let i = 0; i < message.wallpaper.length; ++i) {
          let error = $root.proto.Wallpaper.verify(message.wallpaper[i]);
          if (error) {return 'wallpaper.' + error;}
        }
      }
      return null;
    };

    return InfoWallpaperResponse;
  })();

  proto.MplGetBillToken = (function() {

    /**
         * Properties of a MplGetBillToken.
         * @memberof proto
         * @interface IMplGetBillToken
         * @property {proto.Request|null} [request] MplGetBillToken request
         * @property {Long|null} [billId] MplGetBillToken billId
         * @property {Long|null} [payId] MplGetBillToken payId
         */

    /**
         * Constructs a new MplGetBillToken.
         * @memberof proto
         * @classdesc Represents a MplGetBillToken.
         * @implements IMplGetBillToken
         * @constructor
         * @param {proto.IMplGetBillToken=} [properties] Properties to set
         */
    function MplGetBillToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * MplGetBillToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.MplGetBillToken
         * @instance
         */
    MplGetBillToken.prototype.request = null;

    /**
         * MplGetBillToken billId.
         * @member {Long} billId
         * @memberof proto.MplGetBillToken
         * @instance
         */
    MplGetBillToken.prototype.billId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * MplGetBillToken payId.
         * @member {Long} payId
         * @memberof proto.MplGetBillToken
         * @instance
         */
    MplGetBillToken.prototype.payId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new MplGetBillToken instance using the specified properties.
         * @function create
         * @memberof proto.MplGetBillToken
         * @static
         * @param {proto.IMplGetBillToken=} [properties] Properties to set
         * @returns {proto.MplGetBillToken} MplGetBillToken instance
         */
    MplGetBillToken.create = function create(properties) {
      return new MplGetBillToken(properties);
    };

    /**
         * Encodes the specified MplGetBillToken message. Does not implicitly {@link proto.MplGetBillToken.verify|verify} messages.
         * @function encode
         * @memberof proto.MplGetBillToken
         * @static
         * @param {proto.MplGetBillToken} message MplGetBillToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    MplGetBillToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.billId != null && message.hasOwnProperty('billId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.billId);}
      if (message.payId != null && message.hasOwnProperty('payId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.payId);}
      return writer;
    };

    /**
         * Decodes a MplGetBillToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MplGetBillToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MplGetBillToken} MplGetBillToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    MplGetBillToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MplGetBillToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.billId = reader.uint64();
            break;
          case 3:
            message.payId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a MplGetBillToken message.
         * @function verify
         * @memberof proto.MplGetBillToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    MplGetBillToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.billId != null && message.hasOwnProperty('billId')) {
        if (!$util.isInteger(message.billId) && !(message.billId && $util.isInteger(message.billId.low) && $util.isInteger(message.billId.high))) {return 'billId: integer|Long expected';}
      }
      if (message.payId != null && message.hasOwnProperty('payId')) {
        if (!$util.isInteger(message.payId) && !(message.payId && $util.isInteger(message.payId.low) && $util.isInteger(message.payId.high))) {return 'payId: integer|Long expected';}
      }
      return null;
    };

    return MplGetBillToken;
  })();

  proto.MplGetBillTokenResponse = (function() {

    /**
         * Properties of a MplGetBillTokenResponse.
         * @memberof proto
         * @interface IMplGetBillTokenResponse
         * @property {proto.Response|null} [response] MplGetBillTokenResponse response
         * @property {number|null} [status] MplGetBillTokenResponse status
         * @property {string|null} [token] MplGetBillTokenResponse token
         * @property {number|null} [expireTime] MplGetBillTokenResponse expireTime
         */

    /**
         * Constructs a new MplGetBillTokenResponse.
         * @memberof proto
         * @classdesc Represents a MplGetBillTokenResponse.
         * @implements IMplGetBillTokenResponse
         * @constructor
         * @param {proto.IMplGetBillTokenResponse=} [properties] Properties to set
         */
    function MplGetBillTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * MplGetBillTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.MplGetBillTokenResponse
         * @instance
         */
    MplGetBillTokenResponse.prototype.response = null;

    /**
         * MplGetBillTokenResponse status.
         * @member {number} status
         * @memberof proto.MplGetBillTokenResponse
         * @instance
         */
    MplGetBillTokenResponse.prototype.status = 0;

    /**
         * MplGetBillTokenResponse token.
         * @member {string} token
         * @memberof proto.MplGetBillTokenResponse
         * @instance
         */
    MplGetBillTokenResponse.prototype.token = '';

    /**
         * MplGetBillTokenResponse expireTime.
         * @member {number} expireTime
         * @memberof proto.MplGetBillTokenResponse
         * @instance
         */
    MplGetBillTokenResponse.prototype.expireTime = 0;

    /**
         * Creates a new MplGetBillTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.MplGetBillTokenResponse
         * @static
         * @param {proto.IMplGetBillTokenResponse=} [properties] Properties to set
         * @returns {proto.MplGetBillTokenResponse} MplGetBillTokenResponse instance
         */
    MplGetBillTokenResponse.create = function create(properties) {
      return new MplGetBillTokenResponse(properties);
    };

    /**
         * Encodes the specified MplGetBillTokenResponse message. Does not implicitly {@link proto.MplGetBillTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.MplGetBillTokenResponse
         * @static
         * @param {proto.MplGetBillTokenResponse} message MplGetBillTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    MplGetBillTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.status);}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);}
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expireTime);}
      return writer;
    };

    /**
         * Decodes a MplGetBillTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MplGetBillTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MplGetBillTokenResponse} MplGetBillTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    MplGetBillTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MplGetBillTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.uint32();
            break;
          case 3:
            message.token = reader.string();
            break;
          case 4:
            message.expireTime = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a MplGetBillTokenResponse message.
         * @function verify
         * @memberof proto.MplGetBillTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    MplGetBillTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        if (!$util.isInteger(message.status)) {return 'status: integer expected';}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {
        if (!$util.isInteger(message.expireTime)) {return 'expireTime: integer expected';}
      }
      return null;
    };

    return MplGetBillTokenResponse;
  })();

  proto.MplGetTopupToken = (function() {

    /**
         * Properties of a MplGetTopupToken.
         * @memberof proto
         * @interface IMplGetTopupToken
         * @property {proto.Request|null} [request] MplGetTopupToken request
         * @property {Long|null} [chargeMobileNumber] MplGetTopupToken chargeMobileNumber
         * @property {Long|null} [amount] MplGetTopupToken amount
         * @property {proto.MplGetTopupToken.Type|null} [type] MplGetTopupToken type
         */

    /**
         * Constructs a new MplGetTopupToken.
         * @memberof proto
         * @classdesc Represents a MplGetTopupToken.
         * @implements IMplGetTopupToken
         * @constructor
         * @param {proto.IMplGetTopupToken=} [properties] Properties to set
         */
    function MplGetTopupToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * MplGetTopupToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.MplGetTopupToken
         * @instance
         */
    MplGetTopupToken.prototype.request = null;

    /**
         * MplGetTopupToken chargeMobileNumber.
         * @member {Long} chargeMobileNumber
         * @memberof proto.MplGetTopupToken
         * @instance
         */
    MplGetTopupToken.prototype.chargeMobileNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * MplGetTopupToken amount.
         * @member {Long} amount
         * @memberof proto.MplGetTopupToken
         * @instance
         */
    MplGetTopupToken.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * MplGetTopupToken type.
         * @member {proto.MplGetTopupToken.Type} type
         * @memberof proto.MplGetTopupToken
         * @instance
         */
    MplGetTopupToken.prototype.type = 0;

    /**
         * Creates a new MplGetTopupToken instance using the specified properties.
         * @function create
         * @memberof proto.MplGetTopupToken
         * @static
         * @param {proto.IMplGetTopupToken=} [properties] Properties to set
         * @returns {proto.MplGetTopupToken} MplGetTopupToken instance
         */
    MplGetTopupToken.create = function create(properties) {
      return new MplGetTopupToken(properties);
    };

    /**
         * Encodes the specified MplGetTopupToken message. Does not implicitly {@link proto.MplGetTopupToken.verify|verify} messages.
         * @function encode
         * @memberof proto.MplGetTopupToken
         * @static
         * @param {proto.MplGetTopupToken} message MplGetTopupToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    MplGetTopupToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.chargeMobileNumber != null && message.hasOwnProperty('chargeMobileNumber')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chargeMobileNumber);}
      if (message.amount != null && message.hasOwnProperty('amount')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amount);}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);}
      return writer;
    };

    /**
         * Decodes a MplGetTopupToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MplGetTopupToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MplGetTopupToken} MplGetTopupToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    MplGetTopupToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MplGetTopupToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.chargeMobileNumber = reader.uint64();
            break;
          case 3:
            message.amount = reader.uint64();
            break;
          case 4:
            message.type = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a MplGetTopupToken message.
         * @function verify
         * @memberof proto.MplGetTopupToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    MplGetTopupToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.chargeMobileNumber != null && message.hasOwnProperty('chargeMobileNumber')) {
        if (!$util.isInteger(message.chargeMobileNumber) && !(message.chargeMobileNumber && $util.isInteger(message.chargeMobileNumber.low) && $util.isInteger(message.chargeMobileNumber.high))) {return 'chargeMobileNumber: integer|Long expected';}
      }
      if (message.amount != null && message.hasOwnProperty('amount')) {
        if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high))) {return 'amount: integer|Long expected';}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
        }
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.MplGetTopupToken.Type
         * @enum {string}
         * @property {number} IRANCELL_PREPAID=0 IRANCELL_PREPAID value
         * @property {number} IRANCELL_WOW=1 IRANCELL_WOW value
         * @property {number} IRANCELL_WIMAX=2 IRANCELL_WIMAX value
         * @property {number} IRANCELL_POSTPAID=3 IRANCELL_POSTPAID value
         * @property {number} MCI=4 MCI value
         * @property {number} RIGHTEL=5 RIGHTEL value
         */
    MplGetTopupToken.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'IRANCELL_PREPAID'] = 0;
      values[valuesById[1] = 'IRANCELL_WOW'] = 1;
      values[valuesById[2] = 'IRANCELL_WIMAX'] = 2;
      values[valuesById[3] = 'IRANCELL_POSTPAID'] = 3;
      values[valuesById[4] = 'MCI'] = 4;
      values[valuesById[5] = 'RIGHTEL'] = 5;
      return values;
    })();

    return MplGetTopupToken;
  })();

  proto.MplGetTopupTokenResponse = (function() {

    /**
         * Properties of a MplGetTopupTokenResponse.
         * @memberof proto
         * @interface IMplGetTopupTokenResponse
         * @property {proto.Response|null} [response] MplGetTopupTokenResponse response
         * @property {number|null} [status] MplGetTopupTokenResponse status
         * @property {string|null} [token] MplGetTopupTokenResponse token
         * @property {number|null} [expireTime] MplGetTopupTokenResponse expireTime
         */

    /**
         * Constructs a new MplGetTopupTokenResponse.
         * @memberof proto
         * @classdesc Represents a MplGetTopupTokenResponse.
         * @implements IMplGetTopupTokenResponse
         * @constructor
         * @param {proto.IMplGetTopupTokenResponse=} [properties] Properties to set
         */
    function MplGetTopupTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * MplGetTopupTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.MplGetTopupTokenResponse
         * @instance
         */
    MplGetTopupTokenResponse.prototype.response = null;

    /**
         * MplGetTopupTokenResponse status.
         * @member {number} status
         * @memberof proto.MplGetTopupTokenResponse
         * @instance
         */
    MplGetTopupTokenResponse.prototype.status = 0;

    /**
         * MplGetTopupTokenResponse token.
         * @member {string} token
         * @memberof proto.MplGetTopupTokenResponse
         * @instance
         */
    MplGetTopupTokenResponse.prototype.token = '';

    /**
         * MplGetTopupTokenResponse expireTime.
         * @member {number} expireTime
         * @memberof proto.MplGetTopupTokenResponse
         * @instance
         */
    MplGetTopupTokenResponse.prototype.expireTime = 0;

    /**
         * Creates a new MplGetTopupTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.MplGetTopupTokenResponse
         * @static
         * @param {proto.IMplGetTopupTokenResponse=} [properties] Properties to set
         * @returns {proto.MplGetTopupTokenResponse} MplGetTopupTokenResponse instance
         */
    MplGetTopupTokenResponse.create = function create(properties) {
      return new MplGetTopupTokenResponse(properties);
    };

    /**
         * Encodes the specified MplGetTopupTokenResponse message. Does not implicitly {@link proto.MplGetTopupTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.MplGetTopupTokenResponse
         * @static
         * @param {proto.MplGetTopupTokenResponse} message MplGetTopupTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    MplGetTopupTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.status);}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);}
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expireTime);}
      return writer;
    };

    /**
         * Decodes a MplGetTopupTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MplGetTopupTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MplGetTopupTokenResponse} MplGetTopupTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    MplGetTopupTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MplGetTopupTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.uint32();
            break;
          case 3:
            message.token = reader.string();
            break;
          case 4:
            message.expireTime = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a MplGetTopupTokenResponse message.
         * @function verify
         * @memberof proto.MplGetTopupTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    MplGetTopupTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        if (!$util.isInteger(message.status)) {return 'status: integer expected';}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {
        if (!$util.isInteger(message.expireTime)) {return 'expireTime: integer expected';}
      }
      return null;
    };

    return MplGetTopupTokenResponse;
  })();

  proto.PushLoginTokenResponse = (function() {

    /**
         * Properties of a PushLoginTokenResponse.
         * @memberof proto
         * @interface IPushLoginTokenResponse
         * @property {proto.Response|null} [response] PushLoginTokenResponse response
         * @property {string|null} [username] PushLoginTokenResponse username
         * @property {Long|null} [userId] PushLoginTokenResponse userId
         * @property {string|null} [authorHash] PushLoginTokenResponse authorHash
         * @property {string|null} [token] PushLoginTokenResponse token
         */

    /**
         * Constructs a new PushLoginTokenResponse.
         * @memberof proto
         * @classdesc Represents a PushLoginTokenResponse.
         * @implements IPushLoginTokenResponse
         * @constructor
         * @param {proto.IPushLoginTokenResponse=} [properties] Properties to set
         */
    function PushLoginTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * PushLoginTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.PushLoginTokenResponse
         * @instance
         */
    PushLoginTokenResponse.prototype.response = null;

    /**
         * PushLoginTokenResponse username.
         * @member {string} username
         * @memberof proto.PushLoginTokenResponse
         * @instance
         */
    PushLoginTokenResponse.prototype.username = '';

    /**
         * PushLoginTokenResponse userId.
         * @member {Long} userId
         * @memberof proto.PushLoginTokenResponse
         * @instance
         */
    PushLoginTokenResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * PushLoginTokenResponse authorHash.
         * @member {string} authorHash
         * @memberof proto.PushLoginTokenResponse
         * @instance
         */
    PushLoginTokenResponse.prototype.authorHash = '';

    /**
         * PushLoginTokenResponse token.
         * @member {string} token
         * @memberof proto.PushLoginTokenResponse
         * @instance
         */
    PushLoginTokenResponse.prototype.token = '';

    /**
         * Creates a new PushLoginTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.PushLoginTokenResponse
         * @static
         * @param {proto.IPushLoginTokenResponse=} [properties] Properties to set
         * @returns {proto.PushLoginTokenResponse} PushLoginTokenResponse instance
         */
    PushLoginTokenResponse.create = function create(properties) {
      return new PushLoginTokenResponse(properties);
    };

    /**
         * Encodes the specified PushLoginTokenResponse message. Does not implicitly {@link proto.PushLoginTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.PushLoginTokenResponse
         * @static
         * @param {proto.PushLoginTokenResponse} message PushLoginTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    PushLoginTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.authorHash);}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.token);}
      return writer;
    };

    /**
         * Decodes a PushLoginTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PushLoginTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PushLoginTokenResponse} PushLoginTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    PushLoginTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PushLoginTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          case 4:
            message.authorHash = reader.string();
            break;
          case 5:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a PushLoginTokenResponse message.
         * @function verify
         * @memberof proto.PushLoginTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    PushLoginTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {
        if (!$util.isString(message.authorHash)) {return 'authorHash: string expected';}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return PushLoginTokenResponse;
  })();

  proto.PushRateSignalingResponse = (function() {

    /**
         * Properties of a PushRateSignalingResponse.
         * @memberof proto
         * @interface IPushRateSignalingResponse
         * @property {proto.Response|null} [response] PushRateSignalingResponse response
         * @property {Long|null} [id] PushRateSignalingResponse id
         */

    /**
         * Constructs a new PushRateSignalingResponse.
         * @memberof proto
         * @classdesc Represents a PushRateSignalingResponse.
         * @implements IPushRateSignalingResponse
         * @constructor
         * @param {proto.IPushRateSignalingResponse=} [properties] Properties to set
         */
    function PushRateSignalingResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * PushRateSignalingResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.PushRateSignalingResponse
         * @instance
         */
    PushRateSignalingResponse.prototype.response = null;

    /**
         * PushRateSignalingResponse id.
         * @member {Long} id
         * @memberof proto.PushRateSignalingResponse
         * @instance
         */
    PushRateSignalingResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new PushRateSignalingResponse instance using the specified properties.
         * @function create
         * @memberof proto.PushRateSignalingResponse
         * @static
         * @param {proto.IPushRateSignalingResponse=} [properties] Properties to set
         * @returns {proto.PushRateSignalingResponse} PushRateSignalingResponse instance
         */
    PushRateSignalingResponse.create = function create(properties) {
      return new PushRateSignalingResponse(properties);
    };

    /**
         * Encodes the specified PushRateSignalingResponse message. Does not implicitly {@link proto.PushRateSignalingResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.PushRateSignalingResponse
         * @static
         * @param {proto.PushRateSignalingResponse} message PushRateSignalingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    PushRateSignalingResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      return writer;
    };

    /**
         * Decodes a PushRateSignalingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PushRateSignalingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PushRateSignalingResponse} PushRateSignalingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    PushRateSignalingResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PushRateSignalingResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a PushRateSignalingResponse message.
         * @function verify
         * @memberof proto.PushRateSignalingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    PushRateSignalingResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      return null;
    };

    return PushRateSignalingResponse;
  })();

  proto.PushTwoStepVerificationResponse = (function() {

    /**
         * Properties of a PushTwoStepVerificationResponse.
         * @memberof proto
         * @interface IPushTwoStepVerificationResponse
         * @property {proto.Response|null} [response] PushTwoStepVerificationResponse response
         * @property {string|null} [username] PushTwoStepVerificationResponse username
         * @property {Long|null} [userId] PushTwoStepVerificationResponse userId
         * @property {string|null} [authorHash] PushTwoStepVerificationResponse authorHash
         */

    /**
         * Constructs a new PushTwoStepVerificationResponse.
         * @memberof proto
         * @classdesc Represents a PushTwoStepVerificationResponse.
         * @implements IPushTwoStepVerificationResponse
         * @constructor
         * @param {proto.IPushTwoStepVerificationResponse=} [properties] Properties to set
         */
    function PushTwoStepVerificationResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * PushTwoStepVerificationResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.PushTwoStepVerificationResponse
         * @instance
         */
    PushTwoStepVerificationResponse.prototype.response = null;

    /**
         * PushTwoStepVerificationResponse username.
         * @member {string} username
         * @memberof proto.PushTwoStepVerificationResponse
         * @instance
         */
    PushTwoStepVerificationResponse.prototype.username = '';

    /**
         * PushTwoStepVerificationResponse userId.
         * @member {Long} userId
         * @memberof proto.PushTwoStepVerificationResponse
         * @instance
         */
    PushTwoStepVerificationResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * PushTwoStepVerificationResponse authorHash.
         * @member {string} authorHash
         * @memberof proto.PushTwoStepVerificationResponse
         * @instance
         */
    PushTwoStepVerificationResponse.prototype.authorHash = '';

    /**
         * Creates a new PushTwoStepVerificationResponse instance using the specified properties.
         * @function create
         * @memberof proto.PushTwoStepVerificationResponse
         * @static
         * @param {proto.IPushTwoStepVerificationResponse=} [properties] Properties to set
         * @returns {proto.PushTwoStepVerificationResponse} PushTwoStepVerificationResponse instance
         */
    PushTwoStepVerificationResponse.create = function create(properties) {
      return new PushTwoStepVerificationResponse(properties);
    };

    /**
         * Encodes the specified PushTwoStepVerificationResponse message. Does not implicitly {@link proto.PushTwoStepVerificationResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.PushTwoStepVerificationResponse
         * @static
         * @param {proto.PushTwoStepVerificationResponse} message PushTwoStepVerificationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    PushTwoStepVerificationResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.authorHash);}
      return writer;
    };

    /**
         * Decodes a PushTwoStepVerificationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PushTwoStepVerificationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PushTwoStepVerificationResponse} PushTwoStepVerificationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    PushTwoStepVerificationResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PushTwoStepVerificationResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          case 4:
            message.authorHash = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a PushTwoStepVerificationResponse message.
         * @function verify
         * @memberof proto.PushTwoStepVerificationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    PushTwoStepVerificationResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {
        if (!$util.isString(message.authorHash)) {return 'authorHash: string expected';}
      }
      return null;
    };

    return PushTwoStepVerificationResponse;
  })();

  proto.PushUserInfoExpiredResponse = (function() {

    /**
         * Properties of a PushUserInfoExpiredResponse.
         * @memberof proto
         * @interface IPushUserInfoExpiredResponse
         * @property {proto.Response|null} [response] PushUserInfoExpiredResponse response
         * @property {Long|null} [userId] PushUserInfoExpiredResponse userId
         */

    /**
         * Constructs a new PushUserInfoExpiredResponse.
         * @memberof proto
         * @classdesc Represents a PushUserInfoExpiredResponse.
         * @implements IPushUserInfoExpiredResponse
         * @constructor
         * @param {proto.IPushUserInfoExpiredResponse=} [properties] Properties to set
         */
    function PushUserInfoExpiredResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * PushUserInfoExpiredResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.PushUserInfoExpiredResponse
         * @instance
         */
    PushUserInfoExpiredResponse.prototype.response = null;

    /**
         * PushUserInfoExpiredResponse userId.
         * @member {Long} userId
         * @memberof proto.PushUserInfoExpiredResponse
         * @instance
         */
    PushUserInfoExpiredResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new PushUserInfoExpiredResponse instance using the specified properties.
         * @function create
         * @memberof proto.PushUserInfoExpiredResponse
         * @static
         * @param {proto.IPushUserInfoExpiredResponse=} [properties] Properties to set
         * @returns {proto.PushUserInfoExpiredResponse} PushUserInfoExpiredResponse instance
         */
    PushUserInfoExpiredResponse.create = function create(properties) {
      return new PushUserInfoExpiredResponse(properties);
    };

    /**
         * Encodes the specified PushUserInfoExpiredResponse message. Does not implicitly {@link proto.PushUserInfoExpiredResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.PushUserInfoExpiredResponse
         * @static
         * @param {proto.PushUserInfoExpiredResponse} message PushUserInfoExpiredResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    PushUserInfoExpiredResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a PushUserInfoExpiredResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PushUserInfoExpiredResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PushUserInfoExpiredResponse} PushUserInfoExpiredResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    PushUserInfoExpiredResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PushUserInfoExpiredResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a PushUserInfoExpiredResponse message.
         * @function verify
         * @memberof proto.PushUserInfoExpiredResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    PushUserInfoExpiredResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return PushUserInfoExpiredResponse;
  })();

  proto.QrCodeAddContact = (function() {

    /**
         * Properties of a QrCodeAddContact.
         * @memberof proto
         * @interface IQrCodeAddContact
         * @property {proto.Request|null} [request] QrCodeAddContact request
         * @property {string|null} [phone] QrCodeAddContact phone
         * @property {string|null} [firstName] QrCodeAddContact firstName
         * @property {string|null} [lastName] QrCodeAddContact lastName
         */

    /**
         * Constructs a new QrCodeAddContact.
         * @memberof proto
         * @classdesc Represents a QrCodeAddContact.
         * @implements IQrCodeAddContact
         * @constructor
         * @param {proto.IQrCodeAddContact=} [properties] Properties to set
         */
    function QrCodeAddContact(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeAddContact request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.QrCodeAddContact
         * @instance
         */
    QrCodeAddContact.prototype.request = null;

    /**
         * QrCodeAddContact phone.
         * @member {string} phone
         * @memberof proto.QrCodeAddContact
         * @instance
         */
    QrCodeAddContact.prototype.phone = '';

    /**
         * QrCodeAddContact firstName.
         * @member {string} firstName
         * @memberof proto.QrCodeAddContact
         * @instance
         */
    QrCodeAddContact.prototype.firstName = '';

    /**
         * QrCodeAddContact lastName.
         * @member {string} lastName
         * @memberof proto.QrCodeAddContact
         * @instance
         */
    QrCodeAddContact.prototype.lastName = '';

    /**
         * Creates a new QrCodeAddContact instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeAddContact
         * @static
         * @param {proto.IQrCodeAddContact=} [properties] Properties to set
         * @returns {proto.QrCodeAddContact} QrCodeAddContact instance
         */
    QrCodeAddContact.create = function create(properties) {
      return new QrCodeAddContact(properties);
    };

    /**
         * Encodes the specified QrCodeAddContact message. Does not implicitly {@link proto.QrCodeAddContact.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeAddContact
         * @static
         * @param {proto.QrCodeAddContact} message QrCodeAddContact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeAddContact.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.firstName);}
      if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastName);}
      return writer;
    };

    /**
         * Decodes a QrCodeAddContact message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeAddContact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeAddContact} QrCodeAddContact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeAddContact.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeAddContact();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.phone = reader.string();
            break;
          case 3:
            message.firstName = reader.string();
            break;
          case 4:
            message.lastName = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeAddContact message.
         * @function verify
         * @memberof proto.QrCodeAddContact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeAddContact.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isString(message.phone)) {return 'phone: string expected';}
      }
      if (message.firstName != null && message.hasOwnProperty('firstName')) {
        if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
      }
      if (message.lastName != null && message.hasOwnProperty('lastName')) {
        if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
      }
      return null;
    };

    return QrCodeAddContact;
  })();

  proto.QrCodeAddContactResponse = (function() {

    /**
         * Properties of a QrCodeAddContactResponse.
         * @memberof proto
         * @interface IQrCodeAddContactResponse
         * @property {proto.Response|null} [response] QrCodeAddContactResponse response
         * @property {Uint8Array|null} [qrCodeImage] QrCodeAddContactResponse qrCodeImage
         */

    /**
         * Constructs a new QrCodeAddContactResponse.
         * @memberof proto
         * @classdesc Represents a QrCodeAddContactResponse.
         * @implements IQrCodeAddContactResponse
         * @constructor
         * @param {proto.IQrCodeAddContactResponse=} [properties] Properties to set
         */
    function QrCodeAddContactResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeAddContactResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.QrCodeAddContactResponse
         * @instance
         */
    QrCodeAddContactResponse.prototype.response = null;

    /**
         * QrCodeAddContactResponse qrCodeImage.
         * @member {Uint8Array} qrCodeImage
         * @memberof proto.QrCodeAddContactResponse
         * @instance
         */
    QrCodeAddContactResponse.prototype.qrCodeImage = $util.newBuffer([]);

    /**
         * Creates a new QrCodeAddContactResponse instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeAddContactResponse
         * @static
         * @param {proto.IQrCodeAddContactResponse=} [properties] Properties to set
         * @returns {proto.QrCodeAddContactResponse} QrCodeAddContactResponse instance
         */
    QrCodeAddContactResponse.create = function create(properties) {
      return new QrCodeAddContactResponse(properties);
    };

    /**
         * Encodes the specified QrCodeAddContactResponse message. Does not implicitly {@link proto.QrCodeAddContactResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeAddContactResponse
         * @static
         * @param {proto.QrCodeAddContactResponse} message QrCodeAddContactResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeAddContactResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.qrCodeImage);}
      return writer;
    };

    /**
         * Decodes a QrCodeAddContactResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeAddContactResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeAddContactResponse} QrCodeAddContactResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeAddContactResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeAddContactResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.qrCodeImage = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeAddContactResponse message.
         * @function verify
         * @memberof proto.QrCodeAddContactResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeAddContactResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {
        if (!(message.qrCodeImage && typeof message.qrCodeImage.length === 'number' || $util.isString(message.qrCodeImage))) {return 'qrCodeImage: buffer expected';}
      }
      return null;
    };

    return QrCodeAddContactResponse;
  })();

  proto.QrCodeAddMe = (function() {

    /**
         * Properties of a QrCodeAddMe.
         * @memberof proto
         * @interface IQrCodeAddMe
         * @property {proto.Request|null} [request] QrCodeAddMe request
         */

    /**
         * Constructs a new QrCodeAddMe.
         * @memberof proto
         * @classdesc Represents a QrCodeAddMe.
         * @implements IQrCodeAddMe
         * @constructor
         * @param {proto.IQrCodeAddMe=} [properties] Properties to set
         */
    function QrCodeAddMe(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeAddMe request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.QrCodeAddMe
         * @instance
         */
    QrCodeAddMe.prototype.request = null;

    /**
         * Creates a new QrCodeAddMe instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeAddMe
         * @static
         * @param {proto.IQrCodeAddMe=} [properties] Properties to set
         * @returns {proto.QrCodeAddMe} QrCodeAddMe instance
         */
    QrCodeAddMe.create = function create(properties) {
      return new QrCodeAddMe(properties);
    };

    /**
         * Encodes the specified QrCodeAddMe message. Does not implicitly {@link proto.QrCodeAddMe.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeAddMe
         * @static
         * @param {proto.QrCodeAddMe} message QrCodeAddMe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeAddMe.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a QrCodeAddMe message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeAddMe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeAddMe} QrCodeAddMe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeAddMe.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeAddMe();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeAddMe message.
         * @function verify
         * @memberof proto.QrCodeAddMe
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeAddMe.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return QrCodeAddMe;
  })();

  proto.QrCodeAddMeResponse = (function() {

    /**
         * Properties of a QrCodeAddMeResponse.
         * @memberof proto
         * @interface IQrCodeAddMeResponse
         * @property {proto.Response|null} [response] QrCodeAddMeResponse response
         * @property {Uint8Array|null} [qrCodeImage] QrCodeAddMeResponse qrCodeImage
         */

    /**
         * Constructs a new QrCodeAddMeResponse.
         * @memberof proto
         * @classdesc Represents a QrCodeAddMeResponse.
         * @implements IQrCodeAddMeResponse
         * @constructor
         * @param {proto.IQrCodeAddMeResponse=} [properties] Properties to set
         */
    function QrCodeAddMeResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeAddMeResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.QrCodeAddMeResponse
         * @instance
         */
    QrCodeAddMeResponse.prototype.response = null;

    /**
         * QrCodeAddMeResponse qrCodeImage.
         * @member {Uint8Array} qrCodeImage
         * @memberof proto.QrCodeAddMeResponse
         * @instance
         */
    QrCodeAddMeResponse.prototype.qrCodeImage = $util.newBuffer([]);

    /**
         * Creates a new QrCodeAddMeResponse instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeAddMeResponse
         * @static
         * @param {proto.IQrCodeAddMeResponse=} [properties] Properties to set
         * @returns {proto.QrCodeAddMeResponse} QrCodeAddMeResponse instance
         */
    QrCodeAddMeResponse.create = function create(properties) {
      return new QrCodeAddMeResponse(properties);
    };

    /**
         * Encodes the specified QrCodeAddMeResponse message. Does not implicitly {@link proto.QrCodeAddMeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeAddMeResponse
         * @static
         * @param {proto.QrCodeAddMeResponse} message QrCodeAddMeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeAddMeResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.qrCodeImage);}
      return writer;
    };

    /**
         * Decodes a QrCodeAddMeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeAddMeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeAddMeResponse} QrCodeAddMeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeAddMeResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeAddMeResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.qrCodeImage = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeAddMeResponse message.
         * @function verify
         * @memberof proto.QrCodeAddMeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeAddMeResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {
        if (!(message.qrCodeImage && typeof message.qrCodeImage.length === 'number' || $util.isString(message.qrCodeImage))) {return 'qrCodeImage: buffer expected';}
      }
      return null;
    };

    return QrCodeAddMeResponse;
  })();

  proto.QrCodeJoin = (function() {

    /**
         * Properties of a QrCodeJoin.
         * @memberof proto
         * @interface IQrCodeJoin
         * @property {proto.Request|null} [request] QrCodeJoin request
         * @property {string|null} [inviteToken] QrCodeJoin inviteToken
         */

    /**
         * Constructs a new QrCodeJoin.
         * @memberof proto
         * @classdesc Represents a QrCodeJoin.
         * @implements IQrCodeJoin
         * @constructor
         * @param {proto.IQrCodeJoin=} [properties] Properties to set
         */
    function QrCodeJoin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeJoin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.QrCodeJoin
         * @instance
         */
    QrCodeJoin.prototype.request = null;

    /**
         * QrCodeJoin inviteToken.
         * @member {string} inviteToken
         * @memberof proto.QrCodeJoin
         * @instance
         */
    QrCodeJoin.prototype.inviteToken = '';

    /**
         * Creates a new QrCodeJoin instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeJoin
         * @static
         * @param {proto.IQrCodeJoin=} [properties] Properties to set
         * @returns {proto.QrCodeJoin} QrCodeJoin instance
         */
    QrCodeJoin.create = function create(properties) {
      return new QrCodeJoin(properties);
    };

    /**
         * Encodes the specified QrCodeJoin message. Does not implicitly {@link proto.QrCodeJoin.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeJoin
         * @static
         * @param {proto.QrCodeJoin} message QrCodeJoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeJoin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteToken);}
      return writer;
    };

    /**
         * Decodes a QrCodeJoin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeJoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeJoin} QrCodeJoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeJoin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeJoin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.inviteToken = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeJoin message.
         * @function verify
         * @memberof proto.QrCodeJoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeJoin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.inviteToken != null && message.hasOwnProperty('inviteToken')) {
        if (!$util.isString(message.inviteToken)) {return 'inviteToken: string expected';}
      }
      return null;
    };

    return QrCodeJoin;
  })();

  proto.QrCodeJoinResponse = (function() {

    /**
         * Properties of a QrCodeJoinResponse.
         * @memberof proto
         * @interface IQrCodeJoinResponse
         * @property {proto.Response|null} [response] QrCodeJoinResponse response
         * @property {Uint8Array|null} [qrCodeImage] QrCodeJoinResponse qrCodeImage
         */

    /**
         * Constructs a new QrCodeJoinResponse.
         * @memberof proto
         * @classdesc Represents a QrCodeJoinResponse.
         * @implements IQrCodeJoinResponse
         * @constructor
         * @param {proto.IQrCodeJoinResponse=} [properties] Properties to set
         */
    function QrCodeJoinResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeJoinResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.QrCodeJoinResponse
         * @instance
         */
    QrCodeJoinResponse.prototype.response = null;

    /**
         * QrCodeJoinResponse qrCodeImage.
         * @member {Uint8Array} qrCodeImage
         * @memberof proto.QrCodeJoinResponse
         * @instance
         */
    QrCodeJoinResponse.prototype.qrCodeImage = $util.newBuffer([]);

    /**
         * Creates a new QrCodeJoinResponse instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeJoinResponse
         * @static
         * @param {proto.IQrCodeJoinResponse=} [properties] Properties to set
         * @returns {proto.QrCodeJoinResponse} QrCodeJoinResponse instance
         */
    QrCodeJoinResponse.create = function create(properties) {
      return new QrCodeJoinResponse(properties);
    };

    /**
         * Encodes the specified QrCodeJoinResponse message. Does not implicitly {@link proto.QrCodeJoinResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeJoinResponse
         * @static
         * @param {proto.QrCodeJoinResponse} message QrCodeJoinResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeJoinResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.qrCodeImage);}
      return writer;
    };

    /**
         * Decodes a QrCodeJoinResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeJoinResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeJoinResponse} QrCodeJoinResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeJoinResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeJoinResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.qrCodeImage = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeJoinResponse message.
         * @function verify
         * @memberof proto.QrCodeJoinResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeJoinResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {
        if (!(message.qrCodeImage && typeof message.qrCodeImage.length === 'number' || $util.isString(message.qrCodeImage))) {return 'qrCodeImage: buffer expected';}
      }
      return null;
    };

    return QrCodeJoinResponse;
  })();

  proto.QrCodeNewDevice = (function() {

    /**
         * Properties of a QrCodeNewDevice.
         * @memberof proto
         * @interface IQrCodeNewDevice
         * @property {proto.Request|null} [request] QrCodeNewDevice request
         * @property {string|null} [appName] QrCodeNewDevice appName
         * @property {number|null} [appId] QrCodeNewDevice appId
         * @property {number|null} [appBuildVersion] QrCodeNewDevice appBuildVersion
         * @property {string|null} [appVersion] QrCodeNewDevice appVersion
         * @property {proto.Platform|null} [platform] QrCodeNewDevice platform
         * @property {string|null} [platformVersion] QrCodeNewDevice platformVersion
         * @property {proto.Device|null} [device] QrCodeNewDevice device
         * @property {string|null} [deviceName] QrCodeNewDevice deviceName
         */

    /**
         * Constructs a new QrCodeNewDevice.
         * @memberof proto
         * @classdesc Represents a QrCodeNewDevice.
         * @implements IQrCodeNewDevice
         * @constructor
         * @param {proto.IQrCodeNewDevice=} [properties] Properties to set
         */
    function QrCodeNewDevice(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeNewDevice request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.request = null;

    /**
         * QrCodeNewDevice appName.
         * @member {string} appName
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.appName = '';

    /**
         * QrCodeNewDevice appId.
         * @member {number} appId
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.appId = 0;

    /**
         * QrCodeNewDevice appBuildVersion.
         * @member {number} appBuildVersion
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.appBuildVersion = 0;

    /**
         * QrCodeNewDevice appVersion.
         * @member {string} appVersion
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.appVersion = '';

    /**
         * QrCodeNewDevice platform.
         * @member {proto.Platform} platform
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.platform = 0;

    /**
         * QrCodeNewDevice platformVersion.
         * @member {string} platformVersion
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.platformVersion = '';

    /**
         * QrCodeNewDevice device.
         * @member {proto.Device} device
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.device = 0;

    /**
         * QrCodeNewDevice deviceName.
         * @member {string} deviceName
         * @memberof proto.QrCodeNewDevice
         * @instance
         */
    QrCodeNewDevice.prototype.deviceName = '';

    /**
         * Creates a new QrCodeNewDevice instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeNewDevice
         * @static
         * @param {proto.IQrCodeNewDevice=} [properties] Properties to set
         * @returns {proto.QrCodeNewDevice} QrCodeNewDevice instance
         */
    QrCodeNewDevice.create = function create(properties) {
      return new QrCodeNewDevice(properties);
    };

    /**
         * Encodes the specified QrCodeNewDevice message. Does not implicitly {@link proto.QrCodeNewDevice.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeNewDevice
         * @static
         * @param {proto.QrCodeNewDevice} message QrCodeNewDevice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeNewDevice.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.appName != null && message.hasOwnProperty('appName')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.appName);}
      if (message.appId != null && message.hasOwnProperty('appId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.appId);}
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.appBuildVersion);}
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.appVersion);}
      if (message.platform != null && message.hasOwnProperty('platform')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.platform);}
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.platformVersion);}
      if (message.device != null && message.hasOwnProperty('device')) {writer.uint32(/* id 8, wireType 0 =*/64).int32(message.device);}
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceName);}
      return writer;
    };

    /**
         * Decodes a QrCodeNewDevice message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeNewDevice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeNewDevice} QrCodeNewDevice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeNewDevice.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeNewDevice();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.appName = reader.string();
            break;
          case 3:
            message.appId = reader.uint32();
            break;
          case 4:
            message.appBuildVersion = reader.uint32();
            break;
          case 5:
            message.appVersion = reader.string();
            break;
          case 6:
            message.platform = reader.int32();
            break;
          case 7:
            message.platformVersion = reader.string();
            break;
          case 8:
            message.device = reader.int32();
            break;
          case 9:
            message.deviceName = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeNewDevice message.
         * @function verify
         * @memberof proto.QrCodeNewDevice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeNewDevice.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.appName != null && message.hasOwnProperty('appName')) {
        if (!$util.isString(message.appName)) {return 'appName: string expected';}
      }
      if (message.appId != null && message.hasOwnProperty('appId')) {
        if (!$util.isInteger(message.appId)) {return 'appId: integer expected';}
      }
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {
        if (!$util.isInteger(message.appBuildVersion)) {return 'appBuildVersion: integer expected';}
      }
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {
        if (!$util.isString(message.appVersion)) {return 'appVersion: string expected';}
      }
      if (message.platform != null && message.hasOwnProperty('platform')) {
        switch (message.platform) {
          default:
            return 'platform: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      }
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {
        if (!$util.isString(message.platformVersion)) {return 'platformVersion: string expected';}
      }
      if (message.device != null && message.hasOwnProperty('device')) {
        switch (message.device) {
          default:
            return 'device: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {
        if (!$util.isString(message.deviceName)) {return 'deviceName: string expected';}
      }
      return null;
    };

    return QrCodeNewDevice;
  })();

  proto.QrCodeNewDeviceResponse = (function() {

    /**
         * Properties of a QrCodeNewDeviceResponse.
         * @memberof proto
         * @interface IQrCodeNewDeviceResponse
         * @property {proto.Response|null} [response] QrCodeNewDeviceResponse response
         * @property {Uint8Array|null} [qrCodeImage] QrCodeNewDeviceResponse qrCodeImage
         * @property {number|null} [expireTime] QrCodeNewDeviceResponse expireTime
         */

    /**
         * Constructs a new QrCodeNewDeviceResponse.
         * @memberof proto
         * @classdesc Represents a QrCodeNewDeviceResponse.
         * @implements IQrCodeNewDeviceResponse
         * @constructor
         * @param {proto.IQrCodeNewDeviceResponse=} [properties] Properties to set
         */
    function QrCodeNewDeviceResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeNewDeviceResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.QrCodeNewDeviceResponse
         * @instance
         */
    QrCodeNewDeviceResponse.prototype.response = null;

    /**
         * QrCodeNewDeviceResponse qrCodeImage.
         * @member {Uint8Array} qrCodeImage
         * @memberof proto.QrCodeNewDeviceResponse
         * @instance
         */
    QrCodeNewDeviceResponse.prototype.qrCodeImage = $util.newBuffer([]);

    /**
         * QrCodeNewDeviceResponse expireTime.
         * @member {number} expireTime
         * @memberof proto.QrCodeNewDeviceResponse
         * @instance
         */
    QrCodeNewDeviceResponse.prototype.expireTime = 0;

    /**
         * Creates a new QrCodeNewDeviceResponse instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeNewDeviceResponse
         * @static
         * @param {proto.IQrCodeNewDeviceResponse=} [properties] Properties to set
         * @returns {proto.QrCodeNewDeviceResponse} QrCodeNewDeviceResponse instance
         */
    QrCodeNewDeviceResponse.create = function create(properties) {
      return new QrCodeNewDeviceResponse(properties);
    };

    /**
         * Encodes the specified QrCodeNewDeviceResponse message. Does not implicitly {@link proto.QrCodeNewDeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeNewDeviceResponse
         * @static
         * @param {proto.QrCodeNewDeviceResponse} message QrCodeNewDeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeNewDeviceResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.qrCodeImage);}
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expireTime);}
      return writer;
    };

    /**
         * Decodes a QrCodeNewDeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeNewDeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeNewDeviceResponse} QrCodeNewDeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeNewDeviceResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeNewDeviceResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.qrCodeImage = reader.bytes();
            break;
          case 3:
            message.expireTime = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeNewDeviceResponse message.
         * @function verify
         * @memberof proto.QrCodeNewDeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeNewDeviceResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {
        if (!(message.qrCodeImage && typeof message.qrCodeImage.length === 'number' || $util.isString(message.qrCodeImage))) {return 'qrCodeImage: buffer expected';}
      }
      if (message.expireTime != null && message.hasOwnProperty('expireTime')) {
        if (!$util.isInteger(message.expireTime)) {return 'expireTime: integer expected';}
      }
      return null;
    };

    return QrCodeNewDeviceResponse;
  })();

  proto.QrCodeResolve = (function() {

    /**
         * Properties of a QrCodeResolve.
         * @memberof proto
         * @interface IQrCodeResolve
         * @property {proto.Request|null} [request] QrCodeResolve request
         * @property {string|null} [username] QrCodeResolve username
         * @property {Long|null} [messageId] QrCodeResolve messageId
         */

    /**
         * Constructs a new QrCodeResolve.
         * @memberof proto
         * @classdesc Represents a QrCodeResolve.
         * @implements IQrCodeResolve
         * @constructor
         * @param {proto.IQrCodeResolve=} [properties] Properties to set
         */
    function QrCodeResolve(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeResolve request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.QrCodeResolve
         * @instance
         */
    QrCodeResolve.prototype.request = null;

    /**
         * QrCodeResolve username.
         * @member {string} username
         * @memberof proto.QrCodeResolve
         * @instance
         */
    QrCodeResolve.prototype.username = '';

    /**
         * QrCodeResolve messageId.
         * @member {Long} messageId
         * @memberof proto.QrCodeResolve
         * @instance
         */
    QrCodeResolve.prototype.messageId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new QrCodeResolve instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeResolve
         * @static
         * @param {proto.IQrCodeResolve=} [properties] Properties to set
         * @returns {proto.QrCodeResolve} QrCodeResolve instance
         */
    QrCodeResolve.create = function create(properties) {
      return new QrCodeResolve(properties);
    };

    /**
         * Encodes the specified QrCodeResolve message. Does not implicitly {@link proto.QrCodeResolve.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeResolve
         * @static
         * @param {proto.QrCodeResolve} message QrCodeResolve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeResolve.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.messageId != null && message.hasOwnProperty('messageId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);}
      return writer;
    };

    /**
         * Decodes a QrCodeResolve message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeResolve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeResolve} QrCodeResolve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeResolve.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeResolve();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.messageId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeResolve message.
         * @function verify
         * @memberof proto.QrCodeResolve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeResolve.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.messageId != null && message.hasOwnProperty('messageId')) {
        if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high))) {return 'messageId: integer|Long expected';}
      }
      return null;
    };

    return QrCodeResolve;
  })();

  proto.QrCodeResolveResponse = (function() {

    /**
         * Properties of a QrCodeResolveResponse.
         * @memberof proto
         * @interface IQrCodeResolveResponse
         * @property {proto.Response|null} [response] QrCodeResolveResponse response
         * @property {Uint8Array|null} [qrCodeImage] QrCodeResolveResponse qrCodeImage
         */

    /**
         * Constructs a new QrCodeResolveResponse.
         * @memberof proto
         * @classdesc Represents a QrCodeResolveResponse.
         * @implements IQrCodeResolveResponse
         * @constructor
         * @param {proto.IQrCodeResolveResponse=} [properties] Properties to set
         */
    function QrCodeResolveResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * QrCodeResolveResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.QrCodeResolveResponse
         * @instance
         */
    QrCodeResolveResponse.prototype.response = null;

    /**
         * QrCodeResolveResponse qrCodeImage.
         * @member {Uint8Array} qrCodeImage
         * @memberof proto.QrCodeResolveResponse
         * @instance
         */
    QrCodeResolveResponse.prototype.qrCodeImage = $util.newBuffer([]);

    /**
         * Creates a new QrCodeResolveResponse instance using the specified properties.
         * @function create
         * @memberof proto.QrCodeResolveResponse
         * @static
         * @param {proto.IQrCodeResolveResponse=} [properties] Properties to set
         * @returns {proto.QrCodeResolveResponse} QrCodeResolveResponse instance
         */
    QrCodeResolveResponse.create = function create(properties) {
      return new QrCodeResolveResponse(properties);
    };

    /**
         * Encodes the specified QrCodeResolveResponse message. Does not implicitly {@link proto.QrCodeResolveResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.QrCodeResolveResponse
         * @static
         * @param {proto.QrCodeResolveResponse} message QrCodeResolveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    QrCodeResolveResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.qrCodeImage);}
      return writer;
    };

    /**
         * Decodes a QrCodeResolveResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QrCodeResolveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.QrCodeResolveResponse} QrCodeResolveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    QrCodeResolveResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.QrCodeResolveResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.qrCodeImage = reader.bytes();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a QrCodeResolveResponse message.
         * @function verify
         * @memberof proto.QrCodeResolveResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    QrCodeResolveResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.qrCodeImage != null && message.hasOwnProperty('qrCodeImage')) {
        if (!(message.qrCodeImage && typeof message.qrCodeImage.length === 'number' || $util.isString(message.qrCodeImage))) {return 'qrCodeImage: buffer expected';}
      }
      return null;
    };

    return QrCodeResolveResponse;
  })();

  proto.SignalingAccept = (function() {

    /**
         * Properties of a SignalingAccept.
         * @memberof proto
         * @interface ISignalingAccept
         * @property {proto.Request|null} [request] SignalingAccept request
         * @property {string|null} [calledSdp] SignalingAccept calledSdp
         */

    /**
         * Constructs a new SignalingAccept.
         * @memberof proto
         * @classdesc Represents a SignalingAccept.
         * @implements ISignalingAccept
         * @constructor
         * @param {proto.ISignalingAccept=} [properties] Properties to set
         */
    function SignalingAccept(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingAccept request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingAccept
         * @instance
         */
    SignalingAccept.prototype.request = null;

    /**
         * SignalingAccept calledSdp.
         * @member {string} calledSdp
         * @memberof proto.SignalingAccept
         * @instance
         */
    SignalingAccept.prototype.calledSdp = '';

    /**
         * Creates a new SignalingAccept instance using the specified properties.
         * @function create
         * @memberof proto.SignalingAccept
         * @static
         * @param {proto.ISignalingAccept=} [properties] Properties to set
         * @returns {proto.SignalingAccept} SignalingAccept instance
         */
    SignalingAccept.create = function create(properties) {
      return new SignalingAccept(properties);
    };

    /**
         * Encodes the specified SignalingAccept message. Does not implicitly {@link proto.SignalingAccept.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingAccept
         * @static
         * @param {proto.SignalingAccept} message SignalingAccept message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingAccept.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.calledSdp != null && message.hasOwnProperty('calledSdp')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.calledSdp);}
      return writer;
    };

    /**
         * Decodes a SignalingAccept message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingAccept
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingAccept} SignalingAccept
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingAccept.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingAccept();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.calledSdp = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingAccept message.
         * @function verify
         * @memberof proto.SignalingAccept
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingAccept.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.calledSdp != null && message.hasOwnProperty('calledSdp')) {
        if (!$util.isString(message.calledSdp)) {return 'calledSdp: string expected';}
      }
      return null;
    };

    return SignalingAccept;
  })();

  proto.SignalingAcceptResponse = (function() {

    /**
         * Properties of a SignalingAcceptResponse.
         * @memberof proto
         * @interface ISignalingAcceptResponse
         * @property {proto.Response|null} [response] SignalingAcceptResponse response
         * @property {string|null} [calledSdp] SignalingAcceptResponse calledSdp
         */

    /**
         * Constructs a new SignalingAcceptResponse.
         * @memberof proto
         * @classdesc Represents a SignalingAcceptResponse.
         * @implements ISignalingAcceptResponse
         * @constructor
         * @param {proto.ISignalingAcceptResponse=} [properties] Properties to set
         */
    function SignalingAcceptResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingAcceptResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingAcceptResponse
         * @instance
         */
    SignalingAcceptResponse.prototype.response = null;

    /**
         * SignalingAcceptResponse calledSdp.
         * @member {string} calledSdp
         * @memberof proto.SignalingAcceptResponse
         * @instance
         */
    SignalingAcceptResponse.prototype.calledSdp = '';

    /**
         * Creates a new SignalingAcceptResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingAcceptResponse
         * @static
         * @param {proto.ISignalingAcceptResponse=} [properties] Properties to set
         * @returns {proto.SignalingAcceptResponse} SignalingAcceptResponse instance
         */
    SignalingAcceptResponse.create = function create(properties) {
      return new SignalingAcceptResponse(properties);
    };

    /**
         * Encodes the specified SignalingAcceptResponse message. Does not implicitly {@link proto.SignalingAcceptResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingAcceptResponse
         * @static
         * @param {proto.SignalingAcceptResponse} message SignalingAcceptResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingAcceptResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.calledSdp != null && message.hasOwnProperty('calledSdp')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.calledSdp);}
      return writer;
    };

    /**
         * Decodes a SignalingAcceptResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingAcceptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingAcceptResponse} SignalingAcceptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingAcceptResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingAcceptResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.calledSdp = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingAcceptResponse message.
         * @function verify
         * @memberof proto.SignalingAcceptResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingAcceptResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.calledSdp != null && message.hasOwnProperty('calledSdp')) {
        if (!$util.isString(message.calledSdp)) {return 'calledSdp: string expected';}
      }
      return null;
    };

    return SignalingAcceptResponse;
  })();

  proto.SignalingCandidate = (function() {

    /**
         * Properties of a SignalingCandidate.
         * @memberof proto
         * @interface ISignalingCandidate
         * @property {proto.Request|null} [request] SignalingCandidate request
         * @property {string|null} [candidate] SignalingCandidate candidate
         * @property {string|null} [sdpMId] SignalingCandidate sdpMId
         * @property {number|null} [sdpMLineIndex] SignalingCandidate sdpMLineIndex
         */

    /**
         * Constructs a new SignalingCandidate.
         * @memberof proto
         * @classdesc Represents a SignalingCandidate.
         * @implements ISignalingCandidate
         * @constructor
         * @param {proto.ISignalingCandidate=} [properties] Properties to set
         */
    function SignalingCandidate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingCandidate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingCandidate
         * @instance
         */
    SignalingCandidate.prototype.request = null;

    /**
         * SignalingCandidate candidate.
         * @member {string} candidate
         * @memberof proto.SignalingCandidate
         * @instance
         */
    SignalingCandidate.prototype.candidate = '';

    /**
         * SignalingCandidate sdpMId.
         * @member {string} sdpMId
         * @memberof proto.SignalingCandidate
         * @instance
         */
    SignalingCandidate.prototype.sdpMId = '';

    /**
         * SignalingCandidate sdpMLineIndex.
         * @member {number} sdpMLineIndex
         * @memberof proto.SignalingCandidate
         * @instance
         */
    SignalingCandidate.prototype.sdpMLineIndex = 0;

    /**
         * Creates a new SignalingCandidate instance using the specified properties.
         * @function create
         * @memberof proto.SignalingCandidate
         * @static
         * @param {proto.ISignalingCandidate=} [properties] Properties to set
         * @returns {proto.SignalingCandidate} SignalingCandidate instance
         */
    SignalingCandidate.create = function create(properties) {
      return new SignalingCandidate(properties);
    };

    /**
         * Encodes the specified SignalingCandidate message. Does not implicitly {@link proto.SignalingCandidate.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingCandidate
         * @static
         * @param {proto.SignalingCandidate} message SignalingCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingCandidate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.candidate != null && message.hasOwnProperty('candidate')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.candidate);}
      if (message.sdpMId != null && message.hasOwnProperty('sdpMId')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.sdpMId);}
      if (message.sdpMLineIndex != null && message.hasOwnProperty('sdpMLineIndex')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sdpMLineIndex);}
      return writer;
    };

    /**
         * Decodes a SignalingCandidate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingCandidate} SignalingCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingCandidate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingCandidate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.candidate = reader.string();
            break;
          case 3:
            message.sdpMId = reader.string();
            break;
          case 4:
            message.sdpMLineIndex = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingCandidate message.
         * @function verify
         * @memberof proto.SignalingCandidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingCandidate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.candidate != null && message.hasOwnProperty('candidate')) {
        if (!$util.isString(message.candidate)) {return 'candidate: string expected';}
      }
      if (message.sdpMId != null && message.hasOwnProperty('sdpMId')) {
        if (!$util.isString(message.sdpMId)) {return 'sdpMId: string expected';}
      }
      if (message.sdpMLineIndex != null && message.hasOwnProperty('sdpMLineIndex')) {
        if (!$util.isInteger(message.sdpMLineIndex)) {return 'sdpMLineIndex: integer expected';}
      }
      return null;
    };

    return SignalingCandidate;
  })();

  proto.SignalingCandidateResponse = (function() {

    /**
         * Properties of a SignalingCandidateResponse.
         * @memberof proto
         * @interface ISignalingCandidateResponse
         * @property {proto.Response|null} [response] SignalingCandidateResponse response
         * @property {string|null} [peerCandidate] SignalingCandidateResponse peerCandidate
         * @property {string|null} [peerSdpMId] SignalingCandidateResponse peerSdpMId
         * @property {number|null} [peerSdpMLineIndex] SignalingCandidateResponse peerSdpMLineIndex
         */

    /**
         * Constructs a new SignalingCandidateResponse.
         * @memberof proto
         * @classdesc Represents a SignalingCandidateResponse.
         * @implements ISignalingCandidateResponse
         * @constructor
         * @param {proto.ISignalingCandidateResponse=} [properties] Properties to set
         */
    function SignalingCandidateResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingCandidateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingCandidateResponse
         * @instance
         */
    SignalingCandidateResponse.prototype.response = null;

    /**
         * SignalingCandidateResponse peerCandidate.
         * @member {string} peerCandidate
         * @memberof proto.SignalingCandidateResponse
         * @instance
         */
    SignalingCandidateResponse.prototype.peerCandidate = '';

    /**
         * SignalingCandidateResponse peerSdpMId.
         * @member {string} peerSdpMId
         * @memberof proto.SignalingCandidateResponse
         * @instance
         */
    SignalingCandidateResponse.prototype.peerSdpMId = '';

    /**
         * SignalingCandidateResponse peerSdpMLineIndex.
         * @member {number} peerSdpMLineIndex
         * @memberof proto.SignalingCandidateResponse
         * @instance
         */
    SignalingCandidateResponse.prototype.peerSdpMLineIndex = 0;

    /**
         * Creates a new SignalingCandidateResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingCandidateResponse
         * @static
         * @param {proto.ISignalingCandidateResponse=} [properties] Properties to set
         * @returns {proto.SignalingCandidateResponse} SignalingCandidateResponse instance
         */
    SignalingCandidateResponse.create = function create(properties) {
      return new SignalingCandidateResponse(properties);
    };

    /**
         * Encodes the specified SignalingCandidateResponse message. Does not implicitly {@link proto.SignalingCandidateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingCandidateResponse
         * @static
         * @param {proto.SignalingCandidateResponse} message SignalingCandidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingCandidateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.peerCandidate != null && message.hasOwnProperty('peerCandidate')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.peerCandidate);}
      if (message.peerSdpMId != null && message.hasOwnProperty('peerSdpMId')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.peerSdpMId);}
      if (message.peerSdpMLineIndex != null && message.hasOwnProperty('peerSdpMLineIndex')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.peerSdpMLineIndex);}
      return writer;
    };

    /**
         * Decodes a SignalingCandidateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingCandidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingCandidateResponse} SignalingCandidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingCandidateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingCandidateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.peerCandidate = reader.string();
            break;
          case 3:
            message.peerSdpMId = reader.string();
            break;
          case 4:
            message.peerSdpMLineIndex = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingCandidateResponse message.
         * @function verify
         * @memberof proto.SignalingCandidateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingCandidateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.peerCandidate != null && message.hasOwnProperty('peerCandidate')) {
        if (!$util.isString(message.peerCandidate)) {return 'peerCandidate: string expected';}
      }
      if (message.peerSdpMId != null && message.hasOwnProperty('peerSdpMId')) {
        if (!$util.isString(message.peerSdpMId)) {return 'peerSdpMId: string expected';}
      }
      if (message.peerSdpMLineIndex != null && message.hasOwnProperty('peerSdpMLineIndex')) {
        if (!$util.isInteger(message.peerSdpMLineIndex)) {return 'peerSdpMLineIndex: integer expected';}
      }
      return null;
    };

    return SignalingCandidateResponse;
  })();

  proto.SignalingClearLog = (function() {

    /**
         * Properties of a SignalingClearLog.
         * @memberof proto
         * @interface ISignalingClearLog
         * @property {proto.Request|null} [request] SignalingClearLog request
         * @property {Long|null} [clearId] SignalingClearLog clearId
         */

    /**
         * Constructs a new SignalingClearLog.
         * @memberof proto
         * @classdesc Represents a SignalingClearLog.
         * @implements ISignalingClearLog
         * @constructor
         * @param {proto.ISignalingClearLog=} [properties] Properties to set
         */
    function SignalingClearLog(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingClearLog request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingClearLog
         * @instance
         */
    SignalingClearLog.prototype.request = null;

    /**
         * SignalingClearLog clearId.
         * @member {Long} clearId
         * @memberof proto.SignalingClearLog
         * @instance
         */
    SignalingClearLog.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new SignalingClearLog instance using the specified properties.
         * @function create
         * @memberof proto.SignalingClearLog
         * @static
         * @param {proto.ISignalingClearLog=} [properties] Properties to set
         * @returns {proto.SignalingClearLog} SignalingClearLog instance
         */
    SignalingClearLog.create = function create(properties) {
      return new SignalingClearLog(properties);
    };

    /**
         * Encodes the specified SignalingClearLog message. Does not implicitly {@link proto.SignalingClearLog.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingClearLog
         * @static
         * @param {proto.SignalingClearLog} message SignalingClearLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingClearLog.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a SignalingClearLog message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingClearLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingClearLog} SignalingClearLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingClearLog.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingClearLog();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingClearLog message.
         * @function verify
         * @memberof proto.SignalingClearLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingClearLog.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return SignalingClearLog;
  })();

  proto.SignalingClearLogResponse = (function() {

    /**
         * Properties of a SignalingClearLogResponse.
         * @memberof proto
         * @interface ISignalingClearLogResponse
         * @property {proto.Response|null} [response] SignalingClearLogResponse response
         * @property {Long|null} [clearId] SignalingClearLogResponse clearId
         */

    /**
         * Constructs a new SignalingClearLogResponse.
         * @memberof proto
         * @classdesc Represents a SignalingClearLogResponse.
         * @implements ISignalingClearLogResponse
         * @constructor
         * @param {proto.ISignalingClearLogResponse=} [properties] Properties to set
         */
    function SignalingClearLogResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingClearLogResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingClearLogResponse
         * @instance
         */
    SignalingClearLogResponse.prototype.response = null;

    /**
         * SignalingClearLogResponse clearId.
         * @member {Long} clearId
         * @memberof proto.SignalingClearLogResponse
         * @instance
         */
    SignalingClearLogResponse.prototype.clearId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new SignalingClearLogResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingClearLogResponse
         * @static
         * @param {proto.ISignalingClearLogResponse=} [properties] Properties to set
         * @returns {proto.SignalingClearLogResponse} SignalingClearLogResponse instance
         */
    SignalingClearLogResponse.create = function create(properties) {
      return new SignalingClearLogResponse(properties);
    };

    /**
         * Encodes the specified SignalingClearLogResponse message. Does not implicitly {@link proto.SignalingClearLogResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingClearLogResponse
         * @static
         * @param {proto.SignalingClearLogResponse} message SignalingClearLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingClearLogResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.clearId != null && message.hasOwnProperty('clearId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clearId);}
      return writer;
    };

    /**
         * Decodes a SignalingClearLogResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingClearLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingClearLogResponse} SignalingClearLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingClearLogResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingClearLogResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.clearId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingClearLogResponse message.
         * @function verify
         * @memberof proto.SignalingClearLogResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingClearLogResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.clearId != null && message.hasOwnProperty('clearId')) {
        if (!$util.isInteger(message.clearId) && !(message.clearId && $util.isInteger(message.clearId.low) && $util.isInteger(message.clearId.high))) {return 'clearId: integer|Long expected';}
      }
      return null;
    };

    return SignalingClearLogResponse;
  })();

  proto.SignalingGetConfiguration = (function() {

    /**
         * Properties of a SignalingGetConfiguration.
         * @memberof proto
         * @interface ISignalingGetConfiguration
         * @property {proto.Request|null} [request] SignalingGetConfiguration request
         */

    /**
         * Constructs a new SignalingGetConfiguration.
         * @memberof proto
         * @classdesc Represents a SignalingGetConfiguration.
         * @implements ISignalingGetConfiguration
         * @constructor
         * @param {proto.ISignalingGetConfiguration=} [properties] Properties to set
         */
    function SignalingGetConfiguration(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingGetConfiguration request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingGetConfiguration
         * @instance
         */
    SignalingGetConfiguration.prototype.request = null;

    /**
         * Creates a new SignalingGetConfiguration instance using the specified properties.
         * @function create
         * @memberof proto.SignalingGetConfiguration
         * @static
         * @param {proto.ISignalingGetConfiguration=} [properties] Properties to set
         * @returns {proto.SignalingGetConfiguration} SignalingGetConfiguration instance
         */
    SignalingGetConfiguration.create = function create(properties) {
      return new SignalingGetConfiguration(properties);
    };

    /**
         * Encodes the specified SignalingGetConfiguration message. Does not implicitly {@link proto.SignalingGetConfiguration.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingGetConfiguration
         * @static
         * @param {proto.SignalingGetConfiguration} message SignalingGetConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingGetConfiguration.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingGetConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingGetConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingGetConfiguration} SignalingGetConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingGetConfiguration.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetConfiguration();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingGetConfiguration message.
         * @function verify
         * @memberof proto.SignalingGetConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingGetConfiguration.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return SignalingGetConfiguration;
  })();

  proto.SignalingGetConfigurationResponse = (function() {

    /**
         * Properties of a SignalingGetConfigurationResponse.
         * @memberof proto
         * @interface ISignalingGetConfigurationResponse
         * @property {proto.Response|null} [response] SignalingGetConfigurationResponse response
         * @property {Array.<proto.SignalingGetConfigurationResponse.IceServer>|null} [iceServer] SignalingGetConfigurationResponse iceServer
         * @property {boolean|null} [voiceCalling] SignalingGetConfigurationResponse voiceCalling
         * @property {boolean|null} [videoCalling] SignalingGetConfigurationResponse videoCalling
         * @property {boolean|null} [screenSharing] SignalingGetConfigurationResponse screenSharing
         * @property {boolean|null} [secretChat] SignalingGetConfigurationResponse secretChat
         */

    /**
         * Constructs a new SignalingGetConfigurationResponse.
         * @memberof proto
         * @classdesc Represents a SignalingGetConfigurationResponse.
         * @implements ISignalingGetConfigurationResponse
         * @constructor
         * @param {proto.ISignalingGetConfigurationResponse=} [properties] Properties to set
         */
    function SignalingGetConfigurationResponse(properties) {
      this.iceServer = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingGetConfigurationResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.response = null;

    /**
         * SignalingGetConfigurationResponse iceServer.
         * @member {Array.<proto.SignalingGetConfigurationResponse.IceServer>} iceServer
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.iceServer = $util.emptyArray;

    /**
         * SignalingGetConfigurationResponse voiceCalling.
         * @member {boolean} voiceCalling
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.voiceCalling = false;

    /**
         * SignalingGetConfigurationResponse videoCalling.
         * @member {boolean} videoCalling
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.videoCalling = false;

    /**
         * SignalingGetConfigurationResponse screenSharing.
         * @member {boolean} screenSharing
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.screenSharing = false;

    /**
         * SignalingGetConfigurationResponse secretChat.
         * @member {boolean} secretChat
         * @memberof proto.SignalingGetConfigurationResponse
         * @instance
         */
    SignalingGetConfigurationResponse.prototype.secretChat = false;

    /**
         * Creates a new SignalingGetConfigurationResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingGetConfigurationResponse
         * @static
         * @param {proto.ISignalingGetConfigurationResponse=} [properties] Properties to set
         * @returns {proto.SignalingGetConfigurationResponse} SignalingGetConfigurationResponse instance
         */
    SignalingGetConfigurationResponse.create = function create(properties) {
      return new SignalingGetConfigurationResponse(properties);
    };

    /**
         * Encodes the specified SignalingGetConfigurationResponse message. Does not implicitly {@link proto.SignalingGetConfigurationResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingGetConfigurationResponse
         * @static
         * @param {proto.SignalingGetConfigurationResponse} message SignalingGetConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingGetConfigurationResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.iceServer != null && message.iceServer.length) {
        for (let i = 0; i < message.iceServer.length; ++i) {$root.proto.SignalingGetConfigurationResponse.IceServer.encode(message.iceServer[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      if (message.voiceCalling != null && message.hasOwnProperty('voiceCalling')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.voiceCalling);}
      if (message.videoCalling != null && message.hasOwnProperty('videoCalling')) {writer.uint32(/* id 4, wireType 0 =*/32).bool(message.videoCalling);}
      if (message.screenSharing != null && message.hasOwnProperty('screenSharing')) {writer.uint32(/* id 5, wireType 0 =*/40).bool(message.screenSharing);}
      if (message.secretChat != null && message.hasOwnProperty('secretChat')) {writer.uint32(/* id 6, wireType 0 =*/48).bool(message.secretChat);}
      return writer;
    };

    /**
         * Decodes a SignalingGetConfigurationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingGetConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingGetConfigurationResponse} SignalingGetConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingGetConfigurationResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetConfigurationResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.iceServer && message.iceServer.length)) {message.iceServer = [];}
            message.iceServer.push($root.proto.SignalingGetConfigurationResponse.IceServer.decode(reader, reader.uint32()));
            break;
          case 3:
            message.voiceCalling = reader.bool();
            break;
          case 4:
            message.videoCalling = reader.bool();
            break;
          case 5:
            message.screenSharing = reader.bool();
            break;
          case 6:
            message.secretChat = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingGetConfigurationResponse message.
         * @function verify
         * @memberof proto.SignalingGetConfigurationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingGetConfigurationResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.iceServer != null && message.hasOwnProperty('iceServer')) {
        if (!Array.isArray(message.iceServer)) {return 'iceServer: array expected';}
        for (let i = 0; i < message.iceServer.length; ++i) {
          let error = $root.proto.SignalingGetConfigurationResponse.IceServer.verify(message.iceServer[i]);
          if (error) {return 'iceServer.' + error;}
        }
      }
      if (message.voiceCalling != null && message.hasOwnProperty('voiceCalling')) {
        if (typeof message.voiceCalling !== 'boolean') {return 'voiceCalling: boolean expected';}
      }
      if (message.videoCalling != null && message.hasOwnProperty('videoCalling')) {
        if (typeof message.videoCalling !== 'boolean') {return 'videoCalling: boolean expected';}
      }
      if (message.screenSharing != null && message.hasOwnProperty('screenSharing')) {
        if (typeof message.screenSharing !== 'boolean') {return 'screenSharing: boolean expected';}
      }
      if (message.secretChat != null && message.hasOwnProperty('secretChat')) {
        if (typeof message.secretChat !== 'boolean') {return 'secretChat: boolean expected';}
      }
      return null;
    };

    SignalingGetConfigurationResponse.IceServer = (function() {

      /**
             * Properties of an IceServer.
             * @memberof proto.SignalingGetConfigurationResponse
             * @interface IIceServer
             * @property {string|null} [url] IceServer url
             * @property {string|null} [credential] IceServer credential
             * @property {string|null} [username] IceServer username
             */

      /**
             * Constructs a new IceServer.
             * @memberof proto.SignalingGetConfigurationResponse
             * @classdesc Represents an IceServer.
             * @implements IIceServer
             * @constructor
             * @param {proto.SignalingGetConfigurationResponse.IIceServer=} [properties] Properties to set
             */
      function IceServer(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * IceServer url.
             * @member {string} url
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @instance
             */
      IceServer.prototype.url = '';

      /**
             * IceServer credential.
             * @member {string} credential
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @instance
             */
      IceServer.prototype.credential = '';

      /**
             * IceServer username.
             * @member {string} username
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @instance
             */
      IceServer.prototype.username = '';

      /**
             * Creates a new IceServer instance using the specified properties.
             * @function create
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @static
             * @param {proto.SignalingGetConfigurationResponse.IIceServer=} [properties] Properties to set
             * @returns {proto.SignalingGetConfigurationResponse.IceServer} IceServer instance
             */
      IceServer.create = function create(properties) {
        return new IceServer(properties);
      };

      /**
             * Encodes the specified IceServer message. Does not implicitly {@link proto.SignalingGetConfigurationResponse.IceServer.verify|verify} messages.
             * @function encode
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @static
             * @param {proto.SignalingGetConfigurationResponse.IceServer} message IceServer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      IceServer.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.url != null && message.hasOwnProperty('url')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);}
        if (message.credential != null && message.hasOwnProperty('credential')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.credential);}
        if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);}
        return writer;
      };

      /**
             * Decodes an IceServer message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SignalingGetConfigurationResponse.IceServer} IceServer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      IceServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetConfigurationResponse.IceServer();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.url = reader.string();
              break;
            case 2:
              message.credential = reader.string();
              break;
            case 3:
              message.username = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies an IceServer message.
             * @function verify
             * @memberof proto.SignalingGetConfigurationResponse.IceServer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      IceServer.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.url != null && message.hasOwnProperty('url')) {
          if (!$util.isString(message.url)) {return 'url: string expected';}
        }
        if (message.credential != null && message.hasOwnProperty('credential')) {
          if (!$util.isString(message.credential)) {return 'credential: string expected';}
        }
        if (message.username != null && message.hasOwnProperty('username')) {
          if (!$util.isString(message.username)) {return 'username: string expected';}
        }
        return null;
      };

      return IceServer;
    })();

    return SignalingGetConfigurationResponse;
  })();

  proto.SignalingGetLog = (function() {

    /**
         * Properties of a SignalingGetLog.
         * @memberof proto
         * @interface ISignalingGetLog
         * @property {proto.Request|null} [request] SignalingGetLog request
         * @property {proto.Pagination|null} [pagination] SignalingGetLog pagination
         */

    /**
         * Constructs a new SignalingGetLog.
         * @memberof proto
         * @classdesc Represents a SignalingGetLog.
         * @implements ISignalingGetLog
         * @constructor
         * @param {proto.ISignalingGetLog=} [properties] Properties to set
         */
    function SignalingGetLog(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingGetLog request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingGetLog
         * @instance
         */
    SignalingGetLog.prototype.request = null;

    /**
         * SignalingGetLog pagination.
         * @member {proto.Pagination|null|undefined} pagination
         * @memberof proto.SignalingGetLog
         * @instance
         */
    SignalingGetLog.prototype.pagination = null;

    /**
         * Creates a new SignalingGetLog instance using the specified properties.
         * @function create
         * @memberof proto.SignalingGetLog
         * @static
         * @param {proto.ISignalingGetLog=} [properties] Properties to set
         * @returns {proto.SignalingGetLog} SignalingGetLog instance
         */
    SignalingGetLog.create = function create(properties) {
      return new SignalingGetLog(properties);
    };

    /**
         * Encodes the specified SignalingGetLog message. Does not implicitly {@link proto.SignalingGetLog.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingGetLog
         * @static
         * @param {proto.SignalingGetLog} message SignalingGetLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingGetLog.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.pagination != null && message.hasOwnProperty('pagination')) {$root.proto.Pagination.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingGetLog message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingGetLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingGetLog} SignalingGetLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingGetLog.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetLog();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.pagination = $root.proto.Pagination.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingGetLog message.
         * @function verify
         * @memberof proto.SignalingGetLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingGetLog.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.pagination != null && message.hasOwnProperty('pagination')) {
        let error = $root.proto.Pagination.verify(message.pagination);
        if (error) {return 'pagination.' + error;}
      }
      return null;
    };

    return SignalingGetLog;
  })();

  proto.SignalingGetLogResponse = (function() {

    /**
         * Properties of a SignalingGetLogResponse.
         * @memberof proto
         * @interface ISignalingGetLogResponse
         * @property {proto.Response|null} [response] SignalingGetLogResponse response
         * @property {Array.<proto.SignalingGetLogResponse.SignalingLog>|null} [signalingLog] SignalingGetLogResponse signalingLog
         */

    /**
         * Constructs a new SignalingGetLogResponse.
         * @memberof proto
         * @classdesc Represents a SignalingGetLogResponse.
         * @implements ISignalingGetLogResponse
         * @constructor
         * @param {proto.ISignalingGetLogResponse=} [properties] Properties to set
         */
    function SignalingGetLogResponse(properties) {
      this.signalingLog = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingGetLogResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingGetLogResponse
         * @instance
         */
    SignalingGetLogResponse.prototype.response = null;

    /**
         * SignalingGetLogResponse signalingLog.
         * @member {Array.<proto.SignalingGetLogResponse.SignalingLog>} signalingLog
         * @memberof proto.SignalingGetLogResponse
         * @instance
         */
    SignalingGetLogResponse.prototype.signalingLog = $util.emptyArray;

    /**
         * Creates a new SignalingGetLogResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingGetLogResponse
         * @static
         * @param {proto.ISignalingGetLogResponse=} [properties] Properties to set
         * @returns {proto.SignalingGetLogResponse} SignalingGetLogResponse instance
         */
    SignalingGetLogResponse.create = function create(properties) {
      return new SignalingGetLogResponse(properties);
    };

    /**
         * Encodes the specified SignalingGetLogResponse message. Does not implicitly {@link proto.SignalingGetLogResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingGetLogResponse
         * @static
         * @param {proto.SignalingGetLogResponse} message SignalingGetLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingGetLogResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.signalingLog != null && message.signalingLog.length) {
        for (let i = 0; i < message.signalingLog.length; ++i) {$root.proto.SignalingGetLogResponse.SignalingLog.encode(message.signalingLog[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a SignalingGetLogResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingGetLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingGetLogResponse} SignalingGetLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingGetLogResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetLogResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.signalingLog && message.signalingLog.length)) {message.signalingLog = [];}
            message.signalingLog.push($root.proto.SignalingGetLogResponse.SignalingLog.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingGetLogResponse message.
         * @function verify
         * @memberof proto.SignalingGetLogResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingGetLogResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.signalingLog != null && message.hasOwnProperty('signalingLog')) {
        if (!Array.isArray(message.signalingLog)) {return 'signalingLog: array expected';}
        for (let i = 0; i < message.signalingLog.length; ++i) {
          let error = $root.proto.SignalingGetLogResponse.SignalingLog.verify(message.signalingLog[i]);
          if (error) {return 'signalingLog.' + error;}
        }
      }
      return null;
    };

    SignalingGetLogResponse.SignalingLog = (function() {

      /**
             * Properties of a SignalingLog.
             * @memberof proto.SignalingGetLogResponse
             * @interface ISignalingLog
             * @property {Long|null} [id] SignalingLog id
             * @property {proto.SignalingOffer.Type|null} [type] SignalingLog type
             * @property {proto.SignalingGetLogResponse.SignalingLog.Status|null} [status] SignalingLog status
             * @property {proto.RegisteredUser|null} [peer] SignalingLog peer
             * @property {number|null} [offerTime] SignalingLog offerTime
             * @property {number|null} [duration] SignalingLog duration
             */

      /**
             * Constructs a new SignalingLog.
             * @memberof proto.SignalingGetLogResponse
             * @classdesc Represents a SignalingLog.
             * @implements ISignalingLog
             * @constructor
             * @param {proto.SignalingGetLogResponse.ISignalingLog=} [properties] Properties to set
             */
      function SignalingLog(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * SignalingLog id.
             * @member {Long} id
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * SignalingLog type.
             * @member {proto.SignalingOffer.Type} type
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.type = 0;

      /**
             * SignalingLog status.
             * @member {proto.SignalingGetLogResponse.SignalingLog.Status} status
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.status = 0;

      /**
             * SignalingLog peer.
             * @member {proto.RegisteredUser|null|undefined} peer
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.peer = null;

      /**
             * SignalingLog offerTime.
             * @member {number} offerTime
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.offerTime = 0;

      /**
             * SignalingLog duration.
             * @member {number} duration
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @instance
             */
      SignalingLog.prototype.duration = 0;

      /**
             * Creates a new SignalingLog instance using the specified properties.
             * @function create
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @static
             * @param {proto.SignalingGetLogResponse.ISignalingLog=} [properties] Properties to set
             * @returns {proto.SignalingGetLogResponse.SignalingLog} SignalingLog instance
             */
      SignalingLog.create = function create(properties) {
        return new SignalingLog(properties);
      };

      /**
             * Encodes the specified SignalingLog message. Does not implicitly {@link proto.SignalingGetLogResponse.SignalingLog.verify|verify} messages.
             * @function encode
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @static
             * @param {proto.SignalingGetLogResponse.SignalingLog} message SignalingLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      SignalingLog.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);}
        if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
        if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);}
        if (message.peer != null && message.hasOwnProperty('peer')) {$root.proto.RegisteredUser.encode(message.peer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();}
        if (message.offerTime != null && message.hasOwnProperty('offerTime')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.offerTime);}
        if (message.duration != null && message.hasOwnProperty('duration')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.duration);}
        return writer;
      };

      /**
             * Decodes a SignalingLog message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SignalingGetLogResponse.SignalingLog} SignalingLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      SignalingLog.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingGetLogResponse.SignalingLog();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.type = reader.int32();
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.peer = $root.proto.RegisteredUser.decode(reader, reader.uint32());
              break;
            case 5:
              message.offerTime = reader.uint32();
              break;
            case 6:
              message.duration = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a SignalingLog message.
             * @function verify
             * @memberof proto.SignalingGetLogResponse.SignalingLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      SignalingLog.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.id != null && message.hasOwnProperty('id')) {
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
        }
        if (message.type != null && message.hasOwnProperty('type')) {
          switch (message.type) {
            default:
              return 'type: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        }
        if (message.status != null && message.hasOwnProperty('status')) {
          switch (message.status) {
            default:
              return 'status: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        }
        if (message.peer != null && message.hasOwnProperty('peer')) {
          let error = $root.proto.RegisteredUser.verify(message.peer);
          if (error) {return 'peer.' + error;}
        }
        if (message.offerTime != null && message.hasOwnProperty('offerTime')) {
          if (!$util.isInteger(message.offerTime)) {return 'offerTime: integer expected';}
        }
        if (message.duration != null && message.hasOwnProperty('duration')) {
          if (!$util.isInteger(message.duration)) {return 'duration: integer expected';}
        }
        return null;
      };

      /**
             * Status enum.
             * @name proto.SignalingGetLogResponse.SignalingLog.Status
             * @enum {string}
             * @property {number} MISSED=0 MISSED value
             * @property {number} CANCELED=1 CANCELED value
             * @property {number} INCOMING=2 INCOMING value
             * @property {number} OUTGOING=3 OUTGOING value
             */
      SignalingLog.Status = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = 'MISSED'] = 0;
        values[valuesById[1] = 'CANCELED'] = 1;
        values[valuesById[2] = 'INCOMING'] = 2;
        values[valuesById[3] = 'OUTGOING'] = 3;
        return values;
      })();

      return SignalingLog;
    })();

    return SignalingGetLogResponse;
  })();

  proto.SignalingOffer = (function() {

    /**
         * Properties of a SignalingOffer.
         * @memberof proto
         * @interface ISignalingOffer
         * @property {proto.Request|null} [request] SignalingOffer request
         * @property {Long|null} [calledUserId] SignalingOffer calledUserId
         * @property {proto.SignalingOffer.Type|null} [type] SignalingOffer type
         * @property {string|null} [callerSdp] SignalingOffer callerSdp
         */

    /**
         * Constructs a new SignalingOffer.
         * @memberof proto
         * @classdesc Represents a SignalingOffer.
         * @implements ISignalingOffer
         * @constructor
         * @param {proto.ISignalingOffer=} [properties] Properties to set
         */
    function SignalingOffer(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingOffer request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingOffer
         * @instance
         */
    SignalingOffer.prototype.request = null;

    /**
         * SignalingOffer calledUserId.
         * @member {Long} calledUserId
         * @memberof proto.SignalingOffer
         * @instance
         */
    SignalingOffer.prototype.calledUserId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * SignalingOffer type.
         * @member {proto.SignalingOffer.Type} type
         * @memberof proto.SignalingOffer
         * @instance
         */
    SignalingOffer.prototype.type = 0;

    /**
         * SignalingOffer callerSdp.
         * @member {string} callerSdp
         * @memberof proto.SignalingOffer
         * @instance
         */
    SignalingOffer.prototype.callerSdp = '';

    /**
         * Creates a new SignalingOffer instance using the specified properties.
         * @function create
         * @memberof proto.SignalingOffer
         * @static
         * @param {proto.ISignalingOffer=} [properties] Properties to set
         * @returns {proto.SignalingOffer} SignalingOffer instance
         */
    SignalingOffer.create = function create(properties) {
      return new SignalingOffer(properties);
    };

    /**
         * Encodes the specified SignalingOffer message. Does not implicitly {@link proto.SignalingOffer.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingOffer
         * @static
         * @param {proto.SignalingOffer} message SignalingOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingOffer.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.calledUserId != null && message.hasOwnProperty('calledUserId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.calledUserId);}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);}
      if (message.callerSdp != null && message.hasOwnProperty('callerSdp')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.callerSdp);}
      return writer;
    };

    /**
         * Decodes a SignalingOffer message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingOffer} SignalingOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingOffer.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingOffer();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.calledUserId = reader.uint64();
            break;
          case 3:
            message.type = reader.int32();
            break;
          case 4:
            message.callerSdp = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingOffer message.
         * @function verify
         * @memberof proto.SignalingOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingOffer.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.calledUserId != null && message.hasOwnProperty('calledUserId')) {
        if (!$util.isInteger(message.calledUserId) && !(message.calledUserId && $util.isInteger(message.calledUserId.low) && $util.isInteger(message.calledUserId.high))) {return 'calledUserId: integer|Long expected';}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.callerSdp != null && message.hasOwnProperty('callerSdp')) {
        if (!$util.isString(message.callerSdp)) {return 'callerSdp: string expected';}
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.SignalingOffer.Type
         * @enum {string}
         * @property {number} VOICE_CALLING=0 VOICE_CALLING value
         * @property {number} VIDEO_CALLING=1 VIDEO_CALLING value
         * @property {number} SCREEN_SHARING=2 SCREEN_SHARING value
         * @property {number} SECRET_CHAT=3 SECRET_CHAT value
         */
    SignalingOffer.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'VOICE_CALLING'] = 0;
      values[valuesById[1] = 'VIDEO_CALLING'] = 1;
      values[valuesById[2] = 'SCREEN_SHARING'] = 2;
      values[valuesById[3] = 'SECRET_CHAT'] = 3;
      return values;
    })();

    return SignalingOffer;
  })();

  proto.SignalingOfferResponse = (function() {

    /**
         * Properties of a SignalingOfferResponse.
         * @memberof proto
         * @interface ISignalingOfferResponse
         * @property {proto.Response|null} [response] SignalingOfferResponse response
         * @property {Long|null} [callerUserId] SignalingOfferResponse callerUserId
         * @property {proto.SignalingOffer.Type|null} [type] SignalingOfferResponse type
         * @property {string|null} [callerSdp] SignalingOfferResponse callerSdp
         */

    /**
         * Constructs a new SignalingOfferResponse.
         * @memberof proto
         * @classdesc Represents a SignalingOfferResponse.
         * @implements ISignalingOfferResponse
         * @constructor
         * @param {proto.ISignalingOfferResponse=} [properties] Properties to set
         */
    function SignalingOfferResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingOfferResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingOfferResponse
         * @instance
         */
    SignalingOfferResponse.prototype.response = null;

    /**
         * SignalingOfferResponse callerUserId.
         * @member {Long} callerUserId
         * @memberof proto.SignalingOfferResponse
         * @instance
         */
    SignalingOfferResponse.prototype.callerUserId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * SignalingOfferResponse type.
         * @member {proto.SignalingOffer.Type} type
         * @memberof proto.SignalingOfferResponse
         * @instance
         */
    SignalingOfferResponse.prototype.type = 0;

    /**
         * SignalingOfferResponse callerSdp.
         * @member {string} callerSdp
         * @memberof proto.SignalingOfferResponse
         * @instance
         */
    SignalingOfferResponse.prototype.callerSdp = '';

    /**
         * Creates a new SignalingOfferResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingOfferResponse
         * @static
         * @param {proto.ISignalingOfferResponse=} [properties] Properties to set
         * @returns {proto.SignalingOfferResponse} SignalingOfferResponse instance
         */
    SignalingOfferResponse.create = function create(properties) {
      return new SignalingOfferResponse(properties);
    };

    /**
         * Encodes the specified SignalingOfferResponse message. Does not implicitly {@link proto.SignalingOfferResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingOfferResponse
         * @static
         * @param {proto.SignalingOfferResponse} message SignalingOfferResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingOfferResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.callerUserId != null && message.hasOwnProperty('callerUserId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.callerUserId);}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);}
      if (message.callerSdp != null && message.hasOwnProperty('callerSdp')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.callerSdp);}
      return writer;
    };

    /**
         * Decodes a SignalingOfferResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingOfferResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingOfferResponse} SignalingOfferResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingOfferResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingOfferResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.callerUserId = reader.uint64();
            break;
          case 3:
            message.type = reader.int32();
            break;
          case 4:
            message.callerSdp = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingOfferResponse message.
         * @function verify
         * @memberof proto.SignalingOfferResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingOfferResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.callerUserId != null && message.hasOwnProperty('callerUserId')) {
        if (!$util.isInteger(message.callerUserId) && !(message.callerUserId && $util.isInteger(message.callerUserId.low) && $util.isInteger(message.callerUserId.high))) {return 'callerUserId: integer|Long expected';}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.callerSdp != null && message.hasOwnProperty('callerSdp')) {
        if (!$util.isString(message.callerSdp)) {return 'callerSdp: string expected';}
      }
      return null;
    };

    return SignalingOfferResponse;
  })();

  proto.SignalingLeave = (function() {

    /**
         * Properties of a SignalingLeave.
         * @memberof proto
         * @interface ISignalingLeave
         * @property {proto.Request|null} [request] SignalingLeave request
         */

    /**
         * Constructs a new SignalingLeave.
         * @memberof proto
         * @classdesc Represents a SignalingLeave.
         * @implements ISignalingLeave
         * @constructor
         * @param {proto.ISignalingLeave=} [properties] Properties to set
         */
    function SignalingLeave(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingLeave request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingLeave
         * @instance
         */
    SignalingLeave.prototype.request = null;

    /**
         * Creates a new SignalingLeave instance using the specified properties.
         * @function create
         * @memberof proto.SignalingLeave
         * @static
         * @param {proto.ISignalingLeave=} [properties] Properties to set
         * @returns {proto.SignalingLeave} SignalingLeave instance
         */
    SignalingLeave.create = function create(properties) {
      return new SignalingLeave(properties);
    };

    /**
         * Encodes the specified SignalingLeave message. Does not implicitly {@link proto.SignalingLeave.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingLeave
         * @static
         * @param {proto.SignalingLeave} message SignalingLeave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingLeave.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingLeave message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingLeave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingLeave} SignalingLeave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingLeave.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingLeave();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingLeave message.
         * @function verify
         * @memberof proto.SignalingLeave
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingLeave.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return SignalingLeave;
  })();

  proto.SignalingLeaveResponse = (function() {

    /**
         * Properties of a SignalingLeaveResponse.
         * @memberof proto
         * @interface ISignalingLeaveResponse
         * @property {proto.Response|null} [response] SignalingLeaveResponse response
         * @property {proto.SignalingLeaveResponse.Type|null} [type] SignalingLeaveResponse type
         */

    /**
         * Constructs a new SignalingLeaveResponse.
         * @memberof proto
         * @classdesc Represents a SignalingLeaveResponse.
         * @implements ISignalingLeaveResponse
         * @constructor
         * @param {proto.ISignalingLeaveResponse=} [properties] Properties to set
         */
    function SignalingLeaveResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingLeaveResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingLeaveResponse
         * @instance
         */
    SignalingLeaveResponse.prototype.response = null;

    /**
         * SignalingLeaveResponse type.
         * @member {proto.SignalingLeaveResponse.Type} type
         * @memberof proto.SignalingLeaveResponse
         * @instance
         */
    SignalingLeaveResponse.prototype.type = 0;

    /**
         * Creates a new SignalingLeaveResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingLeaveResponse
         * @static
         * @param {proto.ISignalingLeaveResponse=} [properties] Properties to set
         * @returns {proto.SignalingLeaveResponse} SignalingLeaveResponse instance
         */
    SignalingLeaveResponse.create = function create(properties) {
      return new SignalingLeaveResponse(properties);
    };

    /**
         * Encodes the specified SignalingLeaveResponse message. Does not implicitly {@link proto.SignalingLeaveResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingLeaveResponse
         * @static
         * @param {proto.SignalingLeaveResponse} message SignalingLeaveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingLeaveResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      return writer;
    };

    /**
         * Decodes a SignalingLeaveResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingLeaveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingLeaveResponse} SignalingLeaveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingLeaveResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingLeaveResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.type = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingLeaveResponse message.
         * @function verify
         * @memberof proto.SignalingLeaveResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingLeaveResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      }
      return null;
    };

    /**
         * Type enum.
         * @name proto.SignalingLeaveResponse.Type
         * @enum {string}
         * @property {number} MISSED=0 MISSED value
         * @property {number} REJECTED=1 REJECTED value
         * @property {number} ACCEPTED=2 ACCEPTED value
         * @property {number} NOT_ANSWERED=3 NOT_ANSWERED value
         * @property {number} UNAVAILABLE=4 UNAVAILABLE value
         * @property {number} DISCONNECTED=5 DISCONNECTED value
         * @property {number} FINISHED=6 FINISHED value
         * @property {number} TOO_LONG=7 TOO_LONG value
         */
    SignalingLeaveResponse.Type = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'MISSED'] = 0;
      values[valuesById[1] = 'REJECTED'] = 1;
      values[valuesById[2] = 'ACCEPTED'] = 2;
      values[valuesById[3] = 'NOT_ANSWERED'] = 3;
      values[valuesById[4] = 'UNAVAILABLE'] = 4;
      values[valuesById[5] = 'DISCONNECTED'] = 5;
      values[valuesById[6] = 'FINISHED'] = 6;
      values[valuesById[7] = 'TOO_LONG'] = 7;
      return values;
    })();

    return SignalingLeaveResponse;
  })();

  proto.SignalingRate = (function() {

    /**
         * Properties of a SignalingRate.
         * @memberof proto
         * @interface ISignalingRate
         * @property {proto.Request|null} [request] SignalingRate request
         * @property {Long|null} [id] SignalingRate id
         * @property {number|null} [rate] SignalingRate rate
         * @property {string|null} [reason] SignalingRate reason
         */

    /**
         * Constructs a new SignalingRate.
         * @memberof proto
         * @classdesc Represents a SignalingRate.
         * @implements ISignalingRate
         * @constructor
         * @param {proto.ISignalingRate=} [properties] Properties to set
         */
    function SignalingRate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingRate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingRate
         * @instance
         */
    SignalingRate.prototype.request = null;

    /**
         * SignalingRate id.
         * @member {Long} id
         * @memberof proto.SignalingRate
         * @instance
         */
    SignalingRate.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * SignalingRate rate.
         * @member {number} rate
         * @memberof proto.SignalingRate
         * @instance
         */
    SignalingRate.prototype.rate = 0;

    /**
         * SignalingRate reason.
         * @member {string} reason
         * @memberof proto.SignalingRate
         * @instance
         */
    SignalingRate.prototype.reason = '';

    /**
         * Creates a new SignalingRate instance using the specified properties.
         * @function create
         * @memberof proto.SignalingRate
         * @static
         * @param {proto.ISignalingRate=} [properties] Properties to set
         * @returns {proto.SignalingRate} SignalingRate instance
         */
    SignalingRate.create = function create(properties) {
      return new SignalingRate(properties);
    };

    /**
         * Encodes the specified SignalingRate message. Does not implicitly {@link proto.SignalingRate.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingRate
         * @static
         * @param {proto.SignalingRate} message SignalingRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingRate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      if (message.rate != null && message.hasOwnProperty('rate')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.rate);}
      if (message.reason != null && message.hasOwnProperty('reason')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);}
      return writer;
    };

    /**
         * Decodes a SignalingRate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingRate} SignalingRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingRate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingRate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          case 3:
            message.rate = reader.uint32();
            break;
          case 4:
            message.reason = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingRate message.
         * @function verify
         * @memberof proto.SignalingRate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingRate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      if (message.rate != null && message.hasOwnProperty('rate')) {
        if (!$util.isInteger(message.rate)) {return 'rate: integer expected';}
      }
      if (message.reason != null && message.hasOwnProperty('reason')) {
        if (!$util.isString(message.reason)) {return 'reason: string expected';}
      }
      return null;
    };

    return SignalingRate;
  })();

  proto.SignalingRateResponse = (function() {

    /**
         * Properties of a SignalingRateResponse.
         * @memberof proto
         * @interface ISignalingRateResponse
         * @property {proto.Response|null} [response] SignalingRateResponse response
         */

    /**
         * Constructs a new SignalingRateResponse.
         * @memberof proto
         * @classdesc Represents a SignalingRateResponse.
         * @implements ISignalingRateResponse
         * @constructor
         * @param {proto.ISignalingRateResponse=} [properties] Properties to set
         */
    function SignalingRateResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingRateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingRateResponse
         * @instance
         */
    SignalingRateResponse.prototype.response = null;

    /**
         * Creates a new SignalingRateResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingRateResponse
         * @static
         * @param {proto.ISignalingRateResponse=} [properties] Properties to set
         * @returns {proto.SignalingRateResponse} SignalingRateResponse instance
         */
    SignalingRateResponse.create = function create(properties) {
      return new SignalingRateResponse(properties);
    };

    /**
         * Encodes the specified SignalingRateResponse message. Does not implicitly {@link proto.SignalingRateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingRateResponse
         * @static
         * @param {proto.SignalingRateResponse} message SignalingRateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingRateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingRateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingRateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingRateResponse} SignalingRateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingRateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingRateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingRateResponse message.
         * @function verify
         * @memberof proto.SignalingRateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingRateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return SignalingRateResponse;
  })();

  proto.SignalingRinging = (function() {

    /**
         * Properties of a SignalingRinging.
         * @memberof proto
         * @interface ISignalingRinging
         * @property {proto.Request|null} [request] SignalingRinging request
         */

    /**
         * Constructs a new SignalingRinging.
         * @memberof proto
         * @classdesc Represents a SignalingRinging.
         * @implements ISignalingRinging
         * @constructor
         * @param {proto.ISignalingRinging=} [properties] Properties to set
         */
    function SignalingRinging(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingRinging request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingRinging
         * @instance
         */
    SignalingRinging.prototype.request = null;

    /**
         * Creates a new SignalingRinging instance using the specified properties.
         * @function create
         * @memberof proto.SignalingRinging
         * @static
         * @param {proto.ISignalingRinging=} [properties] Properties to set
         * @returns {proto.SignalingRinging} SignalingRinging instance
         */
    SignalingRinging.create = function create(properties) {
      return new SignalingRinging(properties);
    };

    /**
         * Encodes the specified SignalingRinging message. Does not implicitly {@link proto.SignalingRinging.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingRinging
         * @static
         * @param {proto.SignalingRinging} message SignalingRinging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingRinging.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingRinging message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingRinging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingRinging} SignalingRinging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingRinging.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingRinging();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingRinging message.
         * @function verify
         * @memberof proto.SignalingRinging
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingRinging.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return SignalingRinging;
  })();

  proto.SignalingRingingResponse = (function() {

    /**
         * Properties of a SignalingRingingResponse.
         * @memberof proto
         * @interface ISignalingRingingResponse
         * @property {proto.Response|null} [response] SignalingRingingResponse response
         */

    /**
         * Constructs a new SignalingRingingResponse.
         * @memberof proto
         * @classdesc Represents a SignalingRingingResponse.
         * @implements ISignalingRingingResponse
         * @constructor
         * @param {proto.ISignalingRingingResponse=} [properties] Properties to set
         */
    function SignalingRingingResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingRingingResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingRingingResponse
         * @instance
         */
    SignalingRingingResponse.prototype.response = null;

    /**
         * Creates a new SignalingRingingResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingRingingResponse
         * @static
         * @param {proto.ISignalingRingingResponse=} [properties] Properties to set
         * @returns {proto.SignalingRingingResponse} SignalingRingingResponse instance
         */
    SignalingRingingResponse.create = function create(properties) {
      return new SignalingRingingResponse(properties);
    };

    /**
         * Encodes the specified SignalingRingingResponse message. Does not implicitly {@link proto.SignalingRingingResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingRingingResponse
         * @static
         * @param {proto.SignalingRingingResponse} message SignalingRingingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingRingingResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a SignalingRingingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingRingingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingRingingResponse} SignalingRingingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingRingingResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingRingingResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingRingingResponse message.
         * @function verify
         * @memberof proto.SignalingRingingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingRingingResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return SignalingRingingResponse;
  })();

  proto.SignalingSessionHold = (function() {

    /**
         * Properties of a SignalingSessionHold.
         * @memberof proto
         * @interface ISignalingSessionHold
         * @property {proto.Request|null} [request] SignalingSessionHold request
         * @property {boolean|null} [hold] SignalingSessionHold hold
         */

    /**
         * Constructs a new SignalingSessionHold.
         * @memberof proto
         * @classdesc Represents a SignalingSessionHold.
         * @implements ISignalingSessionHold
         * @constructor
         * @param {proto.ISignalingSessionHold=} [properties] Properties to set
         */
    function SignalingSessionHold(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingSessionHold request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.SignalingSessionHold
         * @instance
         */
    SignalingSessionHold.prototype.request = null;

    /**
         * SignalingSessionHold hold.
         * @member {boolean} hold
         * @memberof proto.SignalingSessionHold
         * @instance
         */
    SignalingSessionHold.prototype.hold = false;

    /**
         * Creates a new SignalingSessionHold instance using the specified properties.
         * @function create
         * @memberof proto.SignalingSessionHold
         * @static
         * @param {proto.ISignalingSessionHold=} [properties] Properties to set
         * @returns {proto.SignalingSessionHold} SignalingSessionHold instance
         */
    SignalingSessionHold.create = function create(properties) {
      return new SignalingSessionHold(properties);
    };

    /**
         * Encodes the specified SignalingSessionHold message. Does not implicitly {@link proto.SignalingSessionHold.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingSessionHold
         * @static
         * @param {proto.SignalingSessionHold} message SignalingSessionHold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingSessionHold.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.hold != null && message.hasOwnProperty('hold')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hold);}
      return writer;
    };

    /**
         * Decodes a SignalingSessionHold message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingSessionHold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingSessionHold} SignalingSessionHold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingSessionHold.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingSessionHold();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.hold = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingSessionHold message.
         * @function verify
         * @memberof proto.SignalingSessionHold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingSessionHold.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.hold != null && message.hasOwnProperty('hold')) {
        if (typeof message.hold !== 'boolean') {return 'hold: boolean expected';}
      }
      return null;
    };

    return SignalingSessionHold;
  })();

  proto.SignalingSessionHoldResponse = (function() {

    /**
         * Properties of a SignalingSessionHoldResponse.
         * @memberof proto
         * @interface ISignalingSessionHoldResponse
         * @property {proto.Response|null} [response] SignalingSessionHoldResponse response
         * @property {boolean|null} [hold] SignalingSessionHoldResponse hold
         */

    /**
         * Constructs a new SignalingSessionHoldResponse.
         * @memberof proto
         * @classdesc Represents a SignalingSessionHoldResponse.
         * @implements ISignalingSessionHoldResponse
         * @constructor
         * @param {proto.ISignalingSessionHoldResponse=} [properties] Properties to set
         */
    function SignalingSessionHoldResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * SignalingSessionHoldResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.SignalingSessionHoldResponse
         * @instance
         */
    SignalingSessionHoldResponse.prototype.response = null;

    /**
         * SignalingSessionHoldResponse hold.
         * @member {boolean} hold
         * @memberof proto.SignalingSessionHoldResponse
         * @instance
         */
    SignalingSessionHoldResponse.prototype.hold = false;

    /**
         * Creates a new SignalingSessionHoldResponse instance using the specified properties.
         * @function create
         * @memberof proto.SignalingSessionHoldResponse
         * @static
         * @param {proto.ISignalingSessionHoldResponse=} [properties] Properties to set
         * @returns {proto.SignalingSessionHoldResponse} SignalingSessionHoldResponse instance
         */
    SignalingSessionHoldResponse.create = function create(properties) {
      return new SignalingSessionHoldResponse(properties);
    };

    /**
         * Encodes the specified SignalingSessionHoldResponse message. Does not implicitly {@link proto.SignalingSessionHoldResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.SignalingSessionHoldResponse
         * @static
         * @param {proto.SignalingSessionHoldResponse} message SignalingSessionHoldResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    SignalingSessionHoldResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.hold != null && message.hasOwnProperty('hold')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hold);}
      return writer;
    };

    /**
         * Decodes a SignalingSessionHoldResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignalingSessionHoldResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignalingSessionHoldResponse} SignalingSessionHoldResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    SignalingSessionHoldResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignalingSessionHoldResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.hold = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a SignalingSessionHoldResponse message.
         * @function verify
         * @memberof proto.SignalingSessionHoldResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    SignalingSessionHoldResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.hold != null && message.hasOwnProperty('hold')) {
        if (typeof message.hold !== 'boolean') {return 'hold: boolean expected';}
      }
      return null;
    };

    return SignalingSessionHoldResponse;
  })();

  proto.UserAvatarAdd = (function() {

    /**
         * Properties of a UserAvatarAdd.
         * @memberof proto
         * @interface IUserAvatarAdd
         * @property {proto.Request|null} [request] UserAvatarAdd request
         * @property {string|null} [attachment] UserAvatarAdd attachment
         */

    /**
         * Constructs a new UserAvatarAdd.
         * @memberof proto
         * @classdesc Represents a UserAvatarAdd.
         * @implements IUserAvatarAdd
         * @constructor
         * @param {proto.IUserAvatarAdd=} [properties] Properties to set
         */
    function UserAvatarAdd(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarAdd request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserAvatarAdd
         * @instance
         */
    UserAvatarAdd.prototype.request = null;

    /**
         * UserAvatarAdd attachment.
         * @member {string} attachment
         * @memberof proto.UserAvatarAdd
         * @instance
         */
    UserAvatarAdd.prototype.attachment = '';

    /**
         * Creates a new UserAvatarAdd instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarAdd
         * @static
         * @param {proto.IUserAvatarAdd=} [properties] Properties to set
         * @returns {proto.UserAvatarAdd} UserAvatarAdd instance
         */
    UserAvatarAdd.create = function create(properties) {
      return new UserAvatarAdd(properties);
    };

    /**
         * Encodes the specified UserAvatarAdd message. Does not implicitly {@link proto.UserAvatarAdd.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarAdd
         * @static
         * @param {proto.UserAvatarAdd} message UserAvatarAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarAdd.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.attachment != null && message.hasOwnProperty('attachment')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.attachment);}
      return writer;
    };

    /**
         * Decodes a UserAvatarAdd message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarAdd} UserAvatarAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarAdd.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarAdd();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.attachment = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarAdd message.
         * @function verify
         * @memberof proto.UserAvatarAdd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarAdd.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.attachment != null && message.hasOwnProperty('attachment')) {
        if (!$util.isString(message.attachment)) {return 'attachment: string expected';}
      }
      return null;
    };

    return UserAvatarAdd;
  })();

  proto.UserAvatarAddResponse = (function() {

    /**
         * Properties of a UserAvatarAddResponse.
         * @memberof proto
         * @interface IUserAvatarAddResponse
         * @property {proto.Response|null} [response] UserAvatarAddResponse response
         * @property {proto.Avatar|null} [avatar] UserAvatarAddResponse avatar
         */

    /**
         * Constructs a new UserAvatarAddResponse.
         * @memberof proto
         * @classdesc Represents a UserAvatarAddResponse.
         * @implements IUserAvatarAddResponse
         * @constructor
         * @param {proto.IUserAvatarAddResponse=} [properties] Properties to set
         */
    function UserAvatarAddResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarAddResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserAvatarAddResponse
         * @instance
         */
    UserAvatarAddResponse.prototype.response = null;

    /**
         * UserAvatarAddResponse avatar.
         * @member {proto.Avatar|null|undefined} avatar
         * @memberof proto.UserAvatarAddResponse
         * @instance
         */
    UserAvatarAddResponse.prototype.avatar = null;

    /**
         * Creates a new UserAvatarAddResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarAddResponse
         * @static
         * @param {proto.IUserAvatarAddResponse=} [properties] Properties to set
         * @returns {proto.UserAvatarAddResponse} UserAvatarAddResponse instance
         */
    UserAvatarAddResponse.create = function create(properties) {
      return new UserAvatarAddResponse(properties);
    };

    /**
         * Encodes the specified UserAvatarAddResponse message. Does not implicitly {@link proto.UserAvatarAddResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarAddResponse
         * @static
         * @param {proto.UserAvatarAddResponse} message UserAvatarAddResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarAddResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.hasOwnProperty('avatar')) {$root.proto.Avatar.encode(message.avatar, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserAvatarAddResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarAddResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarAddResponse} UserAvatarAddResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarAddResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.avatar = $root.proto.Avatar.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarAddResponse message.
         * @function verify
         * @memberof proto.UserAvatarAddResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarAddResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        let error = $root.proto.Avatar.verify(message.avatar);
        if (error) {return 'avatar.' + error;}
      }
      return null;
    };

    return UserAvatarAddResponse;
  })();

  proto.UserAvatarDelete = (function() {

    /**
         * Properties of a UserAvatarDelete.
         * @memberof proto
         * @interface IUserAvatarDelete
         * @property {proto.Request|null} [request] UserAvatarDelete request
         * @property {Long|null} [id] UserAvatarDelete id
         */

    /**
         * Constructs a new UserAvatarDelete.
         * @memberof proto
         * @classdesc Represents a UserAvatarDelete.
         * @implements IUserAvatarDelete
         * @constructor
         * @param {proto.IUserAvatarDelete=} [properties] Properties to set
         */
    function UserAvatarDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserAvatarDelete
         * @instance
         */
    UserAvatarDelete.prototype.request = null;

    /**
         * UserAvatarDelete id.
         * @member {Long} id
         * @memberof proto.UserAvatarDelete
         * @instance
         */
    UserAvatarDelete.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserAvatarDelete instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarDelete
         * @static
         * @param {proto.IUserAvatarDelete=} [properties] Properties to set
         * @returns {proto.UserAvatarDelete} UserAvatarDelete instance
         */
    UserAvatarDelete.create = function create(properties) {
      return new UserAvatarDelete(properties);
    };

    /**
         * Encodes the specified UserAvatarDelete message. Does not implicitly {@link proto.UserAvatarDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarDelete
         * @static
         * @param {proto.UserAvatarDelete} message UserAvatarDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      return writer;
    };

    /**
         * Decodes a UserAvatarDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarDelete} UserAvatarDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarDelete message.
         * @function verify
         * @memberof proto.UserAvatarDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      return null;
    };

    return UserAvatarDelete;
  })();

  proto.UserAvatarDeleteResponse = (function() {

    /**
         * Properties of a UserAvatarDeleteResponse.
         * @memberof proto
         * @interface IUserAvatarDeleteResponse
         * @property {proto.Response|null} [response] UserAvatarDeleteResponse response
         * @property {Long|null} [id] UserAvatarDeleteResponse id
         */

    /**
         * Constructs a new UserAvatarDeleteResponse.
         * @memberof proto
         * @classdesc Represents a UserAvatarDeleteResponse.
         * @implements IUserAvatarDeleteResponse
         * @constructor
         * @param {proto.IUserAvatarDeleteResponse=} [properties] Properties to set
         */
    function UserAvatarDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserAvatarDeleteResponse
         * @instance
         */
    UserAvatarDeleteResponse.prototype.response = null;

    /**
         * UserAvatarDeleteResponse id.
         * @member {Long} id
         * @memberof proto.UserAvatarDeleteResponse
         * @instance
         */
    UserAvatarDeleteResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserAvatarDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarDeleteResponse
         * @static
         * @param {proto.IUserAvatarDeleteResponse=} [properties] Properties to set
         * @returns {proto.UserAvatarDeleteResponse} UserAvatarDeleteResponse instance
         */
    UserAvatarDeleteResponse.create = function create(properties) {
      return new UserAvatarDeleteResponse(properties);
    };

    /**
         * Encodes the specified UserAvatarDeleteResponse message. Does not implicitly {@link proto.UserAvatarDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarDeleteResponse
         * @static
         * @param {proto.UserAvatarDeleteResponse} message UserAvatarDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.id != null && message.hasOwnProperty('id')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);}
      return writer;
    };

    /**
         * Decodes a UserAvatarDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarDeleteResponse} UserAvatarDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.id = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarDeleteResponse message.
         * @function verify
         * @memberof proto.UserAvatarDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.id != null && message.hasOwnProperty('id')) {
        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))) {return 'id: integer|Long expected';}
      }
      return null;
    };

    return UserAvatarDeleteResponse;
  })();

  proto.UserAvatarGetList = (function() {

    /**
         * Properties of a UserAvatarGetList.
         * @memberof proto
         * @interface IUserAvatarGetList
         * @property {proto.Request|null} [request] UserAvatarGetList request
         * @property {Long|null} [userId] UserAvatarGetList userId
         */

    /**
         * Constructs a new UserAvatarGetList.
         * @memberof proto
         * @classdesc Represents a UserAvatarGetList.
         * @implements IUserAvatarGetList
         * @constructor
         * @param {proto.IUserAvatarGetList=} [properties] Properties to set
         */
    function UserAvatarGetList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarGetList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserAvatarGetList
         * @instance
         */
    UserAvatarGetList.prototype.request = null;

    /**
         * UserAvatarGetList userId.
         * @member {Long} userId
         * @memberof proto.UserAvatarGetList
         * @instance
         */
    UserAvatarGetList.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserAvatarGetList instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarGetList
         * @static
         * @param {proto.IUserAvatarGetList=} [properties] Properties to set
         * @returns {proto.UserAvatarGetList} UserAvatarGetList instance
         */
    UserAvatarGetList.create = function create(properties) {
      return new UserAvatarGetList(properties);
    };

    /**
         * Encodes the specified UserAvatarGetList message. Does not implicitly {@link proto.UserAvatarGetList.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarGetList
         * @static
         * @param {proto.UserAvatarGetList} message UserAvatarGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarGetList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserAvatarGetList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarGetList} UserAvatarGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarGetList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarGetList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarGetList message.
         * @function verify
         * @memberof proto.UserAvatarGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarGetList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserAvatarGetList;
  })();

  proto.UserAvatarGetListResponse = (function() {

    /**
         * Properties of a UserAvatarGetListResponse.
         * @memberof proto
         * @interface IUserAvatarGetListResponse
         * @property {proto.Response|null} [response] UserAvatarGetListResponse response
         * @property {Array.<proto.Avatar>|null} [avatar] UserAvatarGetListResponse avatar
         */

    /**
         * Constructs a new UserAvatarGetListResponse.
         * @memberof proto
         * @classdesc Represents a UserAvatarGetListResponse.
         * @implements IUserAvatarGetListResponse
         * @constructor
         * @param {proto.IUserAvatarGetListResponse=} [properties] Properties to set
         */
    function UserAvatarGetListResponse(properties) {
      this.avatar = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserAvatarGetListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserAvatarGetListResponse
         * @instance
         */
    UserAvatarGetListResponse.prototype.response = null;

    /**
         * UserAvatarGetListResponse avatar.
         * @member {Array.<proto.Avatar>} avatar
         * @memberof proto.UserAvatarGetListResponse
         * @instance
         */
    UserAvatarGetListResponse.prototype.avatar = $util.emptyArray;

    /**
         * Creates a new UserAvatarGetListResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserAvatarGetListResponse
         * @static
         * @param {proto.IUserAvatarGetListResponse=} [properties] Properties to set
         * @returns {proto.UserAvatarGetListResponse} UserAvatarGetListResponse instance
         */
    UserAvatarGetListResponse.create = function create(properties) {
      return new UserAvatarGetListResponse(properties);
    };

    /**
         * Encodes the specified UserAvatarGetListResponse message. Does not implicitly {@link proto.UserAvatarGetListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserAvatarGetListResponse
         * @static
         * @param {proto.UserAvatarGetListResponse} message UserAvatarGetListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserAvatarGetListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.avatar != null && message.avatar.length) {
        for (let i = 0; i < message.avatar.length; ++i) {$root.proto.Avatar.encode(message.avatar[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a UserAvatarGetListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserAvatarGetListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserAvatarGetListResponse} UserAvatarGetListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserAvatarGetListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserAvatarGetListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.avatar && message.avatar.length)) {message.avatar = [];}
            message.avatar.push($root.proto.Avatar.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserAvatarGetListResponse message.
         * @function verify
         * @memberof proto.UserAvatarGetListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserAvatarGetListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.avatar != null && message.hasOwnProperty('avatar')) {
        if (!Array.isArray(message.avatar)) {return 'avatar: array expected';}
        for (let i = 0; i < message.avatar.length; ++i) {
          let error = $root.proto.Avatar.verify(message.avatar[i]);
          if (error) {return 'avatar.' + error;}
        }
      }
      return null;
    };

    return UserAvatarGetListResponse;
  })();

  proto.UserContactsBlock = (function() {

    /**
         * Properties of a UserContactsBlock.
         * @memberof proto
         * @interface IUserContactsBlock
         * @property {proto.Request|null} [request] UserContactsBlock request
         * @property {Long|null} [userId] UserContactsBlock userId
         */

    /**
         * Constructs a new UserContactsBlock.
         * @memberof proto
         * @classdesc Represents a UserContactsBlock.
         * @implements IUserContactsBlock
         * @constructor
         * @param {proto.IUserContactsBlock=} [properties] Properties to set
         */
    function UserContactsBlock(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsBlock request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsBlock
         * @instance
         */
    UserContactsBlock.prototype.request = null;

    /**
         * UserContactsBlock userId.
         * @member {Long} userId
         * @memberof proto.UserContactsBlock
         * @instance
         */
    UserContactsBlock.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsBlock instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsBlock
         * @static
         * @param {proto.IUserContactsBlock=} [properties] Properties to set
         * @returns {proto.UserContactsBlock} UserContactsBlock instance
         */
    UserContactsBlock.create = function create(properties) {
      return new UserContactsBlock(properties);
    };

    /**
         * Encodes the specified UserContactsBlock message. Does not implicitly {@link proto.UserContactsBlock.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsBlock
         * @static
         * @param {proto.UserContactsBlock} message UserContactsBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsBlock.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserContactsBlock message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsBlock} UserContactsBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsBlock.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsBlock();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsBlock message.
         * @function verify
         * @memberof proto.UserContactsBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsBlock.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserContactsBlock;
  })();

  proto.UserContactsBlockResponse = (function() {

    /**
         * Properties of a UserContactsBlockResponse.
         * @memberof proto
         * @interface IUserContactsBlockResponse
         * @property {proto.Response|null} [response] UserContactsBlockResponse response
         * @property {Long|null} [userId] UserContactsBlockResponse userId
         */

    /**
         * Constructs a new UserContactsBlockResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsBlockResponse.
         * @implements IUserContactsBlockResponse
         * @constructor
         * @param {proto.IUserContactsBlockResponse=} [properties] Properties to set
         */
    function UserContactsBlockResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsBlockResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsBlockResponse
         * @instance
         */
    UserContactsBlockResponse.prototype.response = null;

    /**
         * UserContactsBlockResponse userId.
         * @member {Long} userId
         * @memberof proto.UserContactsBlockResponse
         * @instance
         */
    UserContactsBlockResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsBlockResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsBlockResponse
         * @static
         * @param {proto.IUserContactsBlockResponse=} [properties] Properties to set
         * @returns {proto.UserContactsBlockResponse} UserContactsBlockResponse instance
         */
    UserContactsBlockResponse.create = function create(properties) {
      return new UserContactsBlockResponse(properties);
    };

    /**
         * Encodes the specified UserContactsBlockResponse message. Does not implicitly {@link proto.UserContactsBlockResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsBlockResponse
         * @static
         * @param {proto.UserContactsBlockResponse} message UserContactsBlockResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsBlockResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserContactsBlockResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsBlockResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsBlockResponse} UserContactsBlockResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsBlockResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsBlockResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsBlockResponse message.
         * @function verify
         * @memberof proto.UserContactsBlockResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsBlockResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserContactsBlockResponse;
  })();

  proto.UserContactsDelete = (function() {

    /**
         * Properties of a UserContactsDelete.
         * @memberof proto
         * @interface IUserContactsDelete
         * @property {proto.Request|null} [request] UserContactsDelete request
         * @property {Long|null} [phone] UserContactsDelete phone
         */

    /**
         * Constructs a new UserContactsDelete.
         * @memberof proto
         * @classdesc Represents a UserContactsDelete.
         * @implements IUserContactsDelete
         * @constructor
         * @param {proto.IUserContactsDelete=} [properties] Properties to set
         */
    function UserContactsDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsDelete
         * @instance
         */
    UserContactsDelete.prototype.request = null;

    /**
         * UserContactsDelete phone.
         * @member {Long} phone
         * @memberof proto.UserContactsDelete
         * @instance
         */
    UserContactsDelete.prototype.phone = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsDelete instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsDelete
         * @static
         * @param {proto.IUserContactsDelete=} [properties] Properties to set
         * @returns {proto.UserContactsDelete} UserContactsDelete instance
         */
    UserContactsDelete.create = function create(properties) {
      return new UserContactsDelete(properties);
    };

    /**
         * Encodes the specified UserContactsDelete message. Does not implicitly {@link proto.UserContactsDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsDelete
         * @static
         * @param {proto.UserContactsDelete} message UserContactsDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.phone);}
      return writer;
    };

    /**
         * Decodes a UserContactsDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsDelete} UserContactsDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.phone = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsDelete message.
         * @function verify
         * @memberof proto.UserContactsDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isInteger(message.phone) && !(message.phone && $util.isInteger(message.phone.low) && $util.isInteger(message.phone.high))) {return 'phone: integer|Long expected';}
      }
      return null;
    };

    return UserContactsDelete;
  })();

  proto.UserContactsDeleteResponse = (function() {

    /**
         * Properties of a UserContactsDeleteResponse.
         * @memberof proto
         * @interface IUserContactsDeleteResponse
         * @property {proto.Response|null} [response] UserContactsDeleteResponse response
         * @property {Long|null} [phone] UserContactsDeleteResponse phone
         */

    /**
         * Constructs a new UserContactsDeleteResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsDeleteResponse.
         * @implements IUserContactsDeleteResponse
         * @constructor
         * @param {proto.IUserContactsDeleteResponse=} [properties] Properties to set
         */
    function UserContactsDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsDeleteResponse
         * @instance
         */
    UserContactsDeleteResponse.prototype.response = null;

    /**
         * UserContactsDeleteResponse phone.
         * @member {Long} phone
         * @memberof proto.UserContactsDeleteResponse
         * @instance
         */
    UserContactsDeleteResponse.prototype.phone = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsDeleteResponse
         * @static
         * @param {proto.IUserContactsDeleteResponse=} [properties] Properties to set
         * @returns {proto.UserContactsDeleteResponse} UserContactsDeleteResponse instance
         */
    UserContactsDeleteResponse.create = function create(properties) {
      return new UserContactsDeleteResponse(properties);
    };

    /**
         * Encodes the specified UserContactsDeleteResponse message. Does not implicitly {@link proto.UserContactsDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsDeleteResponse
         * @static
         * @param {proto.UserContactsDeleteResponse} message UserContactsDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.phone);}
      return writer;
    };

    /**
         * Decodes a UserContactsDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsDeleteResponse} UserContactsDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.phone = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsDeleteResponse message.
         * @function verify
         * @memberof proto.UserContactsDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isInteger(message.phone) && !(message.phone && $util.isInteger(message.phone.low) && $util.isInteger(message.phone.high))) {return 'phone: integer|Long expected';}
      }
      return null;
    };

    return UserContactsDeleteResponse;
  })();

  proto.UserContactsEdit = (function() {

    /**
         * Properties of a UserContactsEdit.
         * @memberof proto
         * @interface IUserContactsEdit
         * @property {proto.Request|null} [request] UserContactsEdit request
         * @property {Long|null} [phone] UserContactsEdit phone
         * @property {string|null} [firstName] UserContactsEdit firstName
         * @property {string|null} [lastName] UserContactsEdit lastName
         */

    /**
         * Constructs a new UserContactsEdit.
         * @memberof proto
         * @classdesc Represents a UserContactsEdit.
         * @implements IUserContactsEdit
         * @constructor
         * @param {proto.IUserContactsEdit=} [properties] Properties to set
         */
    function UserContactsEdit(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsEdit request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsEdit
         * @instance
         */
    UserContactsEdit.prototype.request = null;

    /**
         * UserContactsEdit phone.
         * @member {Long} phone
         * @memberof proto.UserContactsEdit
         * @instance
         */
    UserContactsEdit.prototype.phone = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * UserContactsEdit firstName.
         * @member {string} firstName
         * @memberof proto.UserContactsEdit
         * @instance
         */
    UserContactsEdit.prototype.firstName = '';

    /**
         * UserContactsEdit lastName.
         * @member {string} lastName
         * @memberof proto.UserContactsEdit
         * @instance
         */
    UserContactsEdit.prototype.lastName = '';

    /**
         * Creates a new UserContactsEdit instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsEdit
         * @static
         * @param {proto.IUserContactsEdit=} [properties] Properties to set
         * @returns {proto.UserContactsEdit} UserContactsEdit instance
         */
    UserContactsEdit.create = function create(properties) {
      return new UserContactsEdit(properties);
    };

    /**
         * Encodes the specified UserContactsEdit message. Does not implicitly {@link proto.UserContactsEdit.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsEdit
         * @static
         * @param {proto.UserContactsEdit} message UserContactsEdit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsEdit.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.phone);}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.firstName);}
      if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastName);}
      return writer;
    };

    /**
         * Decodes a UserContactsEdit message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsEdit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsEdit} UserContactsEdit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsEdit.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsEdit();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.phone = reader.uint64();
            break;
          case 3:
            message.firstName = reader.string();
            break;
          case 4:
            message.lastName = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsEdit message.
         * @function verify
         * @memberof proto.UserContactsEdit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsEdit.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isInteger(message.phone) && !(message.phone && $util.isInteger(message.phone.low) && $util.isInteger(message.phone.high))) {return 'phone: integer|Long expected';}
      }
      if (message.firstName != null && message.hasOwnProperty('firstName')) {
        if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
      }
      if (message.lastName != null && message.hasOwnProperty('lastName')) {
        if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
      }
      return null;
    };

    return UserContactsEdit;
  })();

  proto.UserContactsEditResponse = (function() {

    /**
         * Properties of a UserContactsEditResponse.
         * @memberof proto
         * @interface IUserContactsEditResponse
         * @property {proto.Response|null} [response] UserContactsEditResponse response
         * @property {Long|null} [phone] UserContactsEditResponse phone
         * @property {string|null} [firstName] UserContactsEditResponse firstName
         * @property {string|null} [lastName] UserContactsEditResponse lastName
         * @property {string|null} [initials] UserContactsEditResponse initials
         */

    /**
         * Constructs a new UserContactsEditResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsEditResponse.
         * @implements IUserContactsEditResponse
         * @constructor
         * @param {proto.IUserContactsEditResponse=} [properties] Properties to set
         */
    function UserContactsEditResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsEditResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsEditResponse
         * @instance
         */
    UserContactsEditResponse.prototype.response = null;

    /**
         * UserContactsEditResponse phone.
         * @member {Long} phone
         * @memberof proto.UserContactsEditResponse
         * @instance
         */
    UserContactsEditResponse.prototype.phone = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * UserContactsEditResponse firstName.
         * @member {string} firstName
         * @memberof proto.UserContactsEditResponse
         * @instance
         */
    UserContactsEditResponse.prototype.firstName = '';

    /**
         * UserContactsEditResponse lastName.
         * @member {string} lastName
         * @memberof proto.UserContactsEditResponse
         * @instance
         */
    UserContactsEditResponse.prototype.lastName = '';

    /**
         * UserContactsEditResponse initials.
         * @member {string} initials
         * @memberof proto.UserContactsEditResponse
         * @instance
         */
    UserContactsEditResponse.prototype.initials = '';

    /**
         * Creates a new UserContactsEditResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsEditResponse
         * @static
         * @param {proto.IUserContactsEditResponse=} [properties] Properties to set
         * @returns {proto.UserContactsEditResponse} UserContactsEditResponse instance
         */
    UserContactsEditResponse.create = function create(properties) {
      return new UserContactsEditResponse(properties);
    };

    /**
         * Encodes the specified UserContactsEditResponse message. Does not implicitly {@link proto.UserContactsEditResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsEditResponse
         * @static
         * @param {proto.UserContactsEditResponse} message UserContactsEditResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsEditResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.phone);}
      if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.firstName);}
      if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastName);}
      if (message.initials != null && message.hasOwnProperty('initials')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.initials);}
      return writer;
    };

    /**
         * Decodes a UserContactsEditResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsEditResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsEditResponse} UserContactsEditResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsEditResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsEditResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.phone = reader.uint64();
            break;
          case 3:
            message.firstName = reader.string();
            break;
          case 4:
            message.lastName = reader.string();
            break;
          case 5:
            message.initials = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsEditResponse message.
         * @function verify
         * @memberof proto.UserContactsEditResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsEditResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.phone != null && message.hasOwnProperty('phone')) {
        if (!$util.isInteger(message.phone) && !(message.phone && $util.isInteger(message.phone.low) && $util.isInteger(message.phone.high))) {return 'phone: integer|Long expected';}
      }
      if (message.firstName != null && message.hasOwnProperty('firstName')) {
        if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
      }
      if (message.lastName != null && message.hasOwnProperty('lastName')) {
        if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
      }
      if (message.initials != null && message.hasOwnProperty('initials')) {
        if (!$util.isString(message.initials)) {return 'initials: string expected';}
      }
      return null;
    };

    return UserContactsEditResponse;
  })();

  proto.UserContactsGetBlockedList = (function() {

    /**
         * Properties of a UserContactsGetBlockedList.
         * @memberof proto
         * @interface IUserContactsGetBlockedList
         * @property {proto.Request|null} [request] UserContactsGetBlockedList request
         */

    /**
         * Constructs a new UserContactsGetBlockedList.
         * @memberof proto
         * @classdesc Represents a UserContactsGetBlockedList.
         * @implements IUserContactsGetBlockedList
         * @constructor
         * @param {proto.IUserContactsGetBlockedList=} [properties] Properties to set
         */
    function UserContactsGetBlockedList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsGetBlockedList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsGetBlockedList
         * @instance
         */
    UserContactsGetBlockedList.prototype.request = null;

    /**
         * Creates a new UserContactsGetBlockedList instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsGetBlockedList
         * @static
         * @param {proto.IUserContactsGetBlockedList=} [properties] Properties to set
         * @returns {proto.UserContactsGetBlockedList} UserContactsGetBlockedList instance
         */
    UserContactsGetBlockedList.create = function create(properties) {
      return new UserContactsGetBlockedList(properties);
    };

    /**
         * Encodes the specified UserContactsGetBlockedList message. Does not implicitly {@link proto.UserContactsGetBlockedList.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsGetBlockedList
         * @static
         * @param {proto.UserContactsGetBlockedList} message UserContactsGetBlockedList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsGetBlockedList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserContactsGetBlockedList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsGetBlockedList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsGetBlockedList} UserContactsGetBlockedList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsGetBlockedList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsGetBlockedList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsGetBlockedList message.
         * @function verify
         * @memberof proto.UserContactsGetBlockedList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsGetBlockedList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserContactsGetBlockedList;
  })();

  proto.UserContactsGetBlockedListResponse = (function() {

    /**
         * Properties of a UserContactsGetBlockedListResponse.
         * @memberof proto
         * @interface IUserContactsGetBlockedListResponse
         * @property {proto.Response|null} [response] UserContactsGetBlockedListResponse response
         * @property {Array.<proto.UserContactsGetBlockedListResponse.User>|null} [user] UserContactsGetBlockedListResponse user
         */

    /**
         * Constructs a new UserContactsGetBlockedListResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsGetBlockedListResponse.
         * @implements IUserContactsGetBlockedListResponse
         * @constructor
         * @param {proto.IUserContactsGetBlockedListResponse=} [properties] Properties to set
         */
    function UserContactsGetBlockedListResponse(properties) {
      this.user = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsGetBlockedListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsGetBlockedListResponse
         * @instance
         */
    UserContactsGetBlockedListResponse.prototype.response = null;

    /**
         * UserContactsGetBlockedListResponse user.
         * @member {Array.<proto.UserContactsGetBlockedListResponse.User>} user
         * @memberof proto.UserContactsGetBlockedListResponse
         * @instance
         */
    UserContactsGetBlockedListResponse.prototype.user = $util.emptyArray;

    /**
         * Creates a new UserContactsGetBlockedListResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsGetBlockedListResponse
         * @static
         * @param {proto.IUserContactsGetBlockedListResponse=} [properties] Properties to set
         * @returns {proto.UserContactsGetBlockedListResponse} UserContactsGetBlockedListResponse instance
         */
    UserContactsGetBlockedListResponse.create = function create(properties) {
      return new UserContactsGetBlockedListResponse(properties);
    };

    /**
         * Encodes the specified UserContactsGetBlockedListResponse message. Does not implicitly {@link proto.UserContactsGetBlockedListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsGetBlockedListResponse
         * @static
         * @param {proto.UserContactsGetBlockedListResponse} message UserContactsGetBlockedListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsGetBlockedListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.user != null && message.user.length) {
        for (let i = 0; i < message.user.length; ++i) {$root.proto.UserContactsGetBlockedListResponse.User.encode(message.user[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a UserContactsGetBlockedListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsGetBlockedListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsGetBlockedListResponse} UserContactsGetBlockedListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsGetBlockedListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsGetBlockedListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.user && message.user.length)) {message.user = [];}
            message.user.push($root.proto.UserContactsGetBlockedListResponse.User.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsGetBlockedListResponse message.
         * @function verify
         * @memberof proto.UserContactsGetBlockedListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsGetBlockedListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.user != null && message.hasOwnProperty('user')) {
        if (!Array.isArray(message.user)) {return 'user: array expected';}
        for (let i = 0; i < message.user.length; ++i) {
          let error = $root.proto.UserContactsGetBlockedListResponse.User.verify(message.user[i]);
          if (error) {return 'user.' + error;}
        }
      }
      return null;
    };

    UserContactsGetBlockedListResponse.User = (function() {

      /**
             * Properties of a User.
             * @memberof proto.UserContactsGetBlockedListResponse
             * @interface IUser
             * @property {Long|null} [userId] User userId
             * @property {string|null} [cacheId] User cacheId
             */

      /**
             * Constructs a new User.
             * @memberof proto.UserContactsGetBlockedListResponse
             * @classdesc Represents a User.
             * @implements IUser
             * @constructor
             * @param {proto.UserContactsGetBlockedListResponse.IUser=} [properties] Properties to set
             */
      function User(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * User userId.
             * @member {Long} userId
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @instance
             */
      User.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * User cacheId.
             * @member {string} cacheId
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @instance
             */
      User.prototype.cacheId = '';

      /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @static
             * @param {proto.UserContactsGetBlockedListResponse.IUser=} [properties] Properties to set
             * @returns {proto.UserContactsGetBlockedListResponse.User} User instance
             */
      User.create = function create(properties) {
        return new User(properties);
      };

      /**
             * Encodes the specified User message. Does not implicitly {@link proto.UserContactsGetBlockedListResponse.User.verify|verify} messages.
             * @function encode
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @static
             * @param {proto.UserContactsGetBlockedListResponse.User} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      User.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);}
        if (message.cacheId != null && message.hasOwnProperty('cacheId')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.cacheId);}
        return writer;
      };

      /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.UserContactsGetBlockedListResponse.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      User.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsGetBlockedListResponse.User();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.userId = reader.uint64();
              break;
            case 2:
              message.cacheId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a User message.
             * @function verify
             * @memberof proto.UserContactsGetBlockedListResponse.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      User.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        if (message.cacheId != null && message.hasOwnProperty('cacheId')) {
          if (!$util.isString(message.cacheId)) {return 'cacheId: string expected';}
        }
        return null;
      };

      return User;
    })();

    return UserContactsGetBlockedListResponse;
  })();

  proto.UserContactsGetList = (function() {

    /**
         * Properties of a UserContactsGetList.
         * @memberof proto
         * @interface IUserContactsGetList
         * @property {proto.Request|null} [request] UserContactsGetList request
         */

    /**
         * Constructs a new UserContactsGetList.
         * @memberof proto
         * @classdesc Represents a UserContactsGetList.
         * @implements IUserContactsGetList
         * @constructor
         * @param {proto.IUserContactsGetList=} [properties] Properties to set
         */
    function UserContactsGetList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsGetList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsGetList
         * @instance
         */
    UserContactsGetList.prototype.request = null;

    /**
         * Creates a new UserContactsGetList instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsGetList
         * @static
         * @param {proto.IUserContactsGetList=} [properties] Properties to set
         * @returns {proto.UserContactsGetList} UserContactsGetList instance
         */
    UserContactsGetList.create = function create(properties) {
      return new UserContactsGetList(properties);
    };

    /**
         * Encodes the specified UserContactsGetList message. Does not implicitly {@link proto.UserContactsGetList.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsGetList
         * @static
         * @param {proto.UserContactsGetList} message UserContactsGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsGetList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserContactsGetList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsGetList} UserContactsGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsGetList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsGetList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsGetList message.
         * @function verify
         * @memberof proto.UserContactsGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsGetList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserContactsGetList;
  })();

  proto.UserContactsGetListResponse = (function() {

    /**
         * Properties of a UserContactsGetListResponse.
         * @memberof proto
         * @interface IUserContactsGetListResponse
         * @property {proto.Response|null} [response] UserContactsGetListResponse response
         * @property {Array.<proto.RegisteredUser>|null} [registeredUser] UserContactsGetListResponse registeredUser
         */

    /**
         * Constructs a new UserContactsGetListResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsGetListResponse.
         * @implements IUserContactsGetListResponse
         * @constructor
         * @param {proto.IUserContactsGetListResponse=} [properties] Properties to set
         */
    function UserContactsGetListResponse(properties) {
      this.registeredUser = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsGetListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsGetListResponse
         * @instance
         */
    UserContactsGetListResponse.prototype.response = null;

    /**
         * UserContactsGetListResponse registeredUser.
         * @member {Array.<proto.RegisteredUser>} registeredUser
         * @memberof proto.UserContactsGetListResponse
         * @instance
         */
    UserContactsGetListResponse.prototype.registeredUser = $util.emptyArray;

    /**
         * Creates a new UserContactsGetListResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsGetListResponse
         * @static
         * @param {proto.IUserContactsGetListResponse=} [properties] Properties to set
         * @returns {proto.UserContactsGetListResponse} UserContactsGetListResponse instance
         */
    UserContactsGetListResponse.create = function create(properties) {
      return new UserContactsGetListResponse(properties);
    };

    /**
         * Encodes the specified UserContactsGetListResponse message. Does not implicitly {@link proto.UserContactsGetListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsGetListResponse
         * @static
         * @param {proto.UserContactsGetListResponse} message UserContactsGetListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsGetListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.registeredUser != null && message.registeredUser.length) {
        for (let i = 0; i < message.registeredUser.length; ++i) {$root.proto.RegisteredUser.encode(message.registeredUser[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a UserContactsGetListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsGetListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsGetListResponse} UserContactsGetListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsGetListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsGetListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.registeredUser && message.registeredUser.length)) {message.registeredUser = [];}
            message.registeredUser.push($root.proto.RegisteredUser.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsGetListResponse message.
         * @function verify
         * @memberof proto.UserContactsGetListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsGetListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.registeredUser != null && message.hasOwnProperty('registeredUser')) {
        if (!Array.isArray(message.registeredUser)) {return 'registeredUser: array expected';}
        for (let i = 0; i < message.registeredUser.length; ++i) {
          let error = $root.proto.RegisteredUser.verify(message.registeredUser[i]);
          if (error) {return 'registeredUser.' + error;}
        }
      }
      return null;
    };

    return UserContactsGetListResponse;
  })();

  proto.UserContactsImport = (function() {

    /**
         * Properties of a UserContactsImport.
         * @memberof proto
         * @interface IUserContactsImport
         * @property {proto.Request|null} [request] UserContactsImport request
         * @property {Array.<proto.UserContactsImport.Contact>|null} [contacts] UserContactsImport contacts
         * @property {boolean|null} [force] UserContactsImport force
         */

    /**
         * Constructs a new UserContactsImport.
         * @memberof proto
         * @classdesc Represents a UserContactsImport.
         * @implements IUserContactsImport
         * @constructor
         * @param {proto.IUserContactsImport=} [properties] Properties to set
         */
    function UserContactsImport(properties) {
      this.contacts = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsImport request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsImport
         * @instance
         */
    UserContactsImport.prototype.request = null;

    /**
         * UserContactsImport contacts.
         * @member {Array.<proto.UserContactsImport.Contact>} contacts
         * @memberof proto.UserContactsImport
         * @instance
         */
    UserContactsImport.prototype.contacts = $util.emptyArray;

    /**
         * UserContactsImport force.
         * @member {boolean} force
         * @memberof proto.UserContactsImport
         * @instance
         */
    UserContactsImport.prototype.force = false;

    /**
         * Creates a new UserContactsImport instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsImport
         * @static
         * @param {proto.IUserContactsImport=} [properties] Properties to set
         * @returns {proto.UserContactsImport} UserContactsImport instance
         */
    UserContactsImport.create = function create(properties) {
      return new UserContactsImport(properties);
    };

    /**
         * Encodes the specified UserContactsImport message. Does not implicitly {@link proto.UserContactsImport.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsImport
         * @static
         * @param {proto.UserContactsImport} message UserContactsImport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsImport.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.contacts != null && message.contacts.length) {
        for (let i = 0; i < message.contacts.length; ++i) {$root.proto.UserContactsImport.Contact.encode(message.contacts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      if (message.force != null && message.hasOwnProperty('force')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force);}
      return writer;
    };

    /**
         * Decodes a UserContactsImport message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsImport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsImport} UserContactsImport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsImport.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsImport();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.contacts && message.contacts.length)) {message.contacts = [];}
            message.contacts.push($root.proto.UserContactsImport.Contact.decode(reader, reader.uint32()));
            break;
          case 3:
            message.force = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsImport message.
         * @function verify
         * @memberof proto.UserContactsImport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsImport.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.contacts != null && message.hasOwnProperty('contacts')) {
        if (!Array.isArray(message.contacts)) {return 'contacts: array expected';}
        for (let i = 0; i < message.contacts.length; ++i) {
          let error = $root.proto.UserContactsImport.Contact.verify(message.contacts[i]);
          if (error) {return 'contacts.' + error;}
        }
      }
      if (message.force != null && message.hasOwnProperty('force')) {
        if (typeof message.force !== 'boolean') {return 'force: boolean expected';}
      }
      return null;
    };

    UserContactsImport.Contact = (function() {

      /**
             * Properties of a Contact.
             * @memberof proto.UserContactsImport
             * @interface IContact
             * @property {string|null} [phone] Contact phone
             * @property {string|null} [firstName] Contact firstName
             * @property {string|null} [lastName] Contact lastName
             * @property {string|null} [clientId] Contact clientId
             */

      /**
             * Constructs a new Contact.
             * @memberof proto.UserContactsImport
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {proto.UserContactsImport.IContact=} [properties] Properties to set
             */
      function Contact(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Contact phone.
             * @member {string} phone
             * @memberof proto.UserContactsImport.Contact
             * @instance
             */
      Contact.prototype.phone = '';

      /**
             * Contact firstName.
             * @member {string} firstName
             * @memberof proto.UserContactsImport.Contact
             * @instance
             */
      Contact.prototype.firstName = '';

      /**
             * Contact lastName.
             * @member {string} lastName
             * @memberof proto.UserContactsImport.Contact
             * @instance
             */
      Contact.prototype.lastName = '';

      /**
             * Contact clientId.
             * @member {string} clientId
             * @memberof proto.UserContactsImport.Contact
             * @instance
             */
      Contact.prototype.clientId = '';

      /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof proto.UserContactsImport.Contact
             * @static
             * @param {proto.UserContactsImport.IContact=} [properties] Properties to set
             * @returns {proto.UserContactsImport.Contact} Contact instance
             */
      Contact.create = function create(properties) {
        return new Contact(properties);
      };

      /**
             * Encodes the specified Contact message. Does not implicitly {@link proto.UserContactsImport.Contact.verify|verify} messages.
             * @function encode
             * @memberof proto.UserContactsImport.Contact
             * @static
             * @param {proto.UserContactsImport.Contact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Contact.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.phone != null && message.hasOwnProperty('phone')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);}
        if (message.firstName != null && message.hasOwnProperty('firstName')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.firstName);}
        if (message.lastName != null && message.hasOwnProperty('lastName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.lastName);}
        if (message.clientId != null && message.hasOwnProperty('clientId')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);}
        return writer;
      };

      /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof proto.UserContactsImport.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.UserContactsImport.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Contact.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsImport.Contact();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.phone = reader.string();
              break;
            case 2:
              message.firstName = reader.string();
              break;
            case 3:
              message.lastName = reader.string();
              break;
            case 4:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Contact message.
             * @function verify
             * @memberof proto.UserContactsImport.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Contact.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.phone != null && message.hasOwnProperty('phone')) {
          if (!$util.isString(message.phone)) {return 'phone: string expected';}
        }
        if (message.firstName != null && message.hasOwnProperty('firstName')) {
          if (!$util.isString(message.firstName)) {return 'firstName: string expected';}
        }
        if (message.lastName != null && message.hasOwnProperty('lastName')) {
          if (!$util.isString(message.lastName)) {return 'lastName: string expected';}
        }
        if (message.clientId != null && message.hasOwnProperty('clientId')) {
          if (!$util.isString(message.clientId)) {return 'clientId: string expected';}
        }
        return null;
      };

      return Contact;
    })();

    return UserContactsImport;
  })();

  proto.UserContactsImportResponse = (function() {

    /**
         * Properties of a UserContactsImportResponse.
         * @memberof proto
         * @interface IUserContactsImportResponse
         * @property {proto.Response|null} [response] UserContactsImportResponse response
         * @property {Array.<proto.UserContactsImportResponse.Contact>|null} [registeredContacts] UserContactsImportResponse registeredContacts
         */

    /**
         * Constructs a new UserContactsImportResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsImportResponse.
         * @implements IUserContactsImportResponse
         * @constructor
         * @param {proto.IUserContactsImportResponse=} [properties] Properties to set
         */
    function UserContactsImportResponse(properties) {
      this.registeredContacts = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsImportResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsImportResponse
         * @instance
         */
    UserContactsImportResponse.prototype.response = null;

    /**
         * UserContactsImportResponse registeredContacts.
         * @member {Array.<proto.UserContactsImportResponse.Contact>} registeredContacts
         * @memberof proto.UserContactsImportResponse
         * @instance
         */
    UserContactsImportResponse.prototype.registeredContacts = $util.emptyArray;

    /**
         * Creates a new UserContactsImportResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsImportResponse
         * @static
         * @param {proto.IUserContactsImportResponse=} [properties] Properties to set
         * @returns {proto.UserContactsImportResponse} UserContactsImportResponse instance
         */
    UserContactsImportResponse.create = function create(properties) {
      return new UserContactsImportResponse(properties);
    };

    /**
         * Encodes the specified UserContactsImportResponse message. Does not implicitly {@link proto.UserContactsImportResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsImportResponse
         * @static
         * @param {proto.UserContactsImportResponse} message UserContactsImportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsImportResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.registeredContacts != null && message.registeredContacts.length) {
        for (let i = 0; i < message.registeredContacts.length; ++i) {$root.proto.UserContactsImportResponse.Contact.encode(message.registeredContacts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a UserContactsImportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsImportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsImportResponse} UserContactsImportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsImportResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsImportResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.registeredContacts && message.registeredContacts.length)) {message.registeredContacts = [];}
            message.registeredContacts.push($root.proto.UserContactsImportResponse.Contact.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsImportResponse message.
         * @function verify
         * @memberof proto.UserContactsImportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsImportResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.registeredContacts != null && message.hasOwnProperty('registeredContacts')) {
        if (!Array.isArray(message.registeredContacts)) {return 'registeredContacts: array expected';}
        for (let i = 0; i < message.registeredContacts.length; ++i) {
          let error = $root.proto.UserContactsImportResponse.Contact.verify(message.registeredContacts[i]);
          if (error) {return 'registeredContacts.' + error;}
        }
      }
      return null;
    };

    UserContactsImportResponse.Contact = (function() {

      /**
             * Properties of a Contact.
             * @memberof proto.UserContactsImportResponse
             * @interface IContact
             * @property {string|null} [clientId] Contact clientId
             * @property {Long|null} [userId] Contact userId
             */

      /**
             * Constructs a new Contact.
             * @memberof proto.UserContactsImportResponse
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {proto.UserContactsImportResponse.IContact=} [properties] Properties to set
             */
      function Contact(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Contact clientId.
             * @member {string} clientId
             * @memberof proto.UserContactsImportResponse.Contact
             * @instance
             */
      Contact.prototype.clientId = '';

      /**
             * Contact userId.
             * @member {Long} userId
             * @memberof proto.UserContactsImportResponse.Contact
             * @instance
             */
      Contact.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof proto.UserContactsImportResponse.Contact
             * @static
             * @param {proto.UserContactsImportResponse.IContact=} [properties] Properties to set
             * @returns {proto.UserContactsImportResponse.Contact} Contact instance
             */
      Contact.create = function create(properties) {
        return new Contact(properties);
      };

      /**
             * Encodes the specified Contact message. Does not implicitly {@link proto.UserContactsImportResponse.Contact.verify|verify} messages.
             * @function encode
             * @memberof proto.UserContactsImportResponse.Contact
             * @static
             * @param {proto.UserContactsImportResponse.Contact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Contact.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.clientId != null && message.hasOwnProperty('clientId')) {writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientId);}
        if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
        return writer;
      };

      /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof proto.UserContactsImportResponse.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.UserContactsImportResponse.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Contact.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsImportResponse.Contact();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.userId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Contact message.
             * @function verify
             * @memberof proto.UserContactsImportResponse.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Contact.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.clientId != null && message.hasOwnProperty('clientId')) {
          if (!$util.isString(message.clientId)) {return 'clientId: string expected';}
        }
        if (message.userId != null && message.hasOwnProperty('userId')) {
          if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
        }
        return null;
      };

      return Contact;
    })();

    return UserContactsImportResponse;
  })();

  proto.UserContactsUnblock = (function() {

    /**
         * Properties of a UserContactsUnblock.
         * @memberof proto
         * @interface IUserContactsUnblock
         * @property {proto.Request|null} [request] UserContactsUnblock request
         * @property {Long|null} [userId] UserContactsUnblock userId
         */

    /**
         * Constructs a new UserContactsUnblock.
         * @memberof proto
         * @classdesc Represents a UserContactsUnblock.
         * @implements IUserContactsUnblock
         * @constructor
         * @param {proto.IUserContactsUnblock=} [properties] Properties to set
         */
    function UserContactsUnblock(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsUnblock request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserContactsUnblock
         * @instance
         */
    UserContactsUnblock.prototype.request = null;

    /**
         * UserContactsUnblock userId.
         * @member {Long} userId
         * @memberof proto.UserContactsUnblock
         * @instance
         */
    UserContactsUnblock.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsUnblock instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsUnblock
         * @static
         * @param {proto.IUserContactsUnblock=} [properties] Properties to set
         * @returns {proto.UserContactsUnblock} UserContactsUnblock instance
         */
    UserContactsUnblock.create = function create(properties) {
      return new UserContactsUnblock(properties);
    };

    /**
         * Encodes the specified UserContactsUnblock message. Does not implicitly {@link proto.UserContactsUnblock.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsUnblock
         * @static
         * @param {proto.UserContactsUnblock} message UserContactsUnblock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsUnblock.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserContactsUnblock message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsUnblock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsUnblock} UserContactsUnblock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsUnblock.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsUnblock();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsUnblock message.
         * @function verify
         * @memberof proto.UserContactsUnblock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsUnblock.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserContactsUnblock;
  })();

  proto.UserContactsUnblockResponse = (function() {

    /**
         * Properties of a UserContactsUnblockResponse.
         * @memberof proto
         * @interface IUserContactsUnblockResponse
         * @property {proto.Response|null} [response] UserContactsUnblockResponse response
         * @property {Long|null} [userId] UserContactsUnblockResponse userId
         */

    /**
         * Constructs a new UserContactsUnblockResponse.
         * @memberof proto
         * @classdesc Represents a UserContactsUnblockResponse.
         * @implements IUserContactsUnblockResponse
         * @constructor
         * @param {proto.IUserContactsUnblockResponse=} [properties] Properties to set
         */
    function UserContactsUnblockResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserContactsUnblockResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserContactsUnblockResponse
         * @instance
         */
    UserContactsUnblockResponse.prototype.response = null;

    /**
         * UserContactsUnblockResponse userId.
         * @member {Long} userId
         * @memberof proto.UserContactsUnblockResponse
         * @instance
         */
    UserContactsUnblockResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserContactsUnblockResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserContactsUnblockResponse
         * @static
         * @param {proto.IUserContactsUnblockResponse=} [properties] Properties to set
         * @returns {proto.UserContactsUnblockResponse} UserContactsUnblockResponse instance
         */
    UserContactsUnblockResponse.create = function create(properties) {
      return new UserContactsUnblockResponse(properties);
    };

    /**
         * Encodes the specified UserContactsUnblockResponse message. Does not implicitly {@link proto.UserContactsUnblockResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserContactsUnblockResponse
         * @static
         * @param {proto.UserContactsUnblockResponse} message UserContactsUnblockResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserContactsUnblockResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserContactsUnblockResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserContactsUnblockResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserContactsUnblockResponse} UserContactsUnblockResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserContactsUnblockResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserContactsUnblockResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserContactsUnblockResponse message.
         * @function verify
         * @memberof proto.UserContactsUnblockResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserContactsUnblockResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserContactsUnblockResponse;
  })();

  proto.UserDelete = (function() {

    /**
         * Properties of a UserDelete.
         * @memberof proto
         * @interface IUserDelete
         * @property {proto.Request|null} [request] UserDelete request
         * @property {string|null} [token] UserDelete token
         * @property {proto.UserDelete.Reason|null} [reason] UserDelete reason
         */

    /**
         * Constructs a new UserDelete.
         * @memberof proto
         * @classdesc Represents a UserDelete.
         * @implements IUserDelete
         * @constructor
         * @param {proto.IUserDelete=} [properties] Properties to set
         */
    function UserDelete(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserDelete request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserDelete
         * @instance
         */
    UserDelete.prototype.request = null;

    /**
         * UserDelete token.
         * @member {string} token
         * @memberof proto.UserDelete
         * @instance
         */
    UserDelete.prototype.token = '';

    /**
         * UserDelete reason.
         * @member {proto.UserDelete.Reason} reason
         * @memberof proto.UserDelete
         * @instance
         */
    UserDelete.prototype.reason = 0;

    /**
         * Creates a new UserDelete instance using the specified properties.
         * @function create
         * @memberof proto.UserDelete
         * @static
         * @param {proto.IUserDelete=} [properties] Properties to set
         * @returns {proto.UserDelete} UserDelete instance
         */
    UserDelete.create = function create(properties) {
      return new UserDelete(properties);
    };

    /**
         * Encodes the specified UserDelete message. Does not implicitly {@link proto.UserDelete.verify|verify} messages.
         * @function encode
         * @memberof proto.UserDelete
         * @static
         * @param {proto.UserDelete} message UserDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserDelete.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.reason != null && message.hasOwnProperty('reason')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reason);}
      return writer;
    };

    /**
         * Decodes a UserDelete message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserDelete} UserDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserDelete.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserDelete();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.reason = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserDelete message.
         * @function verify
         * @memberof proto.UserDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserDelete.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.reason != null && message.hasOwnProperty('reason')) {
        switch (message.reason) {
          default:
            return 'reason: enum value expected';
          case 0:
            break;
        }
      }
      return null;
    };

    /**
         * Reason enum.
         * @name proto.UserDelete.Reason
         * @enum {string}
         * @property {number} OTHER=0 OTHER value
         */
    UserDelete.Reason = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'OTHER'] = 0;
      return values;
    })();

    return UserDelete;
  })();

  proto.UserDeleteResponse = (function() {

    /**
         * Properties of a UserDeleteResponse.
         * @memberof proto
         * @interface IUserDeleteResponse
         * @property {proto.Response|null} [response] UserDeleteResponse response
         */

    /**
         * Constructs a new UserDeleteResponse.
         * @memberof proto
         * @classdesc Represents a UserDeleteResponse.
         * @implements IUserDeleteResponse
         * @constructor
         * @param {proto.IUserDeleteResponse=} [properties] Properties to set
         */
    function UserDeleteResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserDeleteResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserDeleteResponse
         * @instance
         */
    UserDeleteResponse.prototype.response = null;

    /**
         * Creates a new UserDeleteResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserDeleteResponse
         * @static
         * @param {proto.IUserDeleteResponse=} [properties] Properties to set
         * @returns {proto.UserDeleteResponse} UserDeleteResponse instance
         */
    UserDeleteResponse.create = function create(properties) {
      return new UserDeleteResponse(properties);
    };

    /**
         * Encodes the specified UserDeleteResponse message. Does not implicitly {@link proto.UserDeleteResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserDeleteResponse
         * @static
         * @param {proto.UserDeleteResponse} message UserDeleteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserDeleteResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserDeleteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserDeleteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserDeleteResponse} UserDeleteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserDeleteResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserDeleteResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserDeleteResponse message.
         * @function verify
         * @memberof proto.UserDeleteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserDeleteResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserDeleteResponse;
  })();

  proto.UserGetDeleteToken = (function() {

    /**
         * Properties of a UserGetDeleteToken.
         * @memberof proto
         * @interface IUserGetDeleteToken
         * @property {proto.Request|null} [request] UserGetDeleteToken request
         */

    /**
         * Constructs a new UserGetDeleteToken.
         * @memberof proto
         * @classdesc Represents a UserGetDeleteToken.
         * @implements IUserGetDeleteToken
         * @constructor
         * @param {proto.IUserGetDeleteToken=} [properties] Properties to set
         */
    function UserGetDeleteToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserGetDeleteToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserGetDeleteToken
         * @instance
         */
    UserGetDeleteToken.prototype.request = null;

    /**
         * Creates a new UserGetDeleteToken instance using the specified properties.
         * @function create
         * @memberof proto.UserGetDeleteToken
         * @static
         * @param {proto.IUserGetDeleteToken=} [properties] Properties to set
         * @returns {proto.UserGetDeleteToken} UserGetDeleteToken instance
         */
    UserGetDeleteToken.create = function create(properties) {
      return new UserGetDeleteToken(properties);
    };

    /**
         * Encodes the specified UserGetDeleteToken message. Does not implicitly {@link proto.UserGetDeleteToken.verify|verify} messages.
         * @function encode
         * @memberof proto.UserGetDeleteToken
         * @static
         * @param {proto.UserGetDeleteToken} message UserGetDeleteToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserGetDeleteToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserGetDeleteToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserGetDeleteToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserGetDeleteToken} UserGetDeleteToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserGetDeleteToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserGetDeleteToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserGetDeleteToken message.
         * @function verify
         * @memberof proto.UserGetDeleteToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserGetDeleteToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserGetDeleteToken;
  })();

  proto.UserGetDeleteTokenResponse = (function() {

    /**
         * Properties of a UserGetDeleteTokenResponse.
         * @memberof proto
         * @interface IUserGetDeleteTokenResponse
         * @property {proto.Response|null} [response] UserGetDeleteTokenResponse response
         * @property {number|null} [resendDelay] UserGetDeleteTokenResponse resendDelay
         * @property {Array.<Long>|null} [smsNumber] UserGetDeleteTokenResponse smsNumber
         * @property {string|null} [tokenRegex] UserGetDeleteTokenResponse tokenRegex
         * @property {string|null} [tokenLength] UserGetDeleteTokenResponse tokenLength
         */

    /**
         * Constructs a new UserGetDeleteTokenResponse.
         * @memberof proto
         * @classdesc Represents a UserGetDeleteTokenResponse.
         * @implements IUserGetDeleteTokenResponse
         * @constructor
         * @param {proto.IUserGetDeleteTokenResponse=} [properties] Properties to set
         */
    function UserGetDeleteTokenResponse(properties) {
      this.smsNumber = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserGetDeleteTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserGetDeleteTokenResponse
         * @instance
         */
    UserGetDeleteTokenResponse.prototype.response = null;

    /**
         * UserGetDeleteTokenResponse resendDelay.
         * @member {number} resendDelay
         * @memberof proto.UserGetDeleteTokenResponse
         * @instance
         */
    UserGetDeleteTokenResponse.prototype.resendDelay = 0;

    /**
         * UserGetDeleteTokenResponse smsNumber.
         * @member {Array.<Long>} smsNumber
         * @memberof proto.UserGetDeleteTokenResponse
         * @instance
         */
    UserGetDeleteTokenResponse.prototype.smsNumber = $util.emptyArray;

    /**
         * UserGetDeleteTokenResponse tokenRegex.
         * @member {string} tokenRegex
         * @memberof proto.UserGetDeleteTokenResponse
         * @instance
         */
    UserGetDeleteTokenResponse.prototype.tokenRegex = '';

    /**
         * UserGetDeleteTokenResponse tokenLength.
         * @member {string} tokenLength
         * @memberof proto.UserGetDeleteTokenResponse
         * @instance
         */
    UserGetDeleteTokenResponse.prototype.tokenLength = '';

    /**
         * Creates a new UserGetDeleteTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserGetDeleteTokenResponse
         * @static
         * @param {proto.IUserGetDeleteTokenResponse=} [properties] Properties to set
         * @returns {proto.UserGetDeleteTokenResponse} UserGetDeleteTokenResponse instance
         */
    UserGetDeleteTokenResponse.create = function create(properties) {
      return new UserGetDeleteTokenResponse(properties);
    };

    /**
         * Encodes the specified UserGetDeleteTokenResponse message. Does not implicitly {@link proto.UserGetDeleteTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserGetDeleteTokenResponse
         * @static
         * @param {proto.UserGetDeleteTokenResponse} message UserGetDeleteTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserGetDeleteTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.resendDelay != null && message.hasOwnProperty('resendDelay')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.resendDelay);}
      if (message.smsNumber != null && message.smsNumber.length) {
        writer.uint32(/* id 3, wireType 2 =*/26).fork();
        for (let i = 0; i < message.smsNumber.length; ++i) {writer.uint64(message.smsNumber[i]);}
        writer.ldelim();
      }
      if (message.tokenRegex != null && message.hasOwnProperty('tokenRegex')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.tokenRegex);}
      if (message.tokenLength != null && message.hasOwnProperty('tokenLength')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.tokenLength);}
      return writer;
    };

    /**
         * Decodes a UserGetDeleteTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserGetDeleteTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserGetDeleteTokenResponse} UserGetDeleteTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserGetDeleteTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserGetDeleteTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.resendDelay = reader.uint32();
            break;
          case 3:
            if (!(message.smsNumber && message.smsNumber.length)) {message.smsNumber = [];}
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {message.smsNumber.push(reader.uint64());}
            } else {message.smsNumber.push(reader.uint64());}
            break;
          case 4:
            message.tokenRegex = reader.string();
            break;
          case 5:
            message.tokenLength = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserGetDeleteTokenResponse message.
         * @function verify
         * @memberof proto.UserGetDeleteTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserGetDeleteTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.resendDelay != null && message.hasOwnProperty('resendDelay')) {
        if (!$util.isInteger(message.resendDelay)) {return 'resendDelay: integer expected';}
      }
      if (message.smsNumber != null && message.hasOwnProperty('smsNumber')) {
        if (!Array.isArray(message.smsNumber)) {return 'smsNumber: array expected';}
        for (let i = 0; i < message.smsNumber.length; ++i) {
          if (!$util.isInteger(message.smsNumber[i]) && !(message.smsNumber[i] && $util.isInteger(message.smsNumber[i].low) && $util.isInteger(message.smsNumber[i].high))) {return 'smsNumber: integer|Long[] expected';}
        }
      }
      if (message.tokenRegex != null && message.hasOwnProperty('tokenRegex')) {
        if (!$util.isString(message.tokenRegex)) {return 'tokenRegex: string expected';}
      }
      if (message.tokenLength != null && message.hasOwnProperty('tokenLength')) {
        if (!$util.isString(message.tokenLength)) {return 'tokenLength: string expected';}
      }
      return null;
    };

    return UserGetDeleteTokenResponse;
  })();

  proto.UserInfo = (function() {

    /**
         * Properties of a UserInfo.
         * @memberof proto
         * @interface IUserInfo
         * @property {proto.Request|null} [request] UserInfo request
         * @property {Long|null} [userId] UserInfo userId
         */

    /**
         * Constructs a new UserInfo.
         * @memberof proto
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {proto.IUserInfo=} [properties] Properties to set
         */
    function UserInfo(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserInfo request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserInfo
         * @instance
         */
    UserInfo.prototype.request = null;

    /**
         * UserInfo userId.
         * @member {Long} userId
         * @memberof proto.UserInfo
         * @instance
         */
    UserInfo.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof proto.UserInfo
         * @static
         * @param {proto.IUserInfo=} [properties] Properties to set
         * @returns {proto.UserInfo} UserInfo instance
         */
    UserInfo.create = function create(properties) {
      return new UserInfo(properties);
    };

    /**
         * Encodes the specified UserInfo message. Does not implicitly {@link proto.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.UserInfo
         * @static
         * @param {proto.UserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserInfo.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserInfo.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserInfo();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof proto.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserInfo.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserInfo;
  })();

  proto.UserInfoResponse = (function() {

    /**
         * Properties of a UserInfoResponse.
         * @memberof proto
         * @interface IUserInfoResponse
         * @property {proto.Response|null} [response] UserInfoResponse response
         * @property {proto.RegisteredUser|null} [user] UserInfoResponse user
         */

    /**
         * Constructs a new UserInfoResponse.
         * @memberof proto
         * @classdesc Represents a UserInfoResponse.
         * @implements IUserInfoResponse
         * @constructor
         * @param {proto.IUserInfoResponse=} [properties] Properties to set
         */
    function UserInfoResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserInfoResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserInfoResponse
         * @instance
         */
    UserInfoResponse.prototype.response = null;

    /**
         * UserInfoResponse user.
         * @member {proto.RegisteredUser|null|undefined} user
         * @memberof proto.UserInfoResponse
         * @instance
         */
    UserInfoResponse.prototype.user = null;

    /**
         * Creates a new UserInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserInfoResponse
         * @static
         * @param {proto.IUserInfoResponse=} [properties] Properties to set
         * @returns {proto.UserInfoResponse} UserInfoResponse instance
         */
    UserInfoResponse.create = function create(properties) {
      return new UserInfoResponse(properties);
    };

    /**
         * Encodes the specified UserInfoResponse message. Does not implicitly {@link proto.UserInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserInfoResponse
         * @static
         * @param {proto.UserInfoResponse} message UserInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserInfoResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.user != null && message.hasOwnProperty('user')) {$root.proto.RegisteredUser.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserInfoResponse} UserInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserInfoResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserInfoResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.user = $root.proto.RegisteredUser.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserInfoResponse message.
         * @function verify
         * @memberof proto.UserInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserInfoResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.user != null && message.hasOwnProperty('user')) {
        let error = $root.proto.RegisteredUser.verify(message.user);
        if (error) {return 'user.' + error;}
      }
      return null;
    };

    return UserInfoResponse;
  })();

  proto.UserLogin = (function() {

    /**
         * Properties of a UserLogin.
         * @memberof proto
         * @interface IUserLogin
         * @property {proto.Request|null} [request] UserLogin request
         * @property {string|null} [token] UserLogin token
         * @property {string|null} [appName] UserLogin appName
         * @property {number|null} [appId] UserLogin appId
         * @property {number|null} [appBuildVersion] UserLogin appBuildVersion
         * @property {string|null} [appVersion] UserLogin appVersion
         * @property {proto.Platform|null} [platform] UserLogin platform
         * @property {string|null} [platformVersion] UserLogin platformVersion
         * @property {proto.Device|null} [device] UserLogin device
         * @property {string|null} [deviceName] UserLogin deviceName
         * @property {proto.Language|null} [language] UserLogin language
         */

    /**
         * Constructs a new UserLogin.
         * @memberof proto
         * @classdesc Represents a UserLogin.
         * @implements IUserLogin
         * @constructor
         * @param {proto.IUserLogin=} [properties] Properties to set
         */
    function UserLogin(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserLogin request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.request = null;

    /**
         * UserLogin token.
         * @member {string} token
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.token = '';

    /**
         * UserLogin appName.
         * @member {string} appName
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.appName = '';

    /**
         * UserLogin appId.
         * @member {number} appId
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.appId = 0;

    /**
         * UserLogin appBuildVersion.
         * @member {number} appBuildVersion
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.appBuildVersion = 0;

    /**
         * UserLogin appVersion.
         * @member {string} appVersion
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.appVersion = '';

    /**
         * UserLogin platform.
         * @member {proto.Platform} platform
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.platform = 0;

    /**
         * UserLogin platformVersion.
         * @member {string} platformVersion
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.platformVersion = '';

    /**
         * UserLogin device.
         * @member {proto.Device} device
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.device = 0;

    /**
         * UserLogin deviceName.
         * @member {string} deviceName
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.deviceName = '';

    /**
         * UserLogin language.
         * @member {proto.Language} language
         * @memberof proto.UserLogin
         * @instance
         */
    UserLogin.prototype.language = 0;

    /**
         * Creates a new UserLogin instance using the specified properties.
         * @function create
         * @memberof proto.UserLogin
         * @static
         * @param {proto.IUserLogin=} [properties] Properties to set
         * @returns {proto.UserLogin} UserLogin instance
         */
    UserLogin.create = function create(properties) {
      return new UserLogin(properties);
    };

    /**
         * Encodes the specified UserLogin message. Does not implicitly {@link proto.UserLogin.verify|verify} messages.
         * @function encode
         * @memberof proto.UserLogin
         * @static
         * @param {proto.UserLogin} message UserLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserLogin.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.appName != null && message.hasOwnProperty('appName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.appName);}
      if (message.appId != null && message.hasOwnProperty('appId')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.appId);}
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.appBuildVersion);}
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.appVersion);}
      if (message.platform != null && message.hasOwnProperty('platform')) {writer.uint32(/* id 7, wireType 0 =*/56).int32(message.platform);}
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {writer.uint32(/* id 8, wireType 2 =*/66).string(message.platformVersion);}
      if (message.device != null && message.hasOwnProperty('device')) {writer.uint32(/* id 9, wireType 0 =*/72).int32(message.device);}
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {writer.uint32(/* id 10, wireType 2 =*/82).string(message.deviceName);}
      if (message.language != null && message.hasOwnProperty('language')) {writer.uint32(/* id 11, wireType 0 =*/88).int32(message.language);}
      return writer;
    };

    /**
         * Decodes a UserLogin message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserLogin} UserLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserLogin.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserLogin();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.appName = reader.string();
            break;
          case 4:
            message.appId = reader.uint32();
            break;
          case 5:
            message.appBuildVersion = reader.uint32();
            break;
          case 6:
            message.appVersion = reader.string();
            break;
          case 7:
            message.platform = reader.int32();
            break;
          case 8:
            message.platformVersion = reader.string();
            break;
          case 9:
            message.device = reader.int32();
            break;
          case 10:
            message.deviceName = reader.string();
            break;
          case 11:
            message.language = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserLogin message.
         * @function verify
         * @memberof proto.UserLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserLogin.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.appName != null && message.hasOwnProperty('appName')) {
        if (!$util.isString(message.appName)) {return 'appName: string expected';}
      }
      if (message.appId != null && message.hasOwnProperty('appId')) {
        if (!$util.isInteger(message.appId)) {return 'appId: integer expected';}
      }
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {
        if (!$util.isInteger(message.appBuildVersion)) {return 'appBuildVersion: integer expected';}
      }
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {
        if (!$util.isString(message.appVersion)) {return 'appVersion: string expected';}
      }
      if (message.platform != null && message.hasOwnProperty('platform')) {
        switch (message.platform) {
          default:
            return 'platform: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      }
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {
        if (!$util.isString(message.platformVersion)) {return 'platformVersion: string expected';}
      }
      if (message.device != null && message.hasOwnProperty('device')) {
        switch (message.device) {
          default:
            return 'device: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {
        if (!$util.isString(message.deviceName)) {return 'deviceName: string expected';}
      }
      if (message.language != null && message.hasOwnProperty('language')) {
        switch (message.language) {
          default:
            return 'language: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      return null;
    };

    return UserLogin;
  })();

  proto.UserLoginResponse = (function() {

    /**
         * Properties of a UserLoginResponse.
         * @memberof proto
         * @interface IUserLoginResponse
         * @property {proto.Response|null} [response] UserLoginResponse response
         * @property {boolean|null} [deprecatedClient] UserLoginResponse deprecatedClient
         * @property {string|null} [secondaryNodeName] UserLoginResponse secondaryNodeName
         * @property {boolean|null} [updateAvailable] UserLoginResponse updateAvailable
         * @property {number|null} [chatDeleteMessageForBothPeriod] UserLoginResponse chatDeleteMessageForBothPeriod
         */

    /**
         * Constructs a new UserLoginResponse.
         * @memberof proto
         * @classdesc Represents a UserLoginResponse.
         * @implements IUserLoginResponse
         * @constructor
         * @param {proto.IUserLoginResponse=} [properties] Properties to set
         */
    function UserLoginResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserLoginResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserLoginResponse
         * @instance
         */
    UserLoginResponse.prototype.response = null;

    /**
         * UserLoginResponse deprecatedClient.
         * @member {boolean} deprecatedClient
         * @memberof proto.UserLoginResponse
         * @instance
         */
    UserLoginResponse.prototype.deprecatedClient = false;

    /**
         * UserLoginResponse secondaryNodeName.
         * @member {string} secondaryNodeName
         * @memberof proto.UserLoginResponse
         * @instance
         */
    UserLoginResponse.prototype.secondaryNodeName = '';

    /**
         * UserLoginResponse updateAvailable.
         * @member {boolean} updateAvailable
         * @memberof proto.UserLoginResponse
         * @instance
         */
    UserLoginResponse.prototype.updateAvailable = false;

    /**
         * UserLoginResponse chatDeleteMessageForBothPeriod.
         * @member {number} chatDeleteMessageForBothPeriod
         * @memberof proto.UserLoginResponse
         * @instance
         */
    UserLoginResponse.prototype.chatDeleteMessageForBothPeriod = 0;

    /**
         * Creates a new UserLoginResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserLoginResponse
         * @static
         * @param {proto.IUserLoginResponse=} [properties] Properties to set
         * @returns {proto.UserLoginResponse} UserLoginResponse instance
         */
    UserLoginResponse.create = function create(properties) {
      return new UserLoginResponse(properties);
    };

    /**
         * Encodes the specified UserLoginResponse message. Does not implicitly {@link proto.UserLoginResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserLoginResponse
         * @static
         * @param {proto.UserLoginResponse} message UserLoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserLoginResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.deprecatedClient != null && message.hasOwnProperty('deprecatedClient')) {writer.uint32(/* id 2, wireType 0 =*/16).bool(message.deprecatedClient);}
      if (message.secondaryNodeName != null && message.hasOwnProperty('secondaryNodeName')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.secondaryNodeName);}
      if (message.updateAvailable != null && message.hasOwnProperty('updateAvailable')) {writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateAvailable);}
      if (message.chatDeleteMessageForBothPeriod != null && message.hasOwnProperty('chatDeleteMessageForBothPeriod')) {writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.chatDeleteMessageForBothPeriod);}
      return writer;
    };

    /**
         * Decodes a UserLoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserLoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserLoginResponse} UserLoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserLoginResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserLoginResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.deprecatedClient = reader.bool();
            break;
          case 3:
            message.secondaryNodeName = reader.string();
            break;
          case 4:
            message.updateAvailable = reader.bool();
            break;
          case 5:
            message.chatDeleteMessageForBothPeriod = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserLoginResponse message.
         * @function verify
         * @memberof proto.UserLoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserLoginResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.deprecatedClient != null && message.hasOwnProperty('deprecatedClient')) {
        if (typeof message.deprecatedClient !== 'boolean') {return 'deprecatedClient: boolean expected';}
      }
      if (message.secondaryNodeName != null && message.hasOwnProperty('secondaryNodeName')) {
        if (!$util.isString(message.secondaryNodeName)) {return 'secondaryNodeName: string expected';}
      }
      if (message.updateAvailable != null && message.hasOwnProperty('updateAvailable')) {
        if (typeof message.updateAvailable !== 'boolean') {return 'updateAvailable: boolean expected';}
      }
      if (message.chatDeleteMessageForBothPeriod != null && message.hasOwnProperty('chatDeleteMessageForBothPeriod')) {
        if (!$util.isInteger(message.chatDeleteMessageForBothPeriod)) {return 'chatDeleteMessageForBothPeriod: integer expected';}
      }
      return null;
    };

    return UserLoginResponse;
  })();

  proto.UserPrivacyGetRule = (function() {

    /**
         * Properties of a UserPrivacyGetRule.
         * @memberof proto
         * @interface IUserPrivacyGetRule
         * @property {proto.Request|null} [request] UserPrivacyGetRule request
         * @property {proto.PrivacyType|null} [type] UserPrivacyGetRule type
         */

    /**
         * Constructs a new UserPrivacyGetRule.
         * @memberof proto
         * @classdesc Represents a UserPrivacyGetRule.
         * @implements IUserPrivacyGetRule
         * @constructor
         * @param {proto.IUserPrivacyGetRule=} [properties] Properties to set
         */
    function UserPrivacyGetRule(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserPrivacyGetRule request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserPrivacyGetRule
         * @instance
         */
    UserPrivacyGetRule.prototype.request = null;

    /**
         * UserPrivacyGetRule type.
         * @member {proto.PrivacyType} type
         * @memberof proto.UserPrivacyGetRule
         * @instance
         */
    UserPrivacyGetRule.prototype.type = 0;

    /**
         * Creates a new UserPrivacyGetRule instance using the specified properties.
         * @function create
         * @memberof proto.UserPrivacyGetRule
         * @static
         * @param {proto.IUserPrivacyGetRule=} [properties] Properties to set
         * @returns {proto.UserPrivacyGetRule} UserPrivacyGetRule instance
         */
    UserPrivacyGetRule.create = function create(properties) {
      return new UserPrivacyGetRule(properties);
    };

    /**
         * Encodes the specified UserPrivacyGetRule message. Does not implicitly {@link proto.UserPrivacyGetRule.verify|verify} messages.
         * @function encode
         * @memberof proto.UserPrivacyGetRule
         * @static
         * @param {proto.UserPrivacyGetRule} message UserPrivacyGetRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserPrivacyGetRule.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      return writer;
    };

    /**
         * Decodes a UserPrivacyGetRule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserPrivacyGetRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserPrivacyGetRule} UserPrivacyGetRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserPrivacyGetRule.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserPrivacyGetRule();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.type = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserPrivacyGetRule message.
         * @function verify
         * @memberof proto.UserPrivacyGetRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserPrivacyGetRule.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      }
      return null;
    };

    return UserPrivacyGetRule;
  })();

  proto.UserPrivacyGetRuleResponse = (function() {

    /**
         * Properties of a UserPrivacyGetRuleResponse.
         * @memberof proto
         * @interface IUserPrivacyGetRuleResponse
         * @property {proto.Response|null} [response] UserPrivacyGetRuleResponse response
         * @property {proto.PrivacyLevel|null} [level] UserPrivacyGetRuleResponse level
         */

    /**
         * Constructs a new UserPrivacyGetRuleResponse.
         * @memberof proto
         * @classdesc Represents a UserPrivacyGetRuleResponse.
         * @implements IUserPrivacyGetRuleResponse
         * @constructor
         * @param {proto.IUserPrivacyGetRuleResponse=} [properties] Properties to set
         */
    function UserPrivacyGetRuleResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserPrivacyGetRuleResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserPrivacyGetRuleResponse
         * @instance
         */
    UserPrivacyGetRuleResponse.prototype.response = null;

    /**
         * UserPrivacyGetRuleResponse level.
         * @member {proto.PrivacyLevel} level
         * @memberof proto.UserPrivacyGetRuleResponse
         * @instance
         */
    UserPrivacyGetRuleResponse.prototype.level = 0;

    /**
         * Creates a new UserPrivacyGetRuleResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserPrivacyGetRuleResponse
         * @static
         * @param {proto.IUserPrivacyGetRuleResponse=} [properties] Properties to set
         * @returns {proto.UserPrivacyGetRuleResponse} UserPrivacyGetRuleResponse instance
         */
    UserPrivacyGetRuleResponse.create = function create(properties) {
      return new UserPrivacyGetRuleResponse(properties);
    };

    /**
         * Encodes the specified UserPrivacyGetRuleResponse message. Does not implicitly {@link proto.UserPrivacyGetRuleResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserPrivacyGetRuleResponse
         * @static
         * @param {proto.UserPrivacyGetRuleResponse} message UserPrivacyGetRuleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserPrivacyGetRuleResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.level != null && message.hasOwnProperty('level')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);}
      return writer;
    };

    /**
         * Decodes a UserPrivacyGetRuleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserPrivacyGetRuleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserPrivacyGetRuleResponse} UserPrivacyGetRuleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserPrivacyGetRuleResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserPrivacyGetRuleResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 3:
            message.level = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserPrivacyGetRuleResponse message.
         * @function verify
         * @memberof proto.UserPrivacyGetRuleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserPrivacyGetRuleResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.level != null && message.hasOwnProperty('level')) {
        switch (message.level) {
          default:
            return 'level: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserPrivacyGetRuleResponse;
  })();

  proto.UserPrivacySetRule = (function() {

    /**
         * Properties of a UserPrivacySetRule.
         * @memberof proto
         * @interface IUserPrivacySetRule
         * @property {proto.Request|null} [request] UserPrivacySetRule request
         * @property {proto.PrivacyType|null} [type] UserPrivacySetRule type
         * @property {proto.PrivacyLevel|null} [level] UserPrivacySetRule level
         */

    /**
         * Constructs a new UserPrivacySetRule.
         * @memberof proto
         * @classdesc Represents a UserPrivacySetRule.
         * @implements IUserPrivacySetRule
         * @constructor
         * @param {proto.IUserPrivacySetRule=} [properties] Properties to set
         */
    function UserPrivacySetRule(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserPrivacySetRule request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserPrivacySetRule
         * @instance
         */
    UserPrivacySetRule.prototype.request = null;

    /**
         * UserPrivacySetRule type.
         * @member {proto.PrivacyType} type
         * @memberof proto.UserPrivacySetRule
         * @instance
         */
    UserPrivacySetRule.prototype.type = 0;

    /**
         * UserPrivacySetRule level.
         * @member {proto.PrivacyLevel} level
         * @memberof proto.UserPrivacySetRule
         * @instance
         */
    UserPrivacySetRule.prototype.level = 0;

    /**
         * Creates a new UserPrivacySetRule instance using the specified properties.
         * @function create
         * @memberof proto.UserPrivacySetRule
         * @static
         * @param {proto.IUserPrivacySetRule=} [properties] Properties to set
         * @returns {proto.UserPrivacySetRule} UserPrivacySetRule instance
         */
    UserPrivacySetRule.create = function create(properties) {
      return new UserPrivacySetRule(properties);
    };

    /**
         * Encodes the specified UserPrivacySetRule message. Does not implicitly {@link proto.UserPrivacySetRule.verify|verify} messages.
         * @function encode
         * @memberof proto.UserPrivacySetRule
         * @static
         * @param {proto.UserPrivacySetRule} message UserPrivacySetRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserPrivacySetRule.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      if (message.level != null && message.hasOwnProperty('level')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);}
      return writer;
    };

    /**
         * Decodes a UserPrivacySetRule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserPrivacySetRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserPrivacySetRule} UserPrivacySetRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserPrivacySetRule.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserPrivacySetRule();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.type = reader.int32();
            break;
          case 3:
            message.level = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserPrivacySetRule message.
         * @function verify
         * @memberof proto.UserPrivacySetRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserPrivacySetRule.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      }
      if (message.level != null && message.hasOwnProperty('level')) {
        switch (message.level) {
          default:
            return 'level: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserPrivacySetRule;
  })();

  proto.UserPrivacySetRuleResponse = (function() {

    /**
         * Properties of a UserPrivacySetRuleResponse.
         * @memberof proto
         * @interface IUserPrivacySetRuleResponse
         * @property {proto.Response|null} [response] UserPrivacySetRuleResponse response
         * @property {proto.PrivacyType|null} [type] UserPrivacySetRuleResponse type
         * @property {proto.PrivacyLevel|null} [level] UserPrivacySetRuleResponse level
         */

    /**
         * Constructs a new UserPrivacySetRuleResponse.
         * @memberof proto
         * @classdesc Represents a UserPrivacySetRuleResponse.
         * @implements IUserPrivacySetRuleResponse
         * @constructor
         * @param {proto.IUserPrivacySetRuleResponse=} [properties] Properties to set
         */
    function UserPrivacySetRuleResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserPrivacySetRuleResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserPrivacySetRuleResponse
         * @instance
         */
    UserPrivacySetRuleResponse.prototype.response = null;

    /**
         * UserPrivacySetRuleResponse type.
         * @member {proto.PrivacyType} type
         * @memberof proto.UserPrivacySetRuleResponse
         * @instance
         */
    UserPrivacySetRuleResponse.prototype.type = 0;

    /**
         * UserPrivacySetRuleResponse level.
         * @member {proto.PrivacyLevel} level
         * @memberof proto.UserPrivacySetRuleResponse
         * @instance
         */
    UserPrivacySetRuleResponse.prototype.level = 0;

    /**
         * Creates a new UserPrivacySetRuleResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserPrivacySetRuleResponse
         * @static
         * @param {proto.IUserPrivacySetRuleResponse=} [properties] Properties to set
         * @returns {proto.UserPrivacySetRuleResponse} UserPrivacySetRuleResponse instance
         */
    UserPrivacySetRuleResponse.create = function create(properties) {
      return new UserPrivacySetRuleResponse(properties);
    };

    /**
         * Encodes the specified UserPrivacySetRuleResponse message. Does not implicitly {@link proto.UserPrivacySetRuleResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserPrivacySetRuleResponse
         * @static
         * @param {proto.UserPrivacySetRuleResponse} message UserPrivacySetRuleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserPrivacySetRuleResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.type != null && message.hasOwnProperty('type')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);}
      if (message.level != null && message.hasOwnProperty('level')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);}
      return writer;
    };

    /**
         * Decodes a UserPrivacySetRuleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserPrivacySetRuleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserPrivacySetRuleResponse} UserPrivacySetRuleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserPrivacySetRuleResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserPrivacySetRuleResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.type = reader.int32();
            break;
          case 3:
            message.level = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserPrivacySetRuleResponse message.
         * @function verify
         * @memberof proto.UserPrivacySetRuleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserPrivacySetRuleResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.type != null && message.hasOwnProperty('type')) {
        switch (message.type) {
          default:
            return 'type: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      }
      if (message.level != null && message.hasOwnProperty('level')) {
        switch (message.level) {
          default:
            return 'level: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserPrivacySetRuleResponse;
  })();

  proto.UserProfileCheckUsername = (function() {

    /**
         * Properties of a UserProfileCheckUsername.
         * @memberof proto
         * @interface IUserProfileCheckUsername
         * @property {proto.Request|null} [request] UserProfileCheckUsername request
         * @property {string|null} [username] UserProfileCheckUsername username
         */

    /**
         * Constructs a new UserProfileCheckUsername.
         * @memberof proto
         * @classdesc Represents a UserProfileCheckUsername.
         * @implements IUserProfileCheckUsername
         * @constructor
         * @param {proto.IUserProfileCheckUsername=} [properties] Properties to set
         */
    function UserProfileCheckUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileCheckUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileCheckUsername
         * @instance
         */
    UserProfileCheckUsername.prototype.request = null;

    /**
         * UserProfileCheckUsername username.
         * @member {string} username
         * @memberof proto.UserProfileCheckUsername
         * @instance
         */
    UserProfileCheckUsername.prototype.username = '';

    /**
         * Creates a new UserProfileCheckUsername instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileCheckUsername
         * @static
         * @param {proto.IUserProfileCheckUsername=} [properties] Properties to set
         * @returns {proto.UserProfileCheckUsername} UserProfileCheckUsername instance
         */
    UserProfileCheckUsername.create = function create(properties) {
      return new UserProfileCheckUsername(properties);
    };

    /**
         * Encodes the specified UserProfileCheckUsername message. Does not implicitly {@link proto.UserProfileCheckUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileCheckUsername
         * @static
         * @param {proto.UserProfileCheckUsername} message UserProfileCheckUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileCheckUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a UserProfileCheckUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileCheckUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileCheckUsername} UserProfileCheckUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileCheckUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileCheckUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileCheckUsername message.
         * @function verify
         * @memberof proto.UserProfileCheckUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileCheckUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return UserProfileCheckUsername;
  })();

  proto.UserProfileCheckUsernameResponse = (function() {

    /**
         * Properties of a UserProfileCheckUsernameResponse.
         * @memberof proto
         * @interface IUserProfileCheckUsernameResponse
         * @property {proto.Response|null} [response] UserProfileCheckUsernameResponse response
         * @property {proto.UserProfileCheckUsernameResponse.Status|null} [status] UserProfileCheckUsernameResponse status
         */

    /**
         * Constructs a new UserProfileCheckUsernameResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileCheckUsernameResponse.
         * @implements IUserProfileCheckUsernameResponse
         * @constructor
         * @param {proto.IUserProfileCheckUsernameResponse=} [properties] Properties to set
         */
    function UserProfileCheckUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileCheckUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileCheckUsernameResponse
         * @instance
         */
    UserProfileCheckUsernameResponse.prototype.response = null;

    /**
         * UserProfileCheckUsernameResponse status.
         * @member {proto.UserProfileCheckUsernameResponse.Status} status
         * @memberof proto.UserProfileCheckUsernameResponse
         * @instance
         */
    UserProfileCheckUsernameResponse.prototype.status = 0;

    /**
         * Creates a new UserProfileCheckUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileCheckUsernameResponse
         * @static
         * @param {proto.IUserProfileCheckUsernameResponse=} [properties] Properties to set
         * @returns {proto.UserProfileCheckUsernameResponse} UserProfileCheckUsernameResponse instance
         */
    UserProfileCheckUsernameResponse.create = function create(properties) {
      return new UserProfileCheckUsernameResponse(properties);
    };

    /**
         * Encodes the specified UserProfileCheckUsernameResponse message. Does not implicitly {@link proto.UserProfileCheckUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileCheckUsernameResponse
         * @static
         * @param {proto.UserProfileCheckUsernameResponse} message UserProfileCheckUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileCheckUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a UserProfileCheckUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileCheckUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileCheckUsernameResponse} UserProfileCheckUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileCheckUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileCheckUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileCheckUsernameResponse message.
         * @function verify
         * @memberof proto.UserProfileCheckUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileCheckUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.UserProfileCheckUsernameResponse.Status
         * @enum {string}
         * @property {number} INVALID=0 INVALID value
         * @property {number} TAKEN=1 TAKEN value
         * @property {number} AVAILABLE=2 AVAILABLE value
         */
    UserProfileCheckUsernameResponse.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'INVALID'] = 0;
      values[valuesById[1] = 'TAKEN'] = 1;
      values[valuesById[2] = 'AVAILABLE'] = 2;
      return values;
    })();

    return UserProfileCheckUsernameResponse;
  })();

  proto.UserProfileGetBio = (function() {

    /**
         * Properties of a UserProfileGetBio.
         * @memberof proto
         * @interface IUserProfileGetBio
         * @property {proto.Request|null} [request] UserProfileGetBio request
         */

    /**
         * Constructs a new UserProfileGetBio.
         * @memberof proto
         * @classdesc Represents a UserProfileGetBio.
         * @implements IUserProfileGetBio
         * @constructor
         * @param {proto.IUserProfileGetBio=} [properties] Properties to set
         */
    function UserProfileGetBio(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetBio request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileGetBio
         * @instance
         */
    UserProfileGetBio.prototype.request = null;

    /**
         * Creates a new UserProfileGetBio instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetBio
         * @static
         * @param {proto.IUserProfileGetBio=} [properties] Properties to set
         * @returns {proto.UserProfileGetBio} UserProfileGetBio instance
         */
    UserProfileGetBio.create = function create(properties) {
      return new UserProfileGetBio(properties);
    };

    /**
         * Encodes the specified UserProfileGetBio message. Does not implicitly {@link proto.UserProfileGetBio.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetBio
         * @static
         * @param {proto.UserProfileGetBio} message UserProfileGetBio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetBio.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserProfileGetBio message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetBio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetBio} UserProfileGetBio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetBio.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetBio();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetBio message.
         * @function verify
         * @memberof proto.UserProfileGetBio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetBio.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserProfileGetBio;
  })();

  proto.UserProfileGetBioResponse = (function() {

    /**
         * Properties of a UserProfileGetBioResponse.
         * @memberof proto
         * @interface IUserProfileGetBioResponse
         * @property {proto.Response|null} [response] UserProfileGetBioResponse response
         * @property {string|null} [bio] UserProfileGetBioResponse bio
         */

    /**
         * Constructs a new UserProfileGetBioResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileGetBioResponse.
         * @implements IUserProfileGetBioResponse
         * @constructor
         * @param {proto.IUserProfileGetBioResponse=} [properties] Properties to set
         */
    function UserProfileGetBioResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetBioResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileGetBioResponse
         * @instance
         */
    UserProfileGetBioResponse.prototype.response = null;

    /**
         * UserProfileGetBioResponse bio.
         * @member {string} bio
         * @memberof proto.UserProfileGetBioResponse
         * @instance
         */
    UserProfileGetBioResponse.prototype.bio = '';

    /**
         * Creates a new UserProfileGetBioResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetBioResponse
         * @static
         * @param {proto.IUserProfileGetBioResponse=} [properties] Properties to set
         * @returns {proto.UserProfileGetBioResponse} UserProfileGetBioResponse instance
         */
    UserProfileGetBioResponse.create = function create(properties) {
      return new UserProfileGetBioResponse(properties);
    };

    /**
         * Encodes the specified UserProfileGetBioResponse message. Does not implicitly {@link proto.UserProfileGetBioResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetBioResponse
         * @static
         * @param {proto.UserProfileGetBioResponse} message UserProfileGetBioResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetBioResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.bio != null && message.hasOwnProperty('bio')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.bio);}
      return writer;
    };

    /**
         * Decodes a UserProfileGetBioResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetBioResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetBioResponse} UserProfileGetBioResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetBioResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetBioResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.bio = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetBioResponse message.
         * @function verify
         * @memberof proto.UserProfileGetBioResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetBioResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.bio != null && message.hasOwnProperty('bio')) {
        if (!$util.isString(message.bio)) {return 'bio: string expected';}
      }
      return null;
    };

    return UserProfileGetBioResponse;
  })();

  proto.UserProfileGetEmail = (function() {

    /**
         * Properties of a UserProfileGetEmail.
         * @memberof proto
         * @interface IUserProfileGetEmail
         * @property {proto.Request|null} [request] UserProfileGetEmail request
         */

    /**
         * Constructs a new UserProfileGetEmail.
         * @memberof proto
         * @classdesc Represents a UserProfileGetEmail.
         * @implements IUserProfileGetEmail
         * @constructor
         * @param {proto.IUserProfileGetEmail=} [properties] Properties to set
         */
    function UserProfileGetEmail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetEmail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileGetEmail
         * @instance
         */
    UserProfileGetEmail.prototype.request = null;

    /**
         * Creates a new UserProfileGetEmail instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetEmail
         * @static
         * @param {proto.IUserProfileGetEmail=} [properties] Properties to set
         * @returns {proto.UserProfileGetEmail} UserProfileGetEmail instance
         */
    UserProfileGetEmail.create = function create(properties) {
      return new UserProfileGetEmail(properties);
    };

    /**
         * Encodes the specified UserProfileGetEmail message. Does not implicitly {@link proto.UserProfileGetEmail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetEmail
         * @static
         * @param {proto.UserProfileGetEmail} message UserProfileGetEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetEmail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserProfileGetEmail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetEmail} UserProfileGetEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetEmail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetEmail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetEmail message.
         * @function verify
         * @memberof proto.UserProfileGetEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetEmail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserProfileGetEmail;
  })();

  proto.UserProfileGetEmailResponse = (function() {

    /**
         * Properties of a UserProfileGetEmailResponse.
         * @memberof proto
         * @interface IUserProfileGetEmailResponse
         * @property {proto.Response|null} [response] UserProfileGetEmailResponse response
         * @property {string|null} [email] UserProfileGetEmailResponse email
         */

    /**
         * Constructs a new UserProfileGetEmailResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileGetEmailResponse.
         * @implements IUserProfileGetEmailResponse
         * @constructor
         * @param {proto.IUserProfileGetEmailResponse=} [properties] Properties to set
         */
    function UserProfileGetEmailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetEmailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileGetEmailResponse
         * @instance
         */
    UserProfileGetEmailResponse.prototype.response = null;

    /**
         * UserProfileGetEmailResponse email.
         * @member {string} email
         * @memberof proto.UserProfileGetEmailResponse
         * @instance
         */
    UserProfileGetEmailResponse.prototype.email = '';

    /**
         * Creates a new UserProfileGetEmailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetEmailResponse
         * @static
         * @param {proto.IUserProfileGetEmailResponse=} [properties] Properties to set
         * @returns {proto.UserProfileGetEmailResponse} UserProfileGetEmailResponse instance
         */
    UserProfileGetEmailResponse.create = function create(properties) {
      return new UserProfileGetEmailResponse(properties);
    };

    /**
         * Encodes the specified UserProfileGetEmailResponse message. Does not implicitly {@link proto.UserProfileGetEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetEmailResponse
         * @static
         * @param {proto.UserProfileGetEmailResponse} message UserProfileGetEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetEmailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.email != null && message.hasOwnProperty('email')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);}
      return writer;
    };

    /**
         * Decodes a UserProfileGetEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetEmailResponse} UserProfileGetEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetEmailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetEmailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.email = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetEmailResponse message.
         * @function verify
         * @memberof proto.UserProfileGetEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetEmailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.email != null && message.hasOwnProperty('email')) {
        if (!$util.isString(message.email)) {return 'email: string expected';}
      }
      return null;
    };

    return UserProfileGetEmailResponse;
  })();

  proto.UserProfileGetGender = (function() {

    /**
         * Properties of a UserProfileGetGender.
         * @memberof proto
         * @interface IUserProfileGetGender
         * @property {proto.Request|null} [request] UserProfileGetGender request
         */

    /**
         * Constructs a new UserProfileGetGender.
         * @memberof proto
         * @classdesc Represents a UserProfileGetGender.
         * @implements IUserProfileGetGender
         * @constructor
         * @param {proto.IUserProfileGetGender=} [properties] Properties to set
         */
    function UserProfileGetGender(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetGender request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileGetGender
         * @instance
         */
    UserProfileGetGender.prototype.request = null;

    /**
         * Creates a new UserProfileGetGender instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetGender
         * @static
         * @param {proto.IUserProfileGetGender=} [properties] Properties to set
         * @returns {proto.UserProfileGetGender} UserProfileGetGender instance
         */
    UserProfileGetGender.create = function create(properties) {
      return new UserProfileGetGender(properties);
    };

    /**
         * Encodes the specified UserProfileGetGender message. Does not implicitly {@link proto.UserProfileGetGender.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetGender
         * @static
         * @param {proto.UserProfileGetGender} message UserProfileGetGender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetGender.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserProfileGetGender message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetGender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetGender} UserProfileGetGender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetGender.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetGender();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetGender message.
         * @function verify
         * @memberof proto.UserProfileGetGender
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetGender.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserProfileGetGender;
  })();

  proto.UserProfileGetGenderResponse = (function() {

    /**
         * Properties of a UserProfileGetGenderResponse.
         * @memberof proto
         * @interface IUserProfileGetGenderResponse
         * @property {proto.Response|null} [response] UserProfileGetGenderResponse response
         * @property {proto.Gender|null} [gender] UserProfileGetGenderResponse gender
         */

    /**
         * Constructs a new UserProfileGetGenderResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileGetGenderResponse.
         * @implements IUserProfileGetGenderResponse
         * @constructor
         * @param {proto.IUserProfileGetGenderResponse=} [properties] Properties to set
         */
    function UserProfileGetGenderResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetGenderResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileGetGenderResponse
         * @instance
         */
    UserProfileGetGenderResponse.prototype.response = null;

    /**
         * UserProfileGetGenderResponse gender.
         * @member {proto.Gender} gender
         * @memberof proto.UserProfileGetGenderResponse
         * @instance
         */
    UserProfileGetGenderResponse.prototype.gender = 0;

    /**
         * Creates a new UserProfileGetGenderResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetGenderResponse
         * @static
         * @param {proto.IUserProfileGetGenderResponse=} [properties] Properties to set
         * @returns {proto.UserProfileGetGenderResponse} UserProfileGetGenderResponse instance
         */
    UserProfileGetGenderResponse.create = function create(properties) {
      return new UserProfileGetGenderResponse(properties);
    };

    /**
         * Encodes the specified UserProfileGetGenderResponse message. Does not implicitly {@link proto.UserProfileGetGenderResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetGenderResponse
         * @static
         * @param {proto.UserProfileGetGenderResponse} message UserProfileGetGenderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetGenderResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.gender != null && message.hasOwnProperty('gender')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gender);}
      return writer;
    };

    /**
         * Decodes a UserProfileGetGenderResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetGenderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetGenderResponse} UserProfileGetGenderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetGenderResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetGenderResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.gender = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetGenderResponse message.
         * @function verify
         * @memberof proto.UserProfileGetGenderResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetGenderResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.gender != null && message.hasOwnProperty('gender')) {
        switch (message.gender) {
          default:
            return 'gender: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserProfileGetGenderResponse;
  })();

  proto.UserProfileGetNickname = (function() {

    /**
         * Properties of a UserProfileGetNickname.
         * @memberof proto
         * @interface IUserProfileGetNickname
         * @property {proto.Request|null} [request] UserProfileGetNickname request
         */

    /**
         * Constructs a new UserProfileGetNickname.
         * @memberof proto
         * @classdesc Represents a UserProfileGetNickname.
         * @implements IUserProfileGetNickname
         * @constructor
         * @param {proto.IUserProfileGetNickname=} [properties] Properties to set
         */
    function UserProfileGetNickname(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetNickname request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileGetNickname
         * @instance
         */
    UserProfileGetNickname.prototype.request = null;

    /**
         * Creates a new UserProfileGetNickname instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetNickname
         * @static
         * @param {proto.IUserProfileGetNickname=} [properties] Properties to set
         * @returns {proto.UserProfileGetNickname} UserProfileGetNickname instance
         */
    UserProfileGetNickname.create = function create(properties) {
      return new UserProfileGetNickname(properties);
    };

    /**
         * Encodes the specified UserProfileGetNickname message. Does not implicitly {@link proto.UserProfileGetNickname.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetNickname
         * @static
         * @param {proto.UserProfileGetNickname} message UserProfileGetNickname message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetNickname.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserProfileGetNickname message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetNickname
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetNickname} UserProfileGetNickname
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetNickname.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetNickname();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetNickname message.
         * @function verify
         * @memberof proto.UserProfileGetNickname
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetNickname.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserProfileGetNickname;
  })();

  proto.UserProfileGetNicknameResponse = (function() {

    /**
         * Properties of a UserProfileGetNicknameResponse.
         * @memberof proto
         * @interface IUserProfileGetNicknameResponse
         * @property {proto.Response|null} [response] UserProfileGetNicknameResponse response
         * @property {string|null} [nickname] UserProfileGetNicknameResponse nickname
         */

    /**
         * Constructs a new UserProfileGetNicknameResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileGetNicknameResponse.
         * @implements IUserProfileGetNicknameResponse
         * @constructor
         * @param {proto.IUserProfileGetNicknameResponse=} [properties] Properties to set
         */
    function UserProfileGetNicknameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetNicknameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileGetNicknameResponse
         * @instance
         */
    UserProfileGetNicknameResponse.prototype.response = null;

    /**
         * UserProfileGetNicknameResponse nickname.
         * @member {string} nickname
         * @memberof proto.UserProfileGetNicknameResponse
         * @instance
         */
    UserProfileGetNicknameResponse.prototype.nickname = '';

    /**
         * Creates a new UserProfileGetNicknameResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetNicknameResponse
         * @static
         * @param {proto.IUserProfileGetNicknameResponse=} [properties] Properties to set
         * @returns {proto.UserProfileGetNicknameResponse} UserProfileGetNicknameResponse instance
         */
    UserProfileGetNicknameResponse.create = function create(properties) {
      return new UserProfileGetNicknameResponse(properties);
    };

    /**
         * Encodes the specified UserProfileGetNicknameResponse message. Does not implicitly {@link proto.UserProfileGetNicknameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetNicknameResponse
         * @static
         * @param {proto.UserProfileGetNicknameResponse} message UserProfileGetNicknameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetNicknameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.nickname != null && message.hasOwnProperty('nickname')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);}
      return writer;
    };

    /**
         * Decodes a UserProfileGetNicknameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetNicknameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetNicknameResponse} UserProfileGetNicknameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetNicknameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetNicknameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.nickname = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetNicknameResponse message.
         * @function verify
         * @memberof proto.UserProfileGetNicknameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetNicknameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.nickname != null && message.hasOwnProperty('nickname')) {
        if (!$util.isString(message.nickname)) {return 'nickname: string expected';}
      }
      return null;
    };

    return UserProfileGetNicknameResponse;
  })();

  proto.UserProfileGetSelfRemove = (function() {

    /**
         * Properties of a UserProfileGetSelfRemove.
         * @memberof proto
         * @interface IUserProfileGetSelfRemove
         * @property {proto.Request|null} [request] UserProfileGetSelfRemove request
         */

    /**
         * Constructs a new UserProfileGetSelfRemove.
         * @memberof proto
         * @classdesc Represents a UserProfileGetSelfRemove.
         * @implements IUserProfileGetSelfRemove
         * @constructor
         * @param {proto.IUserProfileGetSelfRemove=} [properties] Properties to set
         */
    function UserProfileGetSelfRemove(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetSelfRemove request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileGetSelfRemove
         * @instance
         */
    UserProfileGetSelfRemove.prototype.request = null;

    /**
         * Creates a new UserProfileGetSelfRemove instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetSelfRemove
         * @static
         * @param {proto.IUserProfileGetSelfRemove=} [properties] Properties to set
         * @returns {proto.UserProfileGetSelfRemove} UserProfileGetSelfRemove instance
         */
    UserProfileGetSelfRemove.create = function create(properties) {
      return new UserProfileGetSelfRemove(properties);
    };

    /**
         * Encodes the specified UserProfileGetSelfRemove message. Does not implicitly {@link proto.UserProfileGetSelfRemove.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetSelfRemove
         * @static
         * @param {proto.UserProfileGetSelfRemove} message UserProfileGetSelfRemove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetSelfRemove.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserProfileGetSelfRemove message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetSelfRemove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetSelfRemove} UserProfileGetSelfRemove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetSelfRemove.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetSelfRemove();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetSelfRemove message.
         * @function verify
         * @memberof proto.UserProfileGetSelfRemove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetSelfRemove.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserProfileGetSelfRemove;
  })();

  proto.UserProfileGetSelfRemoveResponse = (function() {

    /**
         * Properties of a UserProfileGetSelfRemoveResponse.
         * @memberof proto
         * @interface IUserProfileGetSelfRemoveResponse
         * @property {proto.Response|null} [response] UserProfileGetSelfRemoveResponse response
         * @property {number|null} [selfRemove] UserProfileGetSelfRemoveResponse selfRemove
         */

    /**
         * Constructs a new UserProfileGetSelfRemoveResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileGetSelfRemoveResponse.
         * @implements IUserProfileGetSelfRemoveResponse
         * @constructor
         * @param {proto.IUserProfileGetSelfRemoveResponse=} [properties] Properties to set
         */
    function UserProfileGetSelfRemoveResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileGetSelfRemoveResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @instance
         */
    UserProfileGetSelfRemoveResponse.prototype.response = null;

    /**
         * UserProfileGetSelfRemoveResponse selfRemove.
         * @member {number} selfRemove
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @instance
         */
    UserProfileGetSelfRemoveResponse.prototype.selfRemove = 0;

    /**
         * Creates a new UserProfileGetSelfRemoveResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @static
         * @param {proto.IUserProfileGetSelfRemoveResponse=} [properties] Properties to set
         * @returns {proto.UserProfileGetSelfRemoveResponse} UserProfileGetSelfRemoveResponse instance
         */
    UserProfileGetSelfRemoveResponse.create = function create(properties) {
      return new UserProfileGetSelfRemoveResponse(properties);
    };

    /**
         * Encodes the specified UserProfileGetSelfRemoveResponse message. Does not implicitly {@link proto.UserProfileGetSelfRemoveResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @static
         * @param {proto.UserProfileGetSelfRemoveResponse} message UserProfileGetSelfRemoveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileGetSelfRemoveResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selfRemove);}
      return writer;
    };

    /**
         * Decodes a UserProfileGetSelfRemoveResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileGetSelfRemoveResponse} UserProfileGetSelfRemoveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileGetSelfRemoveResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileGetSelfRemoveResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.selfRemove = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileGetSelfRemoveResponse message.
         * @function verify
         * @memberof proto.UserProfileGetSelfRemoveResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileGetSelfRemoveResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {
        if (!$util.isInteger(message.selfRemove)) {return 'selfRemove: integer expected';}
      }
      return null;
    };

    return UserProfileGetSelfRemoveResponse;
  })();

  proto.UserProfileSetBio = (function() {

    /**
         * Properties of a UserProfileSetBio.
         * @memberof proto
         * @interface IUserProfileSetBio
         * @property {proto.Request|null} [request] UserProfileSetBio request
         * @property {string|null} [bio] UserProfileSetBio bio
         */

    /**
         * Constructs a new UserProfileSetBio.
         * @memberof proto
         * @classdesc Represents a UserProfileSetBio.
         * @implements IUserProfileSetBio
         * @constructor
         * @param {proto.IUserProfileSetBio=} [properties] Properties to set
         */
    function UserProfileSetBio(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetBio request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileSetBio
         * @instance
         */
    UserProfileSetBio.prototype.request = null;

    /**
         * UserProfileSetBio bio.
         * @member {string} bio
         * @memberof proto.UserProfileSetBio
         * @instance
         */
    UserProfileSetBio.prototype.bio = '';

    /**
         * Creates a new UserProfileSetBio instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetBio
         * @static
         * @param {proto.IUserProfileSetBio=} [properties] Properties to set
         * @returns {proto.UserProfileSetBio} UserProfileSetBio instance
         */
    UserProfileSetBio.create = function create(properties) {
      return new UserProfileSetBio(properties);
    };

    /**
         * Encodes the specified UserProfileSetBio message. Does not implicitly {@link proto.UserProfileSetBio.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetBio
         * @static
         * @param {proto.UserProfileSetBio} message UserProfileSetBio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetBio.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.bio != null && message.hasOwnProperty('bio')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.bio);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetBio message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetBio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetBio} UserProfileSetBio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetBio.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetBio();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.bio = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetBio message.
         * @function verify
         * @memberof proto.UserProfileSetBio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetBio.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.bio != null && message.hasOwnProperty('bio')) {
        if (!$util.isString(message.bio)) {return 'bio: string expected';}
      }
      return null;
    };

    return UserProfileSetBio;
  })();

  proto.UserProfileSetBioResponse = (function() {

    /**
         * Properties of a UserProfileSetBioResponse.
         * @memberof proto
         * @interface IUserProfileSetBioResponse
         * @property {proto.Response|null} [response] UserProfileSetBioResponse response
         * @property {string|null} [bio] UserProfileSetBioResponse bio
         */

    /**
         * Constructs a new UserProfileSetBioResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileSetBioResponse.
         * @implements IUserProfileSetBioResponse
         * @constructor
         * @param {proto.IUserProfileSetBioResponse=} [properties] Properties to set
         */
    function UserProfileSetBioResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetBioResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileSetBioResponse
         * @instance
         */
    UserProfileSetBioResponse.prototype.response = null;

    /**
         * UserProfileSetBioResponse bio.
         * @member {string} bio
         * @memberof proto.UserProfileSetBioResponse
         * @instance
         */
    UserProfileSetBioResponse.prototype.bio = '';

    /**
         * Creates a new UserProfileSetBioResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetBioResponse
         * @static
         * @param {proto.IUserProfileSetBioResponse=} [properties] Properties to set
         * @returns {proto.UserProfileSetBioResponse} UserProfileSetBioResponse instance
         */
    UserProfileSetBioResponse.create = function create(properties) {
      return new UserProfileSetBioResponse(properties);
    };

    /**
         * Encodes the specified UserProfileSetBioResponse message. Does not implicitly {@link proto.UserProfileSetBioResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetBioResponse
         * @static
         * @param {proto.UserProfileSetBioResponse} message UserProfileSetBioResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetBioResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.bio != null && message.hasOwnProperty('bio')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.bio);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetBioResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetBioResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetBioResponse} UserProfileSetBioResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetBioResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetBioResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.bio = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetBioResponse message.
         * @function verify
         * @memberof proto.UserProfileSetBioResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetBioResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.bio != null && message.hasOwnProperty('bio')) {
        if (!$util.isString(message.bio)) {return 'bio: string expected';}
      }
      return null;
    };

    return UserProfileSetBioResponse;
  })();

  proto.UserProfileSetEmail = (function() {

    /**
         * Properties of a UserProfileSetEmail.
         * @memberof proto
         * @interface IUserProfileSetEmail
         * @property {proto.Request|null} [request] UserProfileSetEmail request
         * @property {string|null} [email] UserProfileSetEmail email
         */

    /**
         * Constructs a new UserProfileSetEmail.
         * @memberof proto
         * @classdesc Represents a UserProfileSetEmail.
         * @implements IUserProfileSetEmail
         * @constructor
         * @param {proto.IUserProfileSetEmail=} [properties] Properties to set
         */
    function UserProfileSetEmail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetEmail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileSetEmail
         * @instance
         */
    UserProfileSetEmail.prototype.request = null;

    /**
         * UserProfileSetEmail email.
         * @member {string} email
         * @memberof proto.UserProfileSetEmail
         * @instance
         */
    UserProfileSetEmail.prototype.email = '';

    /**
         * Creates a new UserProfileSetEmail instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetEmail
         * @static
         * @param {proto.IUserProfileSetEmail=} [properties] Properties to set
         * @returns {proto.UserProfileSetEmail} UserProfileSetEmail instance
         */
    UserProfileSetEmail.create = function create(properties) {
      return new UserProfileSetEmail(properties);
    };

    /**
         * Encodes the specified UserProfileSetEmail message. Does not implicitly {@link proto.UserProfileSetEmail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetEmail
         * @static
         * @param {proto.UserProfileSetEmail} message UserProfileSetEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetEmail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.email != null && message.hasOwnProperty('email')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetEmail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetEmail} UserProfileSetEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetEmail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetEmail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.email = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetEmail message.
         * @function verify
         * @memberof proto.UserProfileSetEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetEmail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.email != null && message.hasOwnProperty('email')) {
        if (!$util.isString(message.email)) {return 'email: string expected';}
      }
      return null;
    };

    return UserProfileSetEmail;
  })();

  proto.UserProfileSetEmailResponse = (function() {

    /**
         * Properties of a UserProfileSetEmailResponse.
         * @memberof proto
         * @interface IUserProfileSetEmailResponse
         * @property {proto.Response|null} [response] UserProfileSetEmailResponse response
         * @property {string|null} [email] UserProfileSetEmailResponse email
         */

    /**
         * Constructs a new UserProfileSetEmailResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileSetEmailResponse.
         * @implements IUserProfileSetEmailResponse
         * @constructor
         * @param {proto.IUserProfileSetEmailResponse=} [properties] Properties to set
         */
    function UserProfileSetEmailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetEmailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileSetEmailResponse
         * @instance
         */
    UserProfileSetEmailResponse.prototype.response = null;

    /**
         * UserProfileSetEmailResponse email.
         * @member {string} email
         * @memberof proto.UserProfileSetEmailResponse
         * @instance
         */
    UserProfileSetEmailResponse.prototype.email = '';

    /**
         * Creates a new UserProfileSetEmailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetEmailResponse
         * @static
         * @param {proto.IUserProfileSetEmailResponse=} [properties] Properties to set
         * @returns {proto.UserProfileSetEmailResponse} UserProfileSetEmailResponse instance
         */
    UserProfileSetEmailResponse.create = function create(properties) {
      return new UserProfileSetEmailResponse(properties);
    };

    /**
         * Encodes the specified UserProfileSetEmailResponse message. Does not implicitly {@link proto.UserProfileSetEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetEmailResponse
         * @static
         * @param {proto.UserProfileSetEmailResponse} message UserProfileSetEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetEmailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.email != null && message.hasOwnProperty('email')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetEmailResponse} UserProfileSetEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetEmailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetEmailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.email = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetEmailResponse message.
         * @function verify
         * @memberof proto.UserProfileSetEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetEmailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.email != null && message.hasOwnProperty('email')) {
        if (!$util.isString(message.email)) {return 'email: string expected';}
      }
      return null;
    };

    return UserProfileSetEmailResponse;
  })();

  proto.UserProfileSetGender = (function() {

    /**
         * Properties of a UserProfileSetGender.
         * @memberof proto
         * @interface IUserProfileSetGender
         * @property {proto.Request|null} [request] UserProfileSetGender request
         * @property {proto.Gender|null} [gender] UserProfileSetGender gender
         */

    /**
         * Constructs a new UserProfileSetGender.
         * @memberof proto
         * @classdesc Represents a UserProfileSetGender.
         * @implements IUserProfileSetGender
         * @constructor
         * @param {proto.IUserProfileSetGender=} [properties] Properties to set
         */
    function UserProfileSetGender(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetGender request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileSetGender
         * @instance
         */
    UserProfileSetGender.prototype.request = null;

    /**
         * UserProfileSetGender gender.
         * @member {proto.Gender} gender
         * @memberof proto.UserProfileSetGender
         * @instance
         */
    UserProfileSetGender.prototype.gender = 0;

    /**
         * Creates a new UserProfileSetGender instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetGender
         * @static
         * @param {proto.IUserProfileSetGender=} [properties] Properties to set
         * @returns {proto.UserProfileSetGender} UserProfileSetGender instance
         */
    UserProfileSetGender.create = function create(properties) {
      return new UserProfileSetGender(properties);
    };

    /**
         * Encodes the specified UserProfileSetGender message. Does not implicitly {@link proto.UserProfileSetGender.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetGender
         * @static
         * @param {proto.UserProfileSetGender} message UserProfileSetGender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetGender.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.gender != null && message.hasOwnProperty('gender')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gender);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetGender message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetGender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetGender} UserProfileSetGender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetGender.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetGender();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.gender = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetGender message.
         * @function verify
         * @memberof proto.UserProfileSetGender
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetGender.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.gender != null && message.hasOwnProperty('gender')) {
        switch (message.gender) {
          default:
            return 'gender: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserProfileSetGender;
  })();

  proto.UserProfileSetGenderResponse = (function() {

    /**
         * Properties of a UserProfileSetGenderResponse.
         * @memberof proto
         * @interface IUserProfileSetGenderResponse
         * @property {proto.Response|null} [response] UserProfileSetGenderResponse response
         * @property {proto.Gender|null} [gender] UserProfileSetGenderResponse gender
         */

    /**
         * Constructs a new UserProfileSetGenderResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileSetGenderResponse.
         * @implements IUserProfileSetGenderResponse
         * @constructor
         * @param {proto.IUserProfileSetGenderResponse=} [properties] Properties to set
         */
    function UserProfileSetGenderResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetGenderResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileSetGenderResponse
         * @instance
         */
    UserProfileSetGenderResponse.prototype.response = null;

    /**
         * UserProfileSetGenderResponse gender.
         * @member {proto.Gender} gender
         * @memberof proto.UserProfileSetGenderResponse
         * @instance
         */
    UserProfileSetGenderResponse.prototype.gender = 0;

    /**
         * Creates a new UserProfileSetGenderResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetGenderResponse
         * @static
         * @param {proto.IUserProfileSetGenderResponse=} [properties] Properties to set
         * @returns {proto.UserProfileSetGenderResponse} UserProfileSetGenderResponse instance
         */
    UserProfileSetGenderResponse.create = function create(properties) {
      return new UserProfileSetGenderResponse(properties);
    };

    /**
         * Encodes the specified UserProfileSetGenderResponse message. Does not implicitly {@link proto.UserProfileSetGenderResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetGenderResponse
         * @static
         * @param {proto.UserProfileSetGenderResponse} message UserProfileSetGenderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetGenderResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.gender != null && message.hasOwnProperty('gender')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gender);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetGenderResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetGenderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetGenderResponse} UserProfileSetGenderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetGenderResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetGenderResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.gender = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetGenderResponse message.
         * @function verify
         * @memberof proto.UserProfileSetGenderResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetGenderResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.gender != null && message.hasOwnProperty('gender')) {
        switch (message.gender) {
          default:
            return 'gender: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      return null;
    };

    return UserProfileSetGenderResponse;
  })();

  proto.UserProfileSetNickname = (function() {

    /**
         * Properties of a UserProfileSetNickname.
         * @memberof proto
         * @interface IUserProfileSetNickname
         * @property {proto.Request|null} [request] UserProfileSetNickname request
         * @property {string|null} [nickname] UserProfileSetNickname nickname
         */

    /**
         * Constructs a new UserProfileSetNickname.
         * @memberof proto
         * @classdesc Represents a UserProfileSetNickname.
         * @implements IUserProfileSetNickname
         * @constructor
         * @param {proto.IUserProfileSetNickname=} [properties] Properties to set
         */
    function UserProfileSetNickname(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetNickname request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileSetNickname
         * @instance
         */
    UserProfileSetNickname.prototype.request = null;

    /**
         * UserProfileSetNickname nickname.
         * @member {string} nickname
         * @memberof proto.UserProfileSetNickname
         * @instance
         */
    UserProfileSetNickname.prototype.nickname = '';

    /**
         * Creates a new UserProfileSetNickname instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetNickname
         * @static
         * @param {proto.IUserProfileSetNickname=} [properties] Properties to set
         * @returns {proto.UserProfileSetNickname} UserProfileSetNickname instance
         */
    UserProfileSetNickname.create = function create(properties) {
      return new UserProfileSetNickname(properties);
    };

    /**
         * Encodes the specified UserProfileSetNickname message. Does not implicitly {@link proto.UserProfileSetNickname.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetNickname
         * @static
         * @param {proto.UserProfileSetNickname} message UserProfileSetNickname message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetNickname.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.nickname != null && message.hasOwnProperty('nickname')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetNickname message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetNickname
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetNickname} UserProfileSetNickname
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetNickname.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetNickname();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.nickname = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetNickname message.
         * @function verify
         * @memberof proto.UserProfileSetNickname
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetNickname.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.nickname != null && message.hasOwnProperty('nickname')) {
        if (!$util.isString(message.nickname)) {return 'nickname: string expected';}
      }
      return null;
    };

    return UserProfileSetNickname;
  })();

  proto.UserProfileSetNicknameResponse = (function() {

    /**
         * Properties of a UserProfileSetNicknameResponse.
         * @memberof proto
         * @interface IUserProfileSetNicknameResponse
         * @property {proto.Response|null} [response] UserProfileSetNicknameResponse response
         * @property {string|null} [nickname] UserProfileSetNicknameResponse nickname
         * @property {string|null} [initials] UserProfileSetNicknameResponse initials
         */

    /**
         * Constructs a new UserProfileSetNicknameResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileSetNicknameResponse.
         * @implements IUserProfileSetNicknameResponse
         * @constructor
         * @param {proto.IUserProfileSetNicknameResponse=} [properties] Properties to set
         */
    function UserProfileSetNicknameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetNicknameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileSetNicknameResponse
         * @instance
         */
    UserProfileSetNicknameResponse.prototype.response = null;

    /**
         * UserProfileSetNicknameResponse nickname.
         * @member {string} nickname
         * @memberof proto.UserProfileSetNicknameResponse
         * @instance
         */
    UserProfileSetNicknameResponse.prototype.nickname = '';

    /**
         * UserProfileSetNicknameResponse initials.
         * @member {string} initials
         * @memberof proto.UserProfileSetNicknameResponse
         * @instance
         */
    UserProfileSetNicknameResponse.prototype.initials = '';

    /**
         * Creates a new UserProfileSetNicknameResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetNicknameResponse
         * @static
         * @param {proto.IUserProfileSetNicknameResponse=} [properties] Properties to set
         * @returns {proto.UserProfileSetNicknameResponse} UserProfileSetNicknameResponse instance
         */
    UserProfileSetNicknameResponse.create = function create(properties) {
      return new UserProfileSetNicknameResponse(properties);
    };

    /**
         * Encodes the specified UserProfileSetNicknameResponse message. Does not implicitly {@link proto.UserProfileSetNicknameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetNicknameResponse
         * @static
         * @param {proto.UserProfileSetNicknameResponse} message UserProfileSetNicknameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetNicknameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.nickname != null && message.hasOwnProperty('nickname')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);}
      if (message.initials != null && message.hasOwnProperty('initials')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.initials);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetNicknameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetNicknameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetNicknameResponse} UserProfileSetNicknameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetNicknameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetNicknameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.nickname = reader.string();
            break;
          case 3:
            message.initials = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetNicknameResponse message.
         * @function verify
         * @memberof proto.UserProfileSetNicknameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetNicknameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.nickname != null && message.hasOwnProperty('nickname')) {
        if (!$util.isString(message.nickname)) {return 'nickname: string expected';}
      }
      if (message.initials != null && message.hasOwnProperty('initials')) {
        if (!$util.isString(message.initials)) {return 'initials: string expected';}
      }
      return null;
    };

    return UserProfileSetNicknameResponse;
  })();

  proto.UserProfileSetSelfRemove = (function() {

    /**
         * Properties of a UserProfileSetSelfRemove.
         * @memberof proto
         * @interface IUserProfileSetSelfRemove
         * @property {proto.Request|null} [request] UserProfileSetSelfRemove request
         * @property {number|null} [selfRemove] UserProfileSetSelfRemove selfRemove
         */

    /**
         * Constructs a new UserProfileSetSelfRemove.
         * @memberof proto
         * @classdesc Represents a UserProfileSetSelfRemove.
         * @implements IUserProfileSetSelfRemove
         * @constructor
         * @param {proto.IUserProfileSetSelfRemove=} [properties] Properties to set
         */
    function UserProfileSetSelfRemove(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetSelfRemove request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileSetSelfRemove
         * @instance
         */
    UserProfileSetSelfRemove.prototype.request = null;

    /**
         * UserProfileSetSelfRemove selfRemove.
         * @member {number} selfRemove
         * @memberof proto.UserProfileSetSelfRemove
         * @instance
         */
    UserProfileSetSelfRemove.prototype.selfRemove = 0;

    /**
         * Creates a new UserProfileSetSelfRemove instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetSelfRemove
         * @static
         * @param {proto.IUserProfileSetSelfRemove=} [properties] Properties to set
         * @returns {proto.UserProfileSetSelfRemove} UserProfileSetSelfRemove instance
         */
    UserProfileSetSelfRemove.create = function create(properties) {
      return new UserProfileSetSelfRemove(properties);
    };

    /**
         * Encodes the specified UserProfileSetSelfRemove message. Does not implicitly {@link proto.UserProfileSetSelfRemove.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetSelfRemove
         * @static
         * @param {proto.UserProfileSetSelfRemove} message UserProfileSetSelfRemove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetSelfRemove.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selfRemove);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetSelfRemove message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetSelfRemove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetSelfRemove} UserProfileSetSelfRemove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetSelfRemove.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetSelfRemove();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.selfRemove = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetSelfRemove message.
         * @function verify
         * @memberof proto.UserProfileSetSelfRemove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetSelfRemove.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {
        if (!$util.isInteger(message.selfRemove)) {return 'selfRemove: integer expected';}
      }
      return null;
    };

    return UserProfileSetSelfRemove;
  })();

  proto.UserProfileSetSelfRemoveResponse = (function() {

    /**
         * Properties of a UserProfileSetSelfRemoveResponse.
         * @memberof proto
         * @interface IUserProfileSetSelfRemoveResponse
         * @property {proto.Response|null} [response] UserProfileSetSelfRemoveResponse response
         * @property {number|null} [selfRemove] UserProfileSetSelfRemoveResponse selfRemove
         */

    /**
         * Constructs a new UserProfileSetSelfRemoveResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileSetSelfRemoveResponse.
         * @implements IUserProfileSetSelfRemoveResponse
         * @constructor
         * @param {proto.IUserProfileSetSelfRemoveResponse=} [properties] Properties to set
         */
    function UserProfileSetSelfRemoveResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileSetSelfRemoveResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @instance
         */
    UserProfileSetSelfRemoveResponse.prototype.response = null;

    /**
         * UserProfileSetSelfRemoveResponse selfRemove.
         * @member {number} selfRemove
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @instance
         */
    UserProfileSetSelfRemoveResponse.prototype.selfRemove = 0;

    /**
         * Creates a new UserProfileSetSelfRemoveResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @static
         * @param {proto.IUserProfileSetSelfRemoveResponse=} [properties] Properties to set
         * @returns {proto.UserProfileSetSelfRemoveResponse} UserProfileSetSelfRemoveResponse instance
         */
    UserProfileSetSelfRemoveResponse.create = function create(properties) {
      return new UserProfileSetSelfRemoveResponse(properties);
    };

    /**
         * Encodes the specified UserProfileSetSelfRemoveResponse message. Does not implicitly {@link proto.UserProfileSetSelfRemoveResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @static
         * @param {proto.UserProfileSetSelfRemoveResponse} message UserProfileSetSelfRemoveResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileSetSelfRemoveResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selfRemove);}
      return writer;
    };

    /**
         * Decodes a UserProfileSetSelfRemoveResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileSetSelfRemoveResponse} UserProfileSetSelfRemoveResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileSetSelfRemoveResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileSetSelfRemoveResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.selfRemove = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileSetSelfRemoveResponse message.
         * @function verify
         * @memberof proto.UserProfileSetSelfRemoveResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileSetSelfRemoveResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.selfRemove != null && message.hasOwnProperty('selfRemove')) {
        if (!$util.isInteger(message.selfRemove)) {return 'selfRemove: integer expected';}
      }
      return null;
    };

    return UserProfileSetSelfRemoveResponse;
  })();

  proto.UserProfileUpdateUsername = (function() {

    /**
         * Properties of a UserProfileUpdateUsername.
         * @memberof proto
         * @interface IUserProfileUpdateUsername
         * @property {proto.Request|null} [request] UserProfileUpdateUsername request
         * @property {string|null} [username] UserProfileUpdateUsername username
         */

    /**
         * Constructs a new UserProfileUpdateUsername.
         * @memberof proto
         * @classdesc Represents a UserProfileUpdateUsername.
         * @implements IUserProfileUpdateUsername
         * @constructor
         * @param {proto.IUserProfileUpdateUsername=} [properties] Properties to set
         */
    function UserProfileUpdateUsername(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileUpdateUsername request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserProfileUpdateUsername
         * @instance
         */
    UserProfileUpdateUsername.prototype.request = null;

    /**
         * UserProfileUpdateUsername username.
         * @member {string} username
         * @memberof proto.UserProfileUpdateUsername
         * @instance
         */
    UserProfileUpdateUsername.prototype.username = '';

    /**
         * Creates a new UserProfileUpdateUsername instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileUpdateUsername
         * @static
         * @param {proto.IUserProfileUpdateUsername=} [properties] Properties to set
         * @returns {proto.UserProfileUpdateUsername} UserProfileUpdateUsername instance
         */
    UserProfileUpdateUsername.create = function create(properties) {
      return new UserProfileUpdateUsername(properties);
    };

    /**
         * Encodes the specified UserProfileUpdateUsername message. Does not implicitly {@link proto.UserProfileUpdateUsername.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileUpdateUsername
         * @static
         * @param {proto.UserProfileUpdateUsername} message UserProfileUpdateUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileUpdateUsername.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a UserProfileUpdateUsername message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileUpdateUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileUpdateUsername} UserProfileUpdateUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileUpdateUsername.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileUpdateUsername();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileUpdateUsername message.
         * @function verify
         * @memberof proto.UserProfileUpdateUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileUpdateUsername.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return UserProfileUpdateUsername;
  })();

  proto.UserProfileUpdateUsernameResponse = (function() {

    /**
         * Properties of a UserProfileUpdateUsernameResponse.
         * @memberof proto
         * @interface IUserProfileUpdateUsernameResponse
         * @property {proto.Response|null} [response] UserProfileUpdateUsernameResponse response
         * @property {string|null} [username] UserProfileUpdateUsernameResponse username
         */

    /**
         * Constructs a new UserProfileUpdateUsernameResponse.
         * @memberof proto
         * @classdesc Represents a UserProfileUpdateUsernameResponse.
         * @implements IUserProfileUpdateUsernameResponse
         * @constructor
         * @param {proto.IUserProfileUpdateUsernameResponse=} [properties] Properties to set
         */
    function UserProfileUpdateUsernameResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserProfileUpdateUsernameResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @instance
         */
    UserProfileUpdateUsernameResponse.prototype.response = null;

    /**
         * UserProfileUpdateUsernameResponse username.
         * @member {string} username
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @instance
         */
    UserProfileUpdateUsernameResponse.prototype.username = '';

    /**
         * Creates a new UserProfileUpdateUsernameResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @static
         * @param {proto.IUserProfileUpdateUsernameResponse=} [properties] Properties to set
         * @returns {proto.UserProfileUpdateUsernameResponse} UserProfileUpdateUsernameResponse instance
         */
    UserProfileUpdateUsernameResponse.create = function create(properties) {
      return new UserProfileUpdateUsernameResponse(properties);
    };

    /**
         * Encodes the specified UserProfileUpdateUsernameResponse message. Does not implicitly {@link proto.UserProfileUpdateUsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @static
         * @param {proto.UserProfileUpdateUsernameResponse} message UserProfileUpdateUsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserProfileUpdateUsernameResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a UserProfileUpdateUsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserProfileUpdateUsernameResponse} UserProfileUpdateUsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserProfileUpdateUsernameResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserProfileUpdateUsernameResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserProfileUpdateUsernameResponse message.
         * @function verify
         * @memberof proto.UserProfileUpdateUsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserProfileUpdateUsernameResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return UserProfileUpdateUsernameResponse;
  })();

  proto.UserRegister = (function() {

    /**
         * Properties of a UserRegister.
         * @memberof proto
         * @interface IUserRegister
         * @property {proto.Request|null} [request] UserRegister request
         * @property {Long|null} [phoneNumber] UserRegister phoneNumber
         * @property {string|null} [countryCode] UserRegister countryCode
         */

    /**
         * Constructs a new UserRegister.
         * @memberof proto
         * @classdesc Represents a UserRegister.
         * @implements IUserRegister
         * @constructor
         * @param {proto.IUserRegister=} [properties] Properties to set
         */
    function UserRegister(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserRegister request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserRegister
         * @instance
         */
    UserRegister.prototype.request = null;

    /**
         * UserRegister phoneNumber.
         * @member {Long} phoneNumber
         * @memberof proto.UserRegister
         * @instance
         */
    UserRegister.prototype.phoneNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * UserRegister countryCode.
         * @member {string} countryCode
         * @memberof proto.UserRegister
         * @instance
         */
    UserRegister.prototype.countryCode = '';

    /**
         * Creates a new UserRegister instance using the specified properties.
         * @function create
         * @memberof proto.UserRegister
         * @static
         * @param {proto.IUserRegister=} [properties] Properties to set
         * @returns {proto.UserRegister} UserRegister instance
         */
    UserRegister.create = function create(properties) {
      return new UserRegister(properties);
    };

    /**
         * Encodes the specified UserRegister message. Does not implicitly {@link proto.UserRegister.verify|verify} messages.
         * @function encode
         * @memberof proto.UserRegister
         * @static
         * @param {proto.UserRegister} message UserRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserRegister.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.phoneNumber != null && message.hasOwnProperty('phoneNumber')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.phoneNumber);}
      if (message.countryCode != null && message.hasOwnProperty('countryCode')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.countryCode);}
      return writer;
    };

    /**
         * Decodes a UserRegister message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserRegister} UserRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserRegister.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserRegister();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.phoneNumber = reader.uint64();
            break;
          case 3:
            message.countryCode = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserRegister message.
         * @function verify
         * @memberof proto.UserRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserRegister.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.phoneNumber != null && message.hasOwnProperty('phoneNumber')) {
        if (!$util.isInteger(message.phoneNumber) && !(message.phoneNumber && $util.isInteger(message.phoneNumber.low) && $util.isInteger(message.phoneNumber.high))) {return 'phoneNumber: integer|Long expected';}
      }
      if (message.countryCode != null && message.hasOwnProperty('countryCode')) {
        if (!$util.isString(message.countryCode)) {return 'countryCode: string expected';}
      }
      return null;
    };

    return UserRegister;
  })();

  proto.UserRegisterResponse = (function() {

    /**
         * Properties of a UserRegisterResponse.
         * @memberof proto
         * @interface IUserRegisterResponse
         * @property {proto.Response|null} [response] UserRegisterResponse response
         * @property {string|null} [username] UserRegisterResponse username
         * @property {Long|null} [userId] UserRegisterResponse userId
         * @property {string|null} [authorHash] UserRegisterResponse authorHash
         * @property {proto.UserRegisterResponse.Method|null} [method] UserRegisterResponse method
         * @property {number|null} [resendDelay] UserRegisterResponse resendDelay
         * @property {Array.<Long>|null} [smsNumber] UserRegisterResponse smsNumber
         * @property {string|null} [verifyCodeRegex] UserRegisterResponse verifyCodeRegex
         * @property {number|null} [verifyCodeDigitCount] UserRegisterResponse verifyCodeDigitCount
         */

    /**
         * Constructs a new UserRegisterResponse.
         * @memberof proto
         * @classdesc Represents a UserRegisterResponse.
         * @implements IUserRegisterResponse
         * @constructor
         * @param {proto.IUserRegisterResponse=} [properties] Properties to set
         */
    function UserRegisterResponse(properties) {
      this.smsNumber = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserRegisterResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.response = null;

    /**
         * UserRegisterResponse username.
         * @member {string} username
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.username = '';

    /**
         * UserRegisterResponse userId.
         * @member {Long} userId
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * UserRegisterResponse authorHash.
         * @member {string} authorHash
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.authorHash = '';

    /**
         * UserRegisterResponse method.
         * @member {proto.UserRegisterResponse.Method} method
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.method = 0;

    /**
         * UserRegisterResponse resendDelay.
         * @member {number} resendDelay
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.resendDelay = 0;

    /**
         * UserRegisterResponse smsNumber.
         * @member {Array.<Long>} smsNumber
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.smsNumber = $util.emptyArray;

    /**
         * UserRegisterResponse verifyCodeRegex.
         * @member {string} verifyCodeRegex
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.verifyCodeRegex = '';

    /**
         * UserRegisterResponse verifyCodeDigitCount.
         * @member {number} verifyCodeDigitCount
         * @memberof proto.UserRegisterResponse
         * @instance
         */
    UserRegisterResponse.prototype.verifyCodeDigitCount = 0;

    /**
         * Creates a new UserRegisterResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserRegisterResponse
         * @static
         * @param {proto.IUserRegisterResponse=} [properties] Properties to set
         * @returns {proto.UserRegisterResponse} UserRegisterResponse instance
         */
    UserRegisterResponse.create = function create(properties) {
      return new UserRegisterResponse(properties);
    };

    /**
         * Encodes the specified UserRegisterResponse message. Does not implicitly {@link proto.UserRegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserRegisterResponse
         * @static
         * @param {proto.UserRegisterResponse} message UserRegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserRegisterResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.authorHash);}
      if (message.method != null && message.hasOwnProperty('method')) {writer.uint32(/* id 5, wireType 0 =*/40).int32(message.method);}
      if (message.resendDelay != null && message.hasOwnProperty('resendDelay')) {writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.resendDelay);}
      if (message.smsNumber != null && message.smsNumber.length) {
        writer.uint32(/* id 7, wireType 2 =*/58).fork();
        for (let i = 0; i < message.smsNumber.length; ++i) {writer.uint64(message.smsNumber[i]);}
        writer.ldelim();
      }
      if (message.verifyCodeRegex != null && message.hasOwnProperty('verifyCodeRegex')) {writer.uint32(/* id 8, wireType 2 =*/66).string(message.verifyCodeRegex);}
      if (message.verifyCodeDigitCount != null && message.hasOwnProperty('verifyCodeDigitCount')) {writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.verifyCodeDigitCount);}
      return writer;
    };

    /**
         * Decodes a UserRegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserRegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserRegisterResponse} UserRegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserRegisterResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserRegisterResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          case 4:
            message.authorHash = reader.string();
            break;
          case 5:
            message.method = reader.int32();
            break;
          case 6:
            message.resendDelay = reader.uint32();
            break;
          case 7:
            if (!(message.smsNumber && message.smsNumber.length)) {message.smsNumber = [];}
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {message.smsNumber.push(reader.uint64());}
            } else {message.smsNumber.push(reader.uint64());}
            break;
          case 8:
            message.verifyCodeRegex = reader.string();
            break;
          case 9:
            message.verifyCodeDigitCount = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserRegisterResponse message.
         * @function verify
         * @memberof proto.UserRegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserRegisterResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.authorHash != null && message.hasOwnProperty('authorHash')) {
        if (!$util.isString(message.authorHash)) {return 'authorHash: string expected';}
      }
      if (message.method != null && message.hasOwnProperty('method')) {
        switch (message.method) {
          default:
            return 'method: enum value expected';
          case 0:
          case 1:
          case 2:
            break;
        }
      }
      if (message.resendDelay != null && message.hasOwnProperty('resendDelay')) {
        if (!$util.isInteger(message.resendDelay)) {return 'resendDelay: integer expected';}
      }
      if (message.smsNumber != null && message.hasOwnProperty('smsNumber')) {
        if (!Array.isArray(message.smsNumber)) {return 'smsNumber: array expected';}
        for (let i = 0; i < message.smsNumber.length; ++i) {
          if (!$util.isInteger(message.smsNumber[i]) && !(message.smsNumber[i] && $util.isInteger(message.smsNumber[i].low) && $util.isInteger(message.smsNumber[i].high))) {return 'smsNumber: integer|Long[] expected';}
        }
      }
      if (message.verifyCodeRegex != null && message.hasOwnProperty('verifyCodeRegex')) {
        if (!$util.isString(message.verifyCodeRegex)) {return 'verifyCodeRegex: string expected';}
      }
      if (message.verifyCodeDigitCount != null && message.hasOwnProperty('verifyCodeDigitCount')) {
        if (!$util.isInteger(message.verifyCodeDigitCount)) {return 'verifyCodeDigitCount: integer expected';}
      }
      return null;
    };

    /**
         * Method enum.
         * @name proto.UserRegisterResponse.Method
         * @enum {string}
         * @property {number} VERIFY_CODE_SMS=0 VERIFY_CODE_SMS value
         * @property {number} VERIFY_CODE_SOCKET=1 VERIFY_CODE_SOCKET value
         * @property {number} VERIFY_CODE_SMS_SOCKET=2 VERIFY_CODE_SMS_SOCKET value
         */
    UserRegisterResponse.Method = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'VERIFY_CODE_SMS'] = 0;
      values[valuesById[1] = 'VERIFY_CODE_SOCKET'] = 1;
      values[valuesById[2] = 'VERIFY_CODE_SMS_SOCKET'] = 2;
      return values;
    })();

    return UserRegisterResponse;
  })();

  proto.UserReport = (function() {

    /**
         * Properties of a UserReport.
         * @memberof proto
         * @interface IUserReport
         * @property {proto.Request|null} [request] UserReport request
         * @property {Long|null} [userId] UserReport userId
         * @property {proto.UserReport.Reason|null} [reason] UserReport reason
         * @property {string|null} [description] UserReport description
         */

    /**
         * Constructs a new UserReport.
         * @memberof proto
         * @classdesc Represents a UserReport.
         * @implements IUserReport
         * @constructor
         * @param {proto.IUserReport=} [properties] Properties to set
         */
    function UserReport(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserReport request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserReport
         * @instance
         */
    UserReport.prototype.request = null;

    /**
         * UserReport userId.
         * @member {Long} userId
         * @memberof proto.UserReport
         * @instance
         */
    UserReport.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * UserReport reason.
         * @member {proto.UserReport.Reason} reason
         * @memberof proto.UserReport
         * @instance
         */
    UserReport.prototype.reason = 0;

    /**
         * UserReport description.
         * @member {string} description
         * @memberof proto.UserReport
         * @instance
         */
    UserReport.prototype.description = '';

    /**
         * Creates a new UserReport instance using the specified properties.
         * @function create
         * @memberof proto.UserReport
         * @static
         * @param {proto.IUserReport=} [properties] Properties to set
         * @returns {proto.UserReport} UserReport instance
         */
    UserReport.create = function create(properties) {
      return new UserReport(properties);
    };

    /**
         * Encodes the specified UserReport message. Does not implicitly {@link proto.UserReport.verify|verify} messages.
         * @function encode
         * @memberof proto.UserReport
         * @static
         * @param {proto.UserReport} message UserReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserReport.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.userId);}
      if (message.reason != null && message.hasOwnProperty('reason')) {writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reason);}
      if (message.description != null && message.hasOwnProperty('description')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);}
      return writer;
    };

    /**
         * Decodes a UserReport message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserReport} UserReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserReport.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserReport();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.userId = reader.uint64();
            break;
          case 3:
            message.reason = reader.int32();
            break;
          case 4:
            message.description = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserReport message.
         * @function verify
         * @memberof proto.UserReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserReport.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      if (message.reason != null && message.hasOwnProperty('reason')) {
        switch (message.reason) {
          default:
            return 'reason: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.description != null && message.hasOwnProperty('description')) {
        if (!$util.isString(message.description)) {return 'description: string expected';}
      }
      return null;
    };

    /**
         * Reason enum.
         * @name proto.UserReport.Reason
         * @enum {string}
         * @property {number} OTHER=0 OTHER value
         * @property {number} SPAM=1 SPAM value
         * @property {number} ABUSE=2 ABUSE value
         * @property {number} FAKE_ACCOUNT=3 FAKE_ACCOUNT value
         */
    UserReport.Reason = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'OTHER'] = 0;
      values[valuesById[1] = 'SPAM'] = 1;
      values[valuesById[2] = 'ABUSE'] = 2;
      values[valuesById[3] = 'FAKE_ACCOUNT'] = 3;
      return values;
    })();

    return UserReport;
  })();

  proto.UserReportResponse = (function() {

    /**
         * Properties of a UserReportResponse.
         * @memberof proto
         * @interface IUserReportResponse
         * @property {proto.Response|null} [response] UserReportResponse response
         */

    /**
         * Constructs a new UserReportResponse.
         * @memberof proto
         * @classdesc Represents a UserReportResponse.
         * @implements IUserReportResponse
         * @constructor
         * @param {proto.IUserReportResponse=} [properties] Properties to set
         */
    function UserReportResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserReportResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserReportResponse
         * @instance
         */
    UserReportResponse.prototype.response = null;

    /**
         * Creates a new UserReportResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserReportResponse
         * @static
         * @param {proto.IUserReportResponse=} [properties] Properties to set
         * @returns {proto.UserReportResponse} UserReportResponse instance
         */
    UserReportResponse.create = function create(properties) {
      return new UserReportResponse(properties);
    };

    /**
         * Encodes the specified UserReportResponse message. Does not implicitly {@link proto.UserReportResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserReportResponse
         * @static
         * @param {proto.UserReportResponse} message UserReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserReportResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserReportResponse} UserReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserReportResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserReportResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserReportResponse message.
         * @function verify
         * @memberof proto.UserReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserReportResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserReportResponse;
  })();

  proto.UserSessionGetActiveList = (function() {

    /**
         * Properties of a UserSessionGetActiveList.
         * @memberof proto
         * @interface IUserSessionGetActiveList
         * @property {proto.Request|null} [request] UserSessionGetActiveList request
         */

    /**
         * Constructs a new UserSessionGetActiveList.
         * @memberof proto
         * @classdesc Represents a UserSessionGetActiveList.
         * @implements IUserSessionGetActiveList
         * @constructor
         * @param {proto.IUserSessionGetActiveList=} [properties] Properties to set
         */
    function UserSessionGetActiveList(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionGetActiveList request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserSessionGetActiveList
         * @instance
         */
    UserSessionGetActiveList.prototype.request = null;

    /**
         * Creates a new UserSessionGetActiveList instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionGetActiveList
         * @static
         * @param {proto.IUserSessionGetActiveList=} [properties] Properties to set
         * @returns {proto.UserSessionGetActiveList} UserSessionGetActiveList instance
         */
    UserSessionGetActiveList.create = function create(properties) {
      return new UserSessionGetActiveList(properties);
    };

    /**
         * Encodes the specified UserSessionGetActiveList message. Does not implicitly {@link proto.UserSessionGetActiveList.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionGetActiveList
         * @static
         * @param {proto.UserSessionGetActiveList} message UserSessionGetActiveList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionGetActiveList.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserSessionGetActiveList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionGetActiveList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionGetActiveList} UserSessionGetActiveList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionGetActiveList.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionGetActiveList();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionGetActiveList message.
         * @function verify
         * @memberof proto.UserSessionGetActiveList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionGetActiveList.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserSessionGetActiveList;
  })();

  proto.UserSessionGetActiveListResponse = (function() {

    /**
         * Properties of a UserSessionGetActiveListResponse.
         * @memberof proto
         * @interface IUserSessionGetActiveListResponse
         * @property {proto.Response|null} [response] UserSessionGetActiveListResponse response
         * @property {Array.<proto.UserSessionGetActiveListResponse.Session>|null} [session] UserSessionGetActiveListResponse session
         */

    /**
         * Constructs a new UserSessionGetActiveListResponse.
         * @memberof proto
         * @classdesc Represents a UserSessionGetActiveListResponse.
         * @implements IUserSessionGetActiveListResponse
         * @constructor
         * @param {proto.IUserSessionGetActiveListResponse=} [properties] Properties to set
         */
    function UserSessionGetActiveListResponse(properties) {
      this.session = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionGetActiveListResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserSessionGetActiveListResponse
         * @instance
         */
    UserSessionGetActiveListResponse.prototype.response = null;

    /**
         * UserSessionGetActiveListResponse session.
         * @member {Array.<proto.UserSessionGetActiveListResponse.Session>} session
         * @memberof proto.UserSessionGetActiveListResponse
         * @instance
         */
    UserSessionGetActiveListResponse.prototype.session = $util.emptyArray;

    /**
         * Creates a new UserSessionGetActiveListResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionGetActiveListResponse
         * @static
         * @param {proto.IUserSessionGetActiveListResponse=} [properties] Properties to set
         * @returns {proto.UserSessionGetActiveListResponse} UserSessionGetActiveListResponse instance
         */
    UserSessionGetActiveListResponse.create = function create(properties) {
      return new UserSessionGetActiveListResponse(properties);
    };

    /**
         * Encodes the specified UserSessionGetActiveListResponse message. Does not implicitly {@link proto.UserSessionGetActiveListResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionGetActiveListResponse
         * @static
         * @param {proto.UserSessionGetActiveListResponse} message UserSessionGetActiveListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionGetActiveListResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.session != null && message.session.length) {
        for (let i = 0; i < message.session.length; ++i) {$root.proto.UserSessionGetActiveListResponse.Session.encode(message.session[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();}
      }
      return writer;
    };

    /**
         * Decodes a UserSessionGetActiveListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionGetActiveListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionGetActiveListResponse} UserSessionGetActiveListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionGetActiveListResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionGetActiveListResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            if (!(message.session && message.session.length)) {message.session = [];}
            message.session.push($root.proto.UserSessionGetActiveListResponse.Session.decode(reader, reader.uint32()));
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionGetActiveListResponse message.
         * @function verify
         * @memberof proto.UserSessionGetActiveListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionGetActiveListResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.session != null && message.hasOwnProperty('session')) {
        if (!Array.isArray(message.session)) {return 'session: array expected';}
        for (let i = 0; i < message.session.length; ++i) {
          let error = $root.proto.UserSessionGetActiveListResponse.Session.verify(message.session[i]);
          if (error) {return 'session.' + error;}
        }
      }
      return null;
    };

    UserSessionGetActiveListResponse.Session = (function() {

      /**
             * Properties of a Session.
             * @memberof proto.UserSessionGetActiveListResponse
             * @interface ISession
             * @property {Long|null} [sessionId] Session sessionId
             * @property {string|null} [appName] Session appName
             * @property {number|null} [appId] Session appId
             * @property {number|null} [appBuildVersion] Session appBuildVersion
             * @property {string|null} [appVersion] Session appVersion
             * @property {proto.Platform|null} [platform] Session platform
             * @property {string|null} [platformVersion] Session platformVersion
             * @property {proto.Device|null} [device] Session device
             * @property {string|null} [deviceName] Session deviceName
             * @property {proto.Language|null} [language] Session language
             * @property {string|null} [country] Session country
             * @property {boolean|null} [current] Session current
             * @property {number|null} [createTime] Session createTime
             * @property {number|null} [activeTime] Session activeTime
             * @property {string|null} [ip] Session ip
             */

      /**
             * Constructs a new Session.
             * @memberof proto.UserSessionGetActiveListResponse
             * @classdesc Represents a Session.
             * @implements ISession
             * @constructor
             * @param {proto.UserSessionGetActiveListResponse.ISession=} [properties] Properties to set
             */
      function Session(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
          }
        }
      }

      /**
             * Session sessionId.
             * @member {Long} sessionId
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.sessionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
             * Session appName.
             * @member {string} appName
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.appName = '';

      /**
             * Session appId.
             * @member {number} appId
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.appId = 0;

      /**
             * Session appBuildVersion.
             * @member {number} appBuildVersion
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.appBuildVersion = 0;

      /**
             * Session appVersion.
             * @member {string} appVersion
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.appVersion = '';

      /**
             * Session platform.
             * @member {proto.Platform} platform
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.platform = 0;

      /**
             * Session platformVersion.
             * @member {string} platformVersion
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.platformVersion = '';

      /**
             * Session device.
             * @member {proto.Device} device
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.device = 0;

      /**
             * Session deviceName.
             * @member {string} deviceName
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.deviceName = '';

      /**
             * Session language.
             * @member {proto.Language} language
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.language = 0;

      /**
             * Session country.
             * @member {string} country
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.country = '';

      /**
             * Session current.
             * @member {boolean} current
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.current = false;

      /**
             * Session createTime.
             * @member {number} createTime
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.createTime = 0;

      /**
             * Session activeTime.
             * @member {number} activeTime
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.activeTime = 0;

      /**
             * Session ip.
             * @member {string} ip
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @instance
             */
      Session.prototype.ip = '';

      /**
             * Creates a new Session instance using the specified properties.
             * @function create
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @static
             * @param {proto.UserSessionGetActiveListResponse.ISession=} [properties] Properties to set
             * @returns {proto.UserSessionGetActiveListResponse.Session} Session instance
             */
      Session.create = function create(properties) {
        return new Session(properties);
      };

      /**
             * Encodes the specified Session message. Does not implicitly {@link proto.UserSessionGetActiveListResponse.Session.verify|verify} messages.
             * @function encode
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @static
             * @param {proto.UserSessionGetActiveListResponse.Session} message Session message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
      Session.encode = function encode(message, writer) {
        if (!writer) {writer = $Writer.create();}
        if (message.sessionId != null && message.hasOwnProperty('sessionId')) {writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sessionId);}
        if (message.appName != null && message.hasOwnProperty('appName')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.appName);}
        if (message.appId != null && message.hasOwnProperty('appId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.appId);}
        if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.appBuildVersion);}
        if (message.appVersion != null && message.hasOwnProperty('appVersion')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.appVersion);}
        if (message.platform != null && message.hasOwnProperty('platform')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.platform);}
        if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.platformVersion);}
        if (message.device != null && message.hasOwnProperty('device')) {writer.uint32(/* id 8, wireType 0 =*/64).int32(message.device);}
        if (message.deviceName != null && message.hasOwnProperty('deviceName')) {writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceName);}
        if (message.language != null && message.hasOwnProperty('language')) {writer.uint32(/* id 10, wireType 0 =*/80).int32(message.language);}
        if (message.country != null && message.hasOwnProperty('country')) {writer.uint32(/* id 11, wireType 2 =*/90).string(message.country);}
        if (message.current != null && message.hasOwnProperty('current')) {writer.uint32(/* id 12, wireType 0 =*/96).bool(message.current);}
        if (message.createTime != null && message.hasOwnProperty('createTime')) {writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.createTime);}
        if (message.activeTime != null && message.hasOwnProperty('activeTime')) {writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.activeTime);}
        if (message.ip != null && message.hasOwnProperty('ip')) {writer.uint32(/* id 15, wireType 2 =*/122).string(message.ip);}
        return writer;
      };

      /**
             * Decodes a Session message from the specified reader or buffer.
             * @function decode
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.UserSessionGetActiveListResponse.Session} Session
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
      Session.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionGetActiveListResponse.Session();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sessionId = reader.uint64();
              break;
            case 2:
              message.appName = reader.string();
              break;
            case 3:
              message.appId = reader.uint32();
              break;
            case 4:
              message.appBuildVersion = reader.uint32();
              break;
            case 5:
              message.appVersion = reader.string();
              break;
            case 6:
              message.platform = reader.int32();
              break;
            case 7:
              message.platformVersion = reader.string();
              break;
            case 8:
              message.device = reader.int32();
              break;
            case 9:
              message.deviceName = reader.string();
              break;
            case 10:
              message.language = reader.int32();
              break;
            case 11:
              message.country = reader.string();
              break;
            case 12:
              message.current = reader.bool();
              break;
            case 13:
              message.createTime = reader.uint32();
              break;
            case 14:
              message.activeTime = reader.uint32();
              break;
            case 15:
              message.ip = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
             * Verifies a Session message.
             * @function verify
             * @memberof proto.UserSessionGetActiveListResponse.Session
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
      Session.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) {return 'object expected';}
        if (message.sessionId != null && message.hasOwnProperty('sessionId')) {
          if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high))) {return 'sessionId: integer|Long expected';}
        }
        if (message.appName != null && message.hasOwnProperty('appName')) {
          if (!$util.isString(message.appName)) {return 'appName: string expected';}
        }
        if (message.appId != null && message.hasOwnProperty('appId')) {
          if (!$util.isInteger(message.appId)) {return 'appId: integer expected';}
        }
        if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {
          if (!$util.isInteger(message.appBuildVersion)) {return 'appBuildVersion: integer expected';}
        }
        if (message.appVersion != null && message.hasOwnProperty('appVersion')) {
          if (!$util.isString(message.appVersion)) {return 'appVersion: string expected';}
        }
        if (message.platform != null && message.hasOwnProperty('platform')) {
          switch (message.platform) {
            default:
              return 'platform: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
              break;
          }
        }
        if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {
          if (!$util.isString(message.platformVersion)) {return 'platformVersion: string expected';}
        }
        if (message.device != null && message.hasOwnProperty('device')) {
          switch (message.device) {
            default:
              return 'device: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        }
        if (message.deviceName != null && message.hasOwnProperty('deviceName')) {
          if (!$util.isString(message.deviceName)) {return 'deviceName: string expected';}
        }
        if (message.language != null && message.hasOwnProperty('language')) {
          switch (message.language) {
            default:
              return 'language: enum value expected';
            case 0:
            case 1:
              break;
          }
        }
        if (message.country != null && message.hasOwnProperty('country')) {
          if (!$util.isString(message.country)) {return 'country: string expected';}
        }
        if (message.current != null && message.hasOwnProperty('current')) {
          if (typeof message.current !== 'boolean') {return 'current: boolean expected';}
        }
        if (message.createTime != null && message.hasOwnProperty('createTime')) {
          if (!$util.isInteger(message.createTime)) {return 'createTime: integer expected';}
        }
        if (message.activeTime != null && message.hasOwnProperty('activeTime')) {
          if (!$util.isInteger(message.activeTime)) {return 'activeTime: integer expected';}
        }
        if (message.ip != null && message.hasOwnProperty('ip')) {
          if (!$util.isString(message.ip)) {return 'ip: string expected';}
        }
        return null;
      };

      return Session;
    })();

    return UserSessionGetActiveListResponse;
  })();

  proto.UserSessionLogout = (function() {

    /**
         * Properties of a UserSessionLogout.
         * @memberof proto
         * @interface IUserSessionLogout
         * @property {proto.Request|null} [request] UserSessionLogout request
         */

    /**
         * Constructs a new UserSessionLogout.
         * @memberof proto
         * @classdesc Represents a UserSessionLogout.
         * @implements IUserSessionLogout
         * @constructor
         * @param {proto.IUserSessionLogout=} [properties] Properties to set
         */
    function UserSessionLogout(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionLogout request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserSessionLogout
         * @instance
         */
    UserSessionLogout.prototype.request = null;

    /**
         * Creates a new UserSessionLogout instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionLogout
         * @static
         * @param {proto.IUserSessionLogout=} [properties] Properties to set
         * @returns {proto.UserSessionLogout} UserSessionLogout instance
         */
    UserSessionLogout.create = function create(properties) {
      return new UserSessionLogout(properties);
    };

    /**
         * Encodes the specified UserSessionLogout message. Does not implicitly {@link proto.UserSessionLogout.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionLogout
         * @static
         * @param {proto.UserSessionLogout} message UserSessionLogout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionLogout.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserSessionLogout message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionLogout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionLogout} UserSessionLogout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionLogout.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionLogout();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionLogout message.
         * @function verify
         * @memberof proto.UserSessionLogout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionLogout.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserSessionLogout;
  })();

  proto.UserSessionLogoutResponse = (function() {

    /**
         * Properties of a UserSessionLogoutResponse.
         * @memberof proto
         * @interface IUserSessionLogoutResponse
         * @property {proto.Response|null} [response] UserSessionLogoutResponse response
         */

    /**
         * Constructs a new UserSessionLogoutResponse.
         * @memberof proto
         * @classdesc Represents a UserSessionLogoutResponse.
         * @implements IUserSessionLogoutResponse
         * @constructor
         * @param {proto.IUserSessionLogoutResponse=} [properties] Properties to set
         */
    function UserSessionLogoutResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionLogoutResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserSessionLogoutResponse
         * @instance
         */
    UserSessionLogoutResponse.prototype.response = null;

    /**
         * Creates a new UserSessionLogoutResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionLogoutResponse
         * @static
         * @param {proto.IUserSessionLogoutResponse=} [properties] Properties to set
         * @returns {proto.UserSessionLogoutResponse} UserSessionLogoutResponse instance
         */
    UserSessionLogoutResponse.create = function create(properties) {
      return new UserSessionLogoutResponse(properties);
    };

    /**
         * Encodes the specified UserSessionLogoutResponse message. Does not implicitly {@link proto.UserSessionLogoutResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionLogoutResponse
         * @static
         * @param {proto.UserSessionLogoutResponse} message UserSessionLogoutResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionLogoutResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserSessionLogoutResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionLogoutResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionLogoutResponse} UserSessionLogoutResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionLogoutResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionLogoutResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionLogoutResponse message.
         * @function verify
         * @memberof proto.UserSessionLogoutResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionLogoutResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserSessionLogoutResponse;
  })();

  proto.UserSessionTerminate = (function() {

    /**
         * Properties of a UserSessionTerminate.
         * @memberof proto
         * @interface IUserSessionTerminate
         * @property {proto.Request|null} [request] UserSessionTerminate request
         * @property {Long|null} [sessionId] UserSessionTerminate sessionId
         */

    /**
         * Constructs a new UserSessionTerminate.
         * @memberof proto
         * @classdesc Represents a UserSessionTerminate.
         * @implements IUserSessionTerminate
         * @constructor
         * @param {proto.IUserSessionTerminate=} [properties] Properties to set
         */
    function UserSessionTerminate(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionTerminate request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserSessionTerminate
         * @instance
         */
    UserSessionTerminate.prototype.request = null;

    /**
         * UserSessionTerminate sessionId.
         * @member {Long} sessionId
         * @memberof proto.UserSessionTerminate
         * @instance
         */
    UserSessionTerminate.prototype.sessionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserSessionTerminate instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionTerminate
         * @static
         * @param {proto.IUserSessionTerminate=} [properties] Properties to set
         * @returns {proto.UserSessionTerminate} UserSessionTerminate instance
         */
    UserSessionTerminate.create = function create(properties) {
      return new UserSessionTerminate(properties);
    };

    /**
         * Encodes the specified UserSessionTerminate message. Does not implicitly {@link proto.UserSessionTerminate.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionTerminate
         * @static
         * @param {proto.UserSessionTerminate} message UserSessionTerminate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionTerminate.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.sessionId != null && message.hasOwnProperty('sessionId')) {writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sessionId);}
      return writer;
    };

    /**
         * Decodes a UserSessionTerminate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionTerminate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionTerminate} UserSessionTerminate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionTerminate.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionTerminate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.sessionId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionTerminate message.
         * @function verify
         * @memberof proto.UserSessionTerminate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionTerminate.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.sessionId != null && message.hasOwnProperty('sessionId')) {
        if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high))) {return 'sessionId: integer|Long expected';}
      }
      return null;
    };

    return UserSessionTerminate;
  })();

  proto.UserSessionTerminateResponse = (function() {

    /**
         * Properties of a UserSessionTerminateResponse.
         * @memberof proto
         * @interface IUserSessionTerminateResponse
         * @property {proto.Response|null} [response] UserSessionTerminateResponse response
         */

    /**
         * Constructs a new UserSessionTerminateResponse.
         * @memberof proto
         * @classdesc Represents a UserSessionTerminateResponse.
         * @implements IUserSessionTerminateResponse
         * @constructor
         * @param {proto.IUserSessionTerminateResponse=} [properties] Properties to set
         */
    function UserSessionTerminateResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserSessionTerminateResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserSessionTerminateResponse
         * @instance
         */
    UserSessionTerminateResponse.prototype.response = null;

    /**
         * Creates a new UserSessionTerminateResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserSessionTerminateResponse
         * @static
         * @param {proto.IUserSessionTerminateResponse=} [properties] Properties to set
         * @returns {proto.UserSessionTerminateResponse} UserSessionTerminateResponse instance
         */
    UserSessionTerminateResponse.create = function create(properties) {
      return new UserSessionTerminateResponse(properties);
    };

    /**
         * Encodes the specified UserSessionTerminateResponse message. Does not implicitly {@link proto.UserSessionTerminateResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserSessionTerminateResponse
         * @static
         * @param {proto.UserSessionTerminateResponse} message UserSessionTerminateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserSessionTerminateResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserSessionTerminateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserSessionTerminateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserSessionTerminateResponse} UserSessionTerminateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserSessionTerminateResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserSessionTerminateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserSessionTerminateResponse message.
         * @function verify
         * @memberof proto.UserSessionTerminateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserSessionTerminateResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserSessionTerminateResponse;
  })();

  proto.UserTwoStepVerificationChangeHint = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeHint.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeHint
         * @property {proto.Request|null} [request] UserTwoStepVerificationChangeHint request
         * @property {string|null} [password] UserTwoStepVerificationChangeHint password
         * @property {string|null} [hint] UserTwoStepVerificationChangeHint hint
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeHint.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeHint.
         * @implements IUserTwoStepVerificationChangeHint
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeHint=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeHint(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeHint request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @instance
         */
    UserTwoStepVerificationChangeHint.prototype.request = null;

    /**
         * UserTwoStepVerificationChangeHint password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @instance
         */
    UserTwoStepVerificationChangeHint.prototype.password = '';

    /**
         * UserTwoStepVerificationChangeHint hint.
         * @member {string} hint
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @instance
         */
    UserTwoStepVerificationChangeHint.prototype.hint = '';

    /**
         * Creates a new UserTwoStepVerificationChangeHint instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @static
         * @param {proto.IUserTwoStepVerificationChangeHint=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeHint} UserTwoStepVerificationChangeHint instance
         */
    UserTwoStepVerificationChangeHint.create = function create(properties) {
      return new UserTwoStepVerificationChangeHint(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeHint message. Does not implicitly {@link proto.UserTwoStepVerificationChangeHint.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @static
         * @param {proto.UserTwoStepVerificationChangeHint} message UserTwoStepVerificationChangeHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeHint.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      if (message.hint != null && message.hasOwnProperty('hint')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.hint);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeHint message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeHint} UserTwoStepVerificationChangeHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeHint.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeHint();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          case 3:
            message.hint = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeHint message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeHint.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      if (message.hint != null && message.hasOwnProperty('hint')) {
        if (!$util.isString(message.hint)) {return 'hint: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationChangeHint;
  })();

  proto.UserTwoStepVerificationChangeHintResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeHintResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeHintResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationChangeHintResponse response
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeHintResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeHintResponse.
         * @implements IUserTwoStepVerificationChangeHintResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeHintResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeHintResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeHintResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationChangeHintResponse
         * @instance
         */
    UserTwoStepVerificationChangeHintResponse.prototype.response = null;

    /**
         * Creates a new UserTwoStepVerificationChangeHintResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeHintResponse
         * @static
         * @param {proto.IUserTwoStepVerificationChangeHintResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeHintResponse} UserTwoStepVerificationChangeHintResponse instance
         */
    UserTwoStepVerificationChangeHintResponse.create = function create(properties) {
      return new UserTwoStepVerificationChangeHintResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeHintResponse message. Does not implicitly {@link proto.UserTwoStepVerificationChangeHintResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeHintResponse
         * @static
         * @param {proto.UserTwoStepVerificationChangeHintResponse} message UserTwoStepVerificationChangeHintResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeHintResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeHintResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeHintResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeHintResponse} UserTwoStepVerificationChangeHintResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeHintResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeHintResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeHintResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeHintResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeHintResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationChangeHintResponse;
  })();

  proto.UserTwoStepVerificationChangeRecoveryEmail = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeRecoveryEmail.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeRecoveryEmail
         * @property {proto.Request|null} [request] UserTwoStepVerificationChangeRecoveryEmail request
         * @property {string|null} [password] UserTwoStepVerificationChangeRecoveryEmail password
         * @property {string|null} [email] UserTwoStepVerificationChangeRecoveryEmail email
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeRecoveryEmail.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeRecoveryEmail.
         * @implements IUserTwoStepVerificationChangeRecoveryEmail
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeRecoveryEmail=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeRecoveryEmail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeRecoveryEmail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryEmail.prototype.request = null;

    /**
         * UserTwoStepVerificationChangeRecoveryEmail password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryEmail.prototype.password = '';

    /**
         * UserTwoStepVerificationChangeRecoveryEmail email.
         * @member {string} email
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryEmail.prototype.email = '';

    /**
         * Creates a new UserTwoStepVerificationChangeRecoveryEmail instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @static
         * @param {proto.IUserTwoStepVerificationChangeRecoveryEmail=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeRecoveryEmail} UserTwoStepVerificationChangeRecoveryEmail instance
         */
    UserTwoStepVerificationChangeRecoveryEmail.create = function create(properties) {
      return new UserTwoStepVerificationChangeRecoveryEmail(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeRecoveryEmail message. Does not implicitly {@link proto.UserTwoStepVerificationChangeRecoveryEmail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @static
         * @param {proto.UserTwoStepVerificationChangeRecoveryEmail} message UserTwoStepVerificationChangeRecoveryEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeRecoveryEmail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      if (message.email != null && message.hasOwnProperty('email')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeRecoveryEmail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeRecoveryEmail} UserTwoStepVerificationChangeRecoveryEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeRecoveryEmail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeRecoveryEmail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          case 3:
            message.email = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeRecoveryEmail message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeRecoveryEmail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      if (message.email != null && message.hasOwnProperty('email')) {
        if (!$util.isString(message.email)) {return 'email: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationChangeRecoveryEmail;
  })();

  proto.UserTwoStepVerificationChangeRecoveryEmailResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeRecoveryEmailResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeRecoveryEmailResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationChangeRecoveryEmailResponse response
         * @property {string|null} [unconfirmedEmailPattern] UserTwoStepVerificationChangeRecoveryEmailResponse unconfirmedEmailPattern
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeRecoveryEmailResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeRecoveryEmailResponse.
         * @implements IUserTwoStepVerificationChangeRecoveryEmailResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeRecoveryEmailResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeRecoveryEmailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeRecoveryEmailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationChangeRecoveryEmailResponse unconfirmedEmailPattern.
         * @member {string} unconfirmedEmailPattern
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.prototype.unconfirmedEmailPattern = '';

    /**
         * Creates a new UserTwoStepVerificationChangeRecoveryEmailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @static
         * @param {proto.IUserTwoStepVerificationChangeRecoveryEmailResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeRecoveryEmailResponse} UserTwoStepVerificationChangeRecoveryEmailResponse instance
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.create = function create(properties) {
      return new UserTwoStepVerificationChangeRecoveryEmailResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeRecoveryEmailResponse message. Does not implicitly {@link proto.UserTwoStepVerificationChangeRecoveryEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @static
         * @param {proto.UserTwoStepVerificationChangeRecoveryEmailResponse} message UserTwoStepVerificationChangeRecoveryEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.unconfirmedEmailPattern);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeRecoveryEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeRecoveryEmailResponse} UserTwoStepVerificationChangeRecoveryEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeRecoveryEmailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.unconfirmedEmailPattern = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeRecoveryEmailResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeRecoveryEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeRecoveryEmailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {
        if (!$util.isString(message.unconfirmedEmailPattern)) {return 'unconfirmedEmailPattern: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationChangeRecoveryEmailResponse;
  })();

  proto.UserTwoStepVerificationChangeRecoveryQuestion = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeRecoveryQuestion.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeRecoveryQuestion
         * @property {proto.Request|null} [request] UserTwoStepVerificationChangeRecoveryQuestion request
         * @property {string|null} [password] UserTwoStepVerificationChangeRecoveryQuestion password
         * @property {string|null} [questionOne] UserTwoStepVerificationChangeRecoveryQuestion questionOne
         * @property {string|null} [answerOne] UserTwoStepVerificationChangeRecoveryQuestion answerOne
         * @property {string|null} [questionTwo] UserTwoStepVerificationChangeRecoveryQuestion questionTwo
         * @property {string|null} [answerTwo] UserTwoStepVerificationChangeRecoveryQuestion answerTwo
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeRecoveryQuestion.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeRecoveryQuestion.
         * @implements IUserTwoStepVerificationChangeRecoveryQuestion
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeRecoveryQuestion=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeRecoveryQuestion(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.request = null;

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.password = '';

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion questionOne.
         * @member {string} questionOne
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.questionOne = '';

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion answerOne.
         * @member {string} answerOne
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.answerOne = '';

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion questionTwo.
         * @member {string} questionTwo
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.questionTwo = '';

    /**
         * UserTwoStepVerificationChangeRecoveryQuestion answerTwo.
         * @member {string} answerTwo
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.prototype.answerTwo = '';

    /**
         * Creates a new UserTwoStepVerificationChangeRecoveryQuestion instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @static
         * @param {proto.IUserTwoStepVerificationChangeRecoveryQuestion=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeRecoveryQuestion} UserTwoStepVerificationChangeRecoveryQuestion instance
         */
    UserTwoStepVerificationChangeRecoveryQuestion.create = function create(properties) {
      return new UserTwoStepVerificationChangeRecoveryQuestion(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeRecoveryQuestion message. Does not implicitly {@link proto.UserTwoStepVerificationChangeRecoveryQuestion.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @static
         * @param {proto.UserTwoStepVerificationChangeRecoveryQuestion} message UserTwoStepVerificationChangeRecoveryQuestion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeRecoveryQuestion.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.questionOne);}
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.answerOne);}
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.questionTwo);}
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.answerTwo);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeRecoveryQuestion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeRecoveryQuestion} UserTwoStepVerificationChangeRecoveryQuestion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeRecoveryQuestion.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeRecoveryQuestion();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          case 3:
            message.questionOne = reader.string();
            break;
          case 4:
            message.answerOne = reader.string();
            break;
          case 5:
            message.questionTwo = reader.string();
            break;
          case 6:
            message.answerTwo = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeRecoveryQuestion message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeRecoveryQuestion.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {
        if (!$util.isString(message.questionOne)) {return 'questionOne: string expected';}
      }
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {
        if (!$util.isString(message.answerOne)) {return 'answerOne: string expected';}
      }
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {
        if (!$util.isString(message.questionTwo)) {return 'questionTwo: string expected';}
      }
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {
        if (!$util.isString(message.answerTwo)) {return 'answerTwo: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationChangeRecoveryQuestion;
  })();

  proto.UserTwoStepVerificationChangeRecoveryQuestionResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationChangeRecoveryQuestionResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationChangeRecoveryQuestionResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationChangeRecoveryQuestionResponse response
         */

    /**
         * Constructs a new UserTwoStepVerificationChangeRecoveryQuestionResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationChangeRecoveryQuestionResponse.
         * @implements IUserTwoStepVerificationChangeRecoveryQuestionResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationChangeRecoveryQuestionResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationChangeRecoveryQuestionResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationChangeRecoveryQuestionResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @instance
         */
    UserTwoStepVerificationChangeRecoveryQuestionResponse.prototype.response = null;

    /**
         * Creates a new UserTwoStepVerificationChangeRecoveryQuestionResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @static
         * @param {proto.IUserTwoStepVerificationChangeRecoveryQuestionResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationChangeRecoveryQuestionResponse} UserTwoStepVerificationChangeRecoveryQuestionResponse instance
         */
    UserTwoStepVerificationChangeRecoveryQuestionResponse.create = function create(properties) {
      return new UserTwoStepVerificationChangeRecoveryQuestionResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationChangeRecoveryQuestionResponse message. Does not implicitly {@link proto.UserTwoStepVerificationChangeRecoveryQuestionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @static
         * @param {proto.UserTwoStepVerificationChangeRecoveryQuestionResponse} message UserTwoStepVerificationChangeRecoveryQuestionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationChangeRecoveryQuestionResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationChangeRecoveryQuestionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationChangeRecoveryQuestionResponse} UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationChangeRecoveryQuestionResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationChangeRecoveryQuestionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationChangeRecoveryQuestionResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationChangeRecoveryQuestionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationChangeRecoveryQuestionResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationChangeRecoveryQuestionResponse;
  })();

  proto.UserTwoStepVerificationCheckPassword = (function() {

    /**
         * Properties of a UserTwoStepVerificationCheckPassword.
         * @memberof proto
         * @interface IUserTwoStepVerificationCheckPassword
         * @property {proto.Request|null} [request] UserTwoStepVerificationCheckPassword request
         * @property {string|null} [password] UserTwoStepVerificationCheckPassword password
         */

    /**
         * Constructs a new UserTwoStepVerificationCheckPassword.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationCheckPassword.
         * @implements IUserTwoStepVerificationCheckPassword
         * @constructor
         * @param {proto.IUserTwoStepVerificationCheckPassword=} [properties] Properties to set
         */
    function UserTwoStepVerificationCheckPassword(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationCheckPassword request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @instance
         */
    UserTwoStepVerificationCheckPassword.prototype.request = null;

    /**
         * UserTwoStepVerificationCheckPassword password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @instance
         */
    UserTwoStepVerificationCheckPassword.prototype.password = '';

    /**
         * Creates a new UserTwoStepVerificationCheckPassword instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @static
         * @param {proto.IUserTwoStepVerificationCheckPassword=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationCheckPassword} UserTwoStepVerificationCheckPassword instance
         */
    UserTwoStepVerificationCheckPassword.create = function create(properties) {
      return new UserTwoStepVerificationCheckPassword(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationCheckPassword message. Does not implicitly {@link proto.UserTwoStepVerificationCheckPassword.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @static
         * @param {proto.UserTwoStepVerificationCheckPassword} message UserTwoStepVerificationCheckPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationCheckPassword.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationCheckPassword message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationCheckPassword} UserTwoStepVerificationCheckPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationCheckPassword.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationCheckPassword();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationCheckPassword message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationCheckPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationCheckPassword.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationCheckPassword;
  })();

  proto.UserTwoStepVerificationCheckPasswordResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationCheckPasswordResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationCheckPasswordResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationCheckPasswordResponse response
         */

    /**
         * Constructs a new UserTwoStepVerificationCheckPasswordResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationCheckPasswordResponse.
         * @implements IUserTwoStepVerificationCheckPasswordResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationCheckPasswordResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationCheckPasswordResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationCheckPasswordResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationCheckPasswordResponse
         * @instance
         */
    UserTwoStepVerificationCheckPasswordResponse.prototype.response = null;

    /**
         * Creates a new UserTwoStepVerificationCheckPasswordResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationCheckPasswordResponse
         * @static
         * @param {proto.IUserTwoStepVerificationCheckPasswordResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationCheckPasswordResponse} UserTwoStepVerificationCheckPasswordResponse instance
         */
    UserTwoStepVerificationCheckPasswordResponse.create = function create(properties) {
      return new UserTwoStepVerificationCheckPasswordResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationCheckPasswordResponse message. Does not implicitly {@link proto.UserTwoStepVerificationCheckPasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationCheckPasswordResponse
         * @static
         * @param {proto.UserTwoStepVerificationCheckPasswordResponse} message UserTwoStepVerificationCheckPasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationCheckPasswordResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationCheckPasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationCheckPasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationCheckPasswordResponse} UserTwoStepVerificationCheckPasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationCheckPasswordResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationCheckPasswordResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationCheckPasswordResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationCheckPasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationCheckPasswordResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationCheckPasswordResponse;
  })();

  proto.UserTwoStepVerificationGetPasswordDetail = (function() {

    /**
         * Properties of a UserTwoStepVerificationGetPasswordDetail.
         * @memberof proto
         * @interface IUserTwoStepVerificationGetPasswordDetail
         * @property {proto.Request|null} [request] UserTwoStepVerificationGetPasswordDetail request
         */

    /**
         * Constructs a new UserTwoStepVerificationGetPasswordDetail.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationGetPasswordDetail.
         * @implements IUserTwoStepVerificationGetPasswordDetail
         * @constructor
         * @param {proto.IUserTwoStepVerificationGetPasswordDetail=} [properties] Properties to set
         */
    function UserTwoStepVerificationGetPasswordDetail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationGetPasswordDetail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationGetPasswordDetail
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetail.prototype.request = null;

    /**
         * Creates a new UserTwoStepVerificationGetPasswordDetail instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationGetPasswordDetail
         * @static
         * @param {proto.IUserTwoStepVerificationGetPasswordDetail=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationGetPasswordDetail} UserTwoStepVerificationGetPasswordDetail instance
         */
    UserTwoStepVerificationGetPasswordDetail.create = function create(properties) {
      return new UserTwoStepVerificationGetPasswordDetail(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationGetPasswordDetail message. Does not implicitly {@link proto.UserTwoStepVerificationGetPasswordDetail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationGetPasswordDetail
         * @static
         * @param {proto.UserTwoStepVerificationGetPasswordDetail} message UserTwoStepVerificationGetPasswordDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationGetPasswordDetail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationGetPasswordDetail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationGetPasswordDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationGetPasswordDetail} UserTwoStepVerificationGetPasswordDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationGetPasswordDetail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationGetPasswordDetail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationGetPasswordDetail message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationGetPasswordDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationGetPasswordDetail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationGetPasswordDetail;
  })();

  proto.UserTwoStepVerificationGetPasswordDetailResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationGetPasswordDetailResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationGetPasswordDetailResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationGetPasswordDetailResponse response
         * @property {string|null} [questionOne] UserTwoStepVerificationGetPasswordDetailResponse questionOne
         * @property {string|null} [questionTwo] UserTwoStepVerificationGetPasswordDetailResponse questionTwo
         * @property {string|null} [hint] UserTwoStepVerificationGetPasswordDetailResponse hint
         * @property {boolean|null} [hasConfirmedRecoveryEmail] UserTwoStepVerificationGetPasswordDetailResponse hasConfirmedRecoveryEmail
         * @property {string|null} [unconfirmedEmailPattern] UserTwoStepVerificationGetPasswordDetailResponse unconfirmedEmailPattern
         */

    /**
         * Constructs a new UserTwoStepVerificationGetPasswordDetailResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationGetPasswordDetailResponse.
         * @implements IUserTwoStepVerificationGetPasswordDetailResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationGetPasswordDetailResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationGetPasswordDetailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse questionOne.
         * @member {string} questionOne
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.questionOne = '';

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse questionTwo.
         * @member {string} questionTwo
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.questionTwo = '';

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse hint.
         * @member {string} hint
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.hint = '';

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse hasConfirmedRecoveryEmail.
         * @member {boolean} hasConfirmedRecoveryEmail
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.hasConfirmedRecoveryEmail = false;

    /**
         * UserTwoStepVerificationGetPasswordDetailResponse unconfirmedEmailPattern.
         * @member {string} unconfirmedEmailPattern
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.prototype.unconfirmedEmailPattern = '';

    /**
         * Creates a new UserTwoStepVerificationGetPasswordDetailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @static
         * @param {proto.IUserTwoStepVerificationGetPasswordDetailResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationGetPasswordDetailResponse} UserTwoStepVerificationGetPasswordDetailResponse instance
         */
    UserTwoStepVerificationGetPasswordDetailResponse.create = function create(properties) {
      return new UserTwoStepVerificationGetPasswordDetailResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationGetPasswordDetailResponse message. Does not implicitly {@link proto.UserTwoStepVerificationGetPasswordDetailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @static
         * @param {proto.UserTwoStepVerificationGetPasswordDetailResponse} message UserTwoStepVerificationGetPasswordDetailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationGetPasswordDetailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.questionOne);}
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.questionTwo);}
      if (message.hint != null && message.hasOwnProperty('hint')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.hint);}
      if (message.hasConfirmedRecoveryEmail != null && message.hasOwnProperty('hasConfirmedRecoveryEmail')) {writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasConfirmedRecoveryEmail);}
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.unconfirmedEmailPattern);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationGetPasswordDetailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationGetPasswordDetailResponse} UserTwoStepVerificationGetPasswordDetailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationGetPasswordDetailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationGetPasswordDetailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.questionOne = reader.string();
            break;
          case 3:
            message.questionTwo = reader.string();
            break;
          case 4:
            message.hint = reader.string();
            break;
          case 5:
            message.hasConfirmedRecoveryEmail = reader.bool();
            break;
          case 6:
            message.unconfirmedEmailPattern = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationGetPasswordDetailResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationGetPasswordDetailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationGetPasswordDetailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {
        if (!$util.isString(message.questionOne)) {return 'questionOne: string expected';}
      }
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {
        if (!$util.isString(message.questionTwo)) {return 'questionTwo: string expected';}
      }
      if (message.hint != null && message.hasOwnProperty('hint')) {
        if (!$util.isString(message.hint)) {return 'hint: string expected';}
      }
      if (message.hasConfirmedRecoveryEmail != null && message.hasOwnProperty('hasConfirmedRecoveryEmail')) {
        if (typeof message.hasConfirmedRecoveryEmail !== 'boolean') {return 'hasConfirmedRecoveryEmail: boolean expected';}
      }
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {
        if (!$util.isString(message.unconfirmedEmailPattern)) {return 'unconfirmedEmailPattern: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationGetPasswordDetailResponse;
  })();

  proto.UserTwoStepVerificationRecoverPasswordByAnswers = (function() {

    /**
         * Properties of a UserTwoStepVerificationRecoverPasswordByAnswers.
         * @memberof proto
         * @interface IUserTwoStepVerificationRecoverPasswordByAnswers
         * @property {proto.Request|null} [request] UserTwoStepVerificationRecoverPasswordByAnswers request
         * @property {string|null} [answerOne] UserTwoStepVerificationRecoverPasswordByAnswers answerOne
         * @property {string|null} [answerTwo] UserTwoStepVerificationRecoverPasswordByAnswers answerTwo
         */

    /**
         * Constructs a new UserTwoStepVerificationRecoverPasswordByAnswers.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRecoverPasswordByAnswers.
         * @implements IUserTwoStepVerificationRecoverPasswordByAnswers
         * @constructor
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByAnswers=} [properties] Properties to set
         */
    function UserTwoStepVerificationRecoverPasswordByAnswers(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRecoverPasswordByAnswers request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.prototype.request = null;

    /**
         * UserTwoStepVerificationRecoverPasswordByAnswers answerOne.
         * @member {string} answerOne
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.prototype.answerOne = '';

    /**
         * UserTwoStepVerificationRecoverPasswordByAnswers answerTwo.
         * @member {string} answerTwo
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.prototype.answerTwo = '';

    /**
         * Creates a new UserTwoStepVerificationRecoverPasswordByAnswers instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @static
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByAnswers=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByAnswers} UserTwoStepVerificationRecoverPasswordByAnswers instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.create = function create(properties) {
      return new UserTwoStepVerificationRecoverPasswordByAnswers(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRecoverPasswordByAnswers message. Does not implicitly {@link proto.UserTwoStepVerificationRecoverPasswordByAnswers.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @static
         * @param {proto.UserTwoStepVerificationRecoverPasswordByAnswers} message UserTwoStepVerificationRecoverPasswordByAnswers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.answerOne);}
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.answerTwo);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRecoverPasswordByAnswers message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByAnswers} UserTwoStepVerificationRecoverPasswordByAnswers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRecoverPasswordByAnswers();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.answerOne = reader.string();
            break;
          case 3:
            message.answerTwo = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRecoverPasswordByAnswers message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRecoverPasswordByAnswers.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {
        if (!$util.isString(message.answerOne)) {return 'answerOne: string expected';}
      }
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {
        if (!$util.isString(message.answerTwo)) {return 'answerTwo: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationRecoverPasswordByAnswers;
  })();

  proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationRecoverPasswordByAnswersResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationRecoverPasswordByAnswersResponse response
         * @property {string|null} [token] UserTwoStepVerificationRecoverPasswordByAnswersResponse token
         */

    /**
         * Constructs a new UserTwoStepVerificationRecoverPasswordByAnswersResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRecoverPasswordByAnswersResponse.
         * @implements IUserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByAnswersResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationRecoverPasswordByAnswersResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRecoverPasswordByAnswersResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationRecoverPasswordByAnswersResponse token.
         * @member {string} token
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.prototype.token = '';

    /**
         * Creates a new UserTwoStepVerificationRecoverPasswordByAnswersResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @static
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByAnswersResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse} UserTwoStepVerificationRecoverPasswordByAnswersResponse instance
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.create = function create(properties) {
      return new UserTwoStepVerificationRecoverPasswordByAnswersResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRecoverPasswordByAnswersResponse message. Does not implicitly {@link proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @static
         * @param {proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse} message UserTwoStepVerificationRecoverPasswordByAnswersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRecoverPasswordByAnswersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse} UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRecoverPasswordByAnswersResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByAnswersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRecoverPasswordByAnswersResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationRecoverPasswordByAnswersResponse;
  })();

  proto.UserTwoStepVerificationRecoverPasswordByToken = (function() {

    /**
         * Properties of a UserTwoStepVerificationRecoverPasswordByToken.
         * @memberof proto
         * @interface IUserTwoStepVerificationRecoverPasswordByToken
         * @property {proto.Request|null} [request] UserTwoStepVerificationRecoverPasswordByToken request
         * @property {string|null} [token] UserTwoStepVerificationRecoverPasswordByToken token
         */

    /**
         * Constructs a new UserTwoStepVerificationRecoverPasswordByToken.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRecoverPasswordByToken.
         * @implements IUserTwoStepVerificationRecoverPasswordByToken
         * @constructor
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByToken=} [properties] Properties to set
         */
    function UserTwoStepVerificationRecoverPasswordByToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRecoverPasswordByToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByToken.prototype.request = null;

    /**
         * UserTwoStepVerificationRecoverPasswordByToken token.
         * @member {string} token
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByToken.prototype.token = '';

    /**
         * Creates a new UserTwoStepVerificationRecoverPasswordByToken instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @static
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByToken=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByToken} UserTwoStepVerificationRecoverPasswordByToken instance
         */
    UserTwoStepVerificationRecoverPasswordByToken.create = function create(properties) {
      return new UserTwoStepVerificationRecoverPasswordByToken(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRecoverPasswordByToken message. Does not implicitly {@link proto.UserTwoStepVerificationRecoverPasswordByToken.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @static
         * @param {proto.UserTwoStepVerificationRecoverPasswordByToken} message UserTwoStepVerificationRecoverPasswordByToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRecoverPasswordByToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRecoverPasswordByToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByToken} UserTwoStepVerificationRecoverPasswordByToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRecoverPasswordByToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRecoverPasswordByToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRecoverPasswordByToken message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRecoverPasswordByToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationRecoverPasswordByToken;
  })();

  proto.UserTwoStepVerificationRecoverPasswordByTokenResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationRecoverPasswordByTokenResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationRecoverPasswordByTokenResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationRecoverPasswordByTokenResponse response
         * @property {string|null} [token] UserTwoStepVerificationRecoverPasswordByTokenResponse token
         */

    /**
         * Constructs a new UserTwoStepVerificationRecoverPasswordByTokenResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRecoverPasswordByTokenResponse.
         * @implements IUserTwoStepVerificationRecoverPasswordByTokenResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByTokenResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationRecoverPasswordByTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRecoverPasswordByTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationRecoverPasswordByTokenResponse token.
         * @member {string} token
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @instance
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.prototype.token = '';

    /**
         * Creates a new UserTwoStepVerificationRecoverPasswordByTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @static
         * @param {proto.IUserTwoStepVerificationRecoverPasswordByTokenResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByTokenResponse} UserTwoStepVerificationRecoverPasswordByTokenResponse instance
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.create = function create(properties) {
      return new UserTwoStepVerificationRecoverPasswordByTokenResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRecoverPasswordByTokenResponse message. Does not implicitly {@link proto.UserTwoStepVerificationRecoverPasswordByTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @static
         * @param {proto.UserTwoStepVerificationRecoverPasswordByTokenResponse} message UserTwoStepVerificationRecoverPasswordByTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRecoverPasswordByTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRecoverPasswordByTokenResponse} UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRecoverPasswordByTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRecoverPasswordByTokenResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRecoverPasswordByTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRecoverPasswordByTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationRecoverPasswordByTokenResponse;
  })();

  proto.UserTwoStepVerificationRequestRecoveryToken = (function() {

    /**
         * Properties of a UserTwoStepVerificationRequestRecoveryToken.
         * @memberof proto
         * @interface IUserTwoStepVerificationRequestRecoveryToken
         * @property {proto.Request|null} [request] UserTwoStepVerificationRequestRecoveryToken request
         */

    /**
         * Constructs a new UserTwoStepVerificationRequestRecoveryToken.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRequestRecoveryToken.
         * @implements IUserTwoStepVerificationRequestRecoveryToken
         * @constructor
         * @param {proto.IUserTwoStepVerificationRequestRecoveryToken=} [properties] Properties to set
         */
    function UserTwoStepVerificationRequestRecoveryToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRequestRecoveryToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationRequestRecoveryToken
         * @instance
         */
    UserTwoStepVerificationRequestRecoveryToken.prototype.request = null;

    /**
         * Creates a new UserTwoStepVerificationRequestRecoveryToken instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRequestRecoveryToken
         * @static
         * @param {proto.IUserTwoStepVerificationRequestRecoveryToken=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRequestRecoveryToken} UserTwoStepVerificationRequestRecoveryToken instance
         */
    UserTwoStepVerificationRequestRecoveryToken.create = function create(properties) {
      return new UserTwoStepVerificationRequestRecoveryToken(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRequestRecoveryToken message. Does not implicitly {@link proto.UserTwoStepVerificationRequestRecoveryToken.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRequestRecoveryToken
         * @static
         * @param {proto.UserTwoStepVerificationRequestRecoveryToken} message UserTwoStepVerificationRequestRecoveryToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRequestRecoveryToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRequestRecoveryToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRequestRecoveryToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRequestRecoveryToken} UserTwoStepVerificationRequestRecoveryToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRequestRecoveryToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRequestRecoveryToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRequestRecoveryToken message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRequestRecoveryToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRequestRecoveryToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationRequestRecoveryToken;
  })();

  proto.UserTwoStepVerificationRequestRecoveryTokenResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationRequestRecoveryTokenResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationRequestRecoveryTokenResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationRequestRecoveryTokenResponse response
         * @property {string|null} [emailPattern] UserTwoStepVerificationRequestRecoveryTokenResponse emailPattern
         */

    /**
         * Constructs a new UserTwoStepVerificationRequestRecoveryTokenResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationRequestRecoveryTokenResponse.
         * @implements IUserTwoStepVerificationRequestRecoveryTokenResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationRequestRecoveryTokenResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationRequestRecoveryTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationRequestRecoveryTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @instance
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationRequestRecoveryTokenResponse emailPattern.
         * @member {string} emailPattern
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @instance
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.prototype.emailPattern = '';

    /**
         * Creates a new UserTwoStepVerificationRequestRecoveryTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @static
         * @param {proto.IUserTwoStepVerificationRequestRecoveryTokenResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationRequestRecoveryTokenResponse} UserTwoStepVerificationRequestRecoveryTokenResponse instance
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.create = function create(properties) {
      return new UserTwoStepVerificationRequestRecoveryTokenResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationRequestRecoveryTokenResponse message. Does not implicitly {@link proto.UserTwoStepVerificationRequestRecoveryTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @static
         * @param {proto.UserTwoStepVerificationRequestRecoveryTokenResponse} message UserTwoStepVerificationRequestRecoveryTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.emailPattern != null && message.hasOwnProperty('emailPattern')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.emailPattern);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationRequestRecoveryTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationRequestRecoveryTokenResponse} UserTwoStepVerificationRequestRecoveryTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationRequestRecoveryTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.emailPattern = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationRequestRecoveryTokenResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationRequestRecoveryTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationRequestRecoveryTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.emailPattern != null && message.hasOwnProperty('emailPattern')) {
        if (!$util.isString(message.emailPattern)) {return 'emailPattern: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationRequestRecoveryTokenResponse;
  })();

  proto.UserTwoStepVerificationResendVerifyEmail = (function() {

    /**
         * Properties of a UserTwoStepVerificationResendVerifyEmail.
         * @memberof proto
         * @interface IUserTwoStepVerificationResendVerifyEmail
         * @property {proto.Request|null} [request] UserTwoStepVerificationResendVerifyEmail request
         */

    /**
         * Constructs a new UserTwoStepVerificationResendVerifyEmail.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationResendVerifyEmail.
         * @implements IUserTwoStepVerificationResendVerifyEmail
         * @constructor
         * @param {proto.IUserTwoStepVerificationResendVerifyEmail=} [properties] Properties to set
         */
    function UserTwoStepVerificationResendVerifyEmail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationResendVerifyEmail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationResendVerifyEmail
         * @instance
         */
    UserTwoStepVerificationResendVerifyEmail.prototype.request = null;

    /**
         * Creates a new UserTwoStepVerificationResendVerifyEmail instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationResendVerifyEmail
         * @static
         * @param {proto.IUserTwoStepVerificationResendVerifyEmail=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationResendVerifyEmail} UserTwoStepVerificationResendVerifyEmail instance
         */
    UserTwoStepVerificationResendVerifyEmail.create = function create(properties) {
      return new UserTwoStepVerificationResendVerifyEmail(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationResendVerifyEmail message. Does not implicitly {@link proto.UserTwoStepVerificationResendVerifyEmail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationResendVerifyEmail
         * @static
         * @param {proto.UserTwoStepVerificationResendVerifyEmail} message UserTwoStepVerificationResendVerifyEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationResendVerifyEmail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationResendVerifyEmail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationResendVerifyEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationResendVerifyEmail} UserTwoStepVerificationResendVerifyEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationResendVerifyEmail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationResendVerifyEmail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationResendVerifyEmail message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationResendVerifyEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationResendVerifyEmail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationResendVerifyEmail;
  })();

  proto.UserTwoStepVerificationResendVerifyEmailResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationResendVerifyEmailResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationResendVerifyEmailResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationResendVerifyEmailResponse response
         * @property {string|null} [unconfirmedEmailPattern] UserTwoStepVerificationResendVerifyEmailResponse unconfirmedEmailPattern
         */

    /**
         * Constructs a new UserTwoStepVerificationResendVerifyEmailResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationResendVerifyEmailResponse.
         * @implements IUserTwoStepVerificationResendVerifyEmailResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationResendVerifyEmailResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationResendVerifyEmailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationResendVerifyEmailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @instance
         */
    UserTwoStepVerificationResendVerifyEmailResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationResendVerifyEmailResponse unconfirmedEmailPattern.
         * @member {string} unconfirmedEmailPattern
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @instance
         */
    UserTwoStepVerificationResendVerifyEmailResponse.prototype.unconfirmedEmailPattern = '';

    /**
         * Creates a new UserTwoStepVerificationResendVerifyEmailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @static
         * @param {proto.IUserTwoStepVerificationResendVerifyEmailResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationResendVerifyEmailResponse} UserTwoStepVerificationResendVerifyEmailResponse instance
         */
    UserTwoStepVerificationResendVerifyEmailResponse.create = function create(properties) {
      return new UserTwoStepVerificationResendVerifyEmailResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationResendVerifyEmailResponse message. Does not implicitly {@link proto.UserTwoStepVerificationResendVerifyEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @static
         * @param {proto.UserTwoStepVerificationResendVerifyEmailResponse} message UserTwoStepVerificationResendVerifyEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationResendVerifyEmailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.unconfirmedEmailPattern);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationResendVerifyEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationResendVerifyEmailResponse} UserTwoStepVerificationResendVerifyEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationResendVerifyEmailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationResendVerifyEmailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.unconfirmedEmailPattern = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationResendVerifyEmailResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationResendVerifyEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationResendVerifyEmailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {
        if (!$util.isString(message.unconfirmedEmailPattern)) {return 'unconfirmedEmailPattern: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationResendVerifyEmailResponse;
  })();

  proto.UserTwoStepVerificationSetPassword = (function() {

    /**
         * Properties of a UserTwoStepVerificationSetPassword.
         * @memberof proto
         * @interface IUserTwoStepVerificationSetPassword
         * @property {proto.Request|null} [request] UserTwoStepVerificationSetPassword request
         * @property {string|null} [oldPassword] UserTwoStepVerificationSetPassword oldPassword
         * @property {string|null} [newPassword] UserTwoStepVerificationSetPassword newPassword
         * @property {string|null} [recoveryEmail] UserTwoStepVerificationSetPassword recoveryEmail
         * @property {string|null} [questionOne] UserTwoStepVerificationSetPassword questionOne
         * @property {string|null} [answerOne] UserTwoStepVerificationSetPassword answerOne
         * @property {string|null} [questionTwo] UserTwoStepVerificationSetPassword questionTwo
         * @property {string|null} [answerTwo] UserTwoStepVerificationSetPassword answerTwo
         * @property {string|null} [hint] UserTwoStepVerificationSetPassword hint
         */

    /**
         * Constructs a new UserTwoStepVerificationSetPassword.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationSetPassword.
         * @implements IUserTwoStepVerificationSetPassword
         * @constructor
         * @param {proto.IUserTwoStepVerificationSetPassword=} [properties] Properties to set
         */
    function UserTwoStepVerificationSetPassword(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationSetPassword request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.request = null;

    /**
         * UserTwoStepVerificationSetPassword oldPassword.
         * @member {string} oldPassword
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.oldPassword = '';

    /**
         * UserTwoStepVerificationSetPassword newPassword.
         * @member {string} newPassword
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.newPassword = '';

    /**
         * UserTwoStepVerificationSetPassword recoveryEmail.
         * @member {string} recoveryEmail
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.recoveryEmail = '';

    /**
         * UserTwoStepVerificationSetPassword questionOne.
         * @member {string} questionOne
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.questionOne = '';

    /**
         * UserTwoStepVerificationSetPassword answerOne.
         * @member {string} answerOne
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.answerOne = '';

    /**
         * UserTwoStepVerificationSetPassword questionTwo.
         * @member {string} questionTwo
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.questionTwo = '';

    /**
         * UserTwoStepVerificationSetPassword answerTwo.
         * @member {string} answerTwo
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.answerTwo = '';

    /**
         * UserTwoStepVerificationSetPassword hint.
         * @member {string} hint
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @instance
         */
    UserTwoStepVerificationSetPassword.prototype.hint = '';

    /**
         * Creates a new UserTwoStepVerificationSetPassword instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @static
         * @param {proto.IUserTwoStepVerificationSetPassword=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationSetPassword} UserTwoStepVerificationSetPassword instance
         */
    UserTwoStepVerificationSetPassword.create = function create(properties) {
      return new UserTwoStepVerificationSetPassword(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationSetPassword message. Does not implicitly {@link proto.UserTwoStepVerificationSetPassword.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @static
         * @param {proto.UserTwoStepVerificationSetPassword} message UserTwoStepVerificationSetPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationSetPassword.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.oldPassword != null && message.hasOwnProperty('oldPassword')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.oldPassword);}
      if (message.newPassword != null && message.hasOwnProperty('newPassword')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.newPassword);}
      if (message.recoveryEmail != null && message.hasOwnProperty('recoveryEmail')) {writer.uint32(/* id 4, wireType 2 =*/34).string(message.recoveryEmail);}
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.questionOne);}
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {writer.uint32(/* id 6, wireType 2 =*/50).string(message.answerOne);}
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.questionTwo);}
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {writer.uint32(/* id 8, wireType 2 =*/66).string(message.answerTwo);}
      if (message.hint != null && message.hasOwnProperty('hint')) {writer.uint32(/* id 9, wireType 2 =*/74).string(message.hint);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationSetPassword message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationSetPassword} UserTwoStepVerificationSetPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationSetPassword.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationSetPassword();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.oldPassword = reader.string();
            break;
          case 3:
            message.newPassword = reader.string();
            break;
          case 4:
            message.recoveryEmail = reader.string();
            break;
          case 5:
            message.questionOne = reader.string();
            break;
          case 6:
            message.answerOne = reader.string();
            break;
          case 7:
            message.questionTwo = reader.string();
            break;
          case 8:
            message.answerTwo = reader.string();
            break;
          case 9:
            message.hint = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationSetPassword message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationSetPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationSetPassword.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.oldPassword != null && message.hasOwnProperty('oldPassword')) {
        if (!$util.isString(message.oldPassword)) {return 'oldPassword: string expected';}
      }
      if (message.newPassword != null && message.hasOwnProperty('newPassword')) {
        if (!$util.isString(message.newPassword)) {return 'newPassword: string expected';}
      }
      if (message.recoveryEmail != null && message.hasOwnProperty('recoveryEmail')) {
        if (!$util.isString(message.recoveryEmail)) {return 'recoveryEmail: string expected';}
      }
      if (message.questionOne != null && message.hasOwnProperty('questionOne')) {
        if (!$util.isString(message.questionOne)) {return 'questionOne: string expected';}
      }
      if (message.answerOne != null && message.hasOwnProperty('answerOne')) {
        if (!$util.isString(message.answerOne)) {return 'answerOne: string expected';}
      }
      if (message.questionTwo != null && message.hasOwnProperty('questionTwo')) {
        if (!$util.isString(message.questionTwo)) {return 'questionTwo: string expected';}
      }
      if (message.answerTwo != null && message.hasOwnProperty('answerTwo')) {
        if (!$util.isString(message.answerTwo)) {return 'answerTwo: string expected';}
      }
      if (message.hint != null && message.hasOwnProperty('hint')) {
        if (!$util.isString(message.hint)) {return 'hint: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationSetPassword;
  })();

  proto.UserTwoStepVerificationSetPasswordResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationSetPasswordResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationSetPasswordResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationSetPasswordResponse response
         * @property {string|null} [unconfirmedEmailPattern] UserTwoStepVerificationSetPasswordResponse unconfirmedEmailPattern
         */

    /**
         * Constructs a new UserTwoStepVerificationSetPasswordResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationSetPasswordResponse.
         * @implements IUserTwoStepVerificationSetPasswordResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationSetPasswordResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationSetPasswordResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationSetPasswordResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @instance
         */
    UserTwoStepVerificationSetPasswordResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationSetPasswordResponse unconfirmedEmailPattern.
         * @member {string} unconfirmedEmailPattern
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @instance
         */
    UserTwoStepVerificationSetPasswordResponse.prototype.unconfirmedEmailPattern = '';

    /**
         * Creates a new UserTwoStepVerificationSetPasswordResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @static
         * @param {proto.IUserTwoStepVerificationSetPasswordResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationSetPasswordResponse} UserTwoStepVerificationSetPasswordResponse instance
         */
    UserTwoStepVerificationSetPasswordResponse.create = function create(properties) {
      return new UserTwoStepVerificationSetPasswordResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationSetPasswordResponse message. Does not implicitly {@link proto.UserTwoStepVerificationSetPasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @static
         * @param {proto.UserTwoStepVerificationSetPasswordResponse} message UserTwoStepVerificationSetPasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationSetPasswordResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.unconfirmedEmailPattern);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationSetPasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationSetPasswordResponse} UserTwoStepVerificationSetPasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationSetPasswordResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationSetPasswordResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.unconfirmedEmailPattern = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationSetPasswordResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationSetPasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationSetPasswordResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.unconfirmedEmailPattern != null && message.hasOwnProperty('unconfirmedEmailPattern')) {
        if (!$util.isString(message.unconfirmedEmailPattern)) {return 'unconfirmedEmailPattern: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationSetPasswordResponse;
  })();

  proto.UserTwoStepVerificationUnsetPassword = (function() {

    /**
         * Properties of a UserTwoStepVerificationUnsetPassword.
         * @memberof proto
         * @interface IUserTwoStepVerificationUnsetPassword
         * @property {proto.Request|null} [request] UserTwoStepVerificationUnsetPassword request
         * @property {string|null} [password] UserTwoStepVerificationUnsetPassword password
         */

    /**
         * Constructs a new UserTwoStepVerificationUnsetPassword.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationUnsetPassword.
         * @implements IUserTwoStepVerificationUnsetPassword
         * @constructor
         * @param {proto.IUserTwoStepVerificationUnsetPassword=} [properties] Properties to set
         */
    function UserTwoStepVerificationUnsetPassword(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationUnsetPassword request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @instance
         */
    UserTwoStepVerificationUnsetPassword.prototype.request = null;

    /**
         * UserTwoStepVerificationUnsetPassword password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @instance
         */
    UserTwoStepVerificationUnsetPassword.prototype.password = '';

    /**
         * Creates a new UserTwoStepVerificationUnsetPassword instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @static
         * @param {proto.IUserTwoStepVerificationUnsetPassword=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationUnsetPassword} UserTwoStepVerificationUnsetPassword instance
         */
    UserTwoStepVerificationUnsetPassword.create = function create(properties) {
      return new UserTwoStepVerificationUnsetPassword(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationUnsetPassword message. Does not implicitly {@link proto.UserTwoStepVerificationUnsetPassword.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @static
         * @param {proto.UserTwoStepVerificationUnsetPassword} message UserTwoStepVerificationUnsetPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationUnsetPassword.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationUnsetPassword message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationUnsetPassword} UserTwoStepVerificationUnsetPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationUnsetPassword.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationUnsetPassword();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationUnsetPassword message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationUnsetPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationUnsetPassword.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationUnsetPassword;
  })();

  proto.UserTwoStepVerificationUnsetPasswordResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationUnsetPasswordResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationUnsetPasswordResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationUnsetPasswordResponse response
         */

    /**
         * Constructs a new UserTwoStepVerificationUnsetPasswordResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationUnsetPasswordResponse.
         * @implements IUserTwoStepVerificationUnsetPasswordResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationUnsetPasswordResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationUnsetPasswordResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationUnsetPasswordResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationUnsetPasswordResponse
         * @instance
         */
    UserTwoStepVerificationUnsetPasswordResponse.prototype.response = null;

    /**
         * Creates a new UserTwoStepVerificationUnsetPasswordResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationUnsetPasswordResponse
         * @static
         * @param {proto.IUserTwoStepVerificationUnsetPasswordResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationUnsetPasswordResponse} UserTwoStepVerificationUnsetPasswordResponse instance
         */
    UserTwoStepVerificationUnsetPasswordResponse.create = function create(properties) {
      return new UserTwoStepVerificationUnsetPasswordResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationUnsetPasswordResponse message. Does not implicitly {@link proto.UserTwoStepVerificationUnsetPasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationUnsetPasswordResponse
         * @static
         * @param {proto.UserTwoStepVerificationUnsetPasswordResponse} message UserTwoStepVerificationUnsetPasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationUnsetPasswordResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationUnsetPasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationUnsetPasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationUnsetPasswordResponse} UserTwoStepVerificationUnsetPasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationUnsetPasswordResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationUnsetPasswordResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationUnsetPasswordResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationUnsetPasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationUnsetPasswordResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationUnsetPasswordResponse;
  })();

  proto.UserTwoStepVerificationVerifyPassword = (function() {

    /**
         * Properties of a UserTwoStepVerificationVerifyPassword.
         * @memberof proto
         * @interface IUserTwoStepVerificationVerifyPassword
         * @property {proto.Request|null} [request] UserTwoStepVerificationVerifyPassword request
         * @property {string|null} [password] UserTwoStepVerificationVerifyPassword password
         */

    /**
         * Constructs a new UserTwoStepVerificationVerifyPassword.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationVerifyPassword.
         * @implements IUserTwoStepVerificationVerifyPassword
         * @constructor
         * @param {proto.IUserTwoStepVerificationVerifyPassword=} [properties] Properties to set
         */
    function UserTwoStepVerificationVerifyPassword(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationVerifyPassword request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @instance
         */
    UserTwoStepVerificationVerifyPassword.prototype.request = null;

    /**
         * UserTwoStepVerificationVerifyPassword password.
         * @member {string} password
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @instance
         */
    UserTwoStepVerificationVerifyPassword.prototype.password = '';

    /**
         * Creates a new UserTwoStepVerificationVerifyPassword instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @static
         * @param {proto.IUserTwoStepVerificationVerifyPassword=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationVerifyPassword} UserTwoStepVerificationVerifyPassword instance
         */
    UserTwoStepVerificationVerifyPassword.create = function create(properties) {
      return new UserTwoStepVerificationVerifyPassword(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationVerifyPassword message. Does not implicitly {@link proto.UserTwoStepVerificationVerifyPassword.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @static
         * @param {proto.UserTwoStepVerificationVerifyPassword} message UserTwoStepVerificationVerifyPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationVerifyPassword.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.password != null && message.hasOwnProperty('password')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationVerifyPassword message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationVerifyPassword} UserTwoStepVerificationVerifyPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationVerifyPassword.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationVerifyPassword();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.password = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationVerifyPassword message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationVerifyPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationVerifyPassword.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.password != null && message.hasOwnProperty('password')) {
        if (!$util.isString(message.password)) {return 'password: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationVerifyPassword;
  })();

  proto.UserTwoStepVerificationVerifyPasswordResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationVerifyPasswordResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationVerifyPasswordResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationVerifyPasswordResponse response
         * @property {string|null} [token] UserTwoStepVerificationVerifyPasswordResponse token
         */

    /**
         * Constructs a new UserTwoStepVerificationVerifyPasswordResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationVerifyPasswordResponse.
         * @implements IUserTwoStepVerificationVerifyPasswordResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationVerifyPasswordResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationVerifyPasswordResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationVerifyPasswordResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @instance
         */
    UserTwoStepVerificationVerifyPasswordResponse.prototype.response = null;

    /**
         * UserTwoStepVerificationVerifyPasswordResponse token.
         * @member {string} token
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @instance
         */
    UserTwoStepVerificationVerifyPasswordResponse.prototype.token = '';

    /**
         * Creates a new UserTwoStepVerificationVerifyPasswordResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @static
         * @param {proto.IUserTwoStepVerificationVerifyPasswordResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationVerifyPasswordResponse} UserTwoStepVerificationVerifyPasswordResponse instance
         */
    UserTwoStepVerificationVerifyPasswordResponse.create = function create(properties) {
      return new UserTwoStepVerificationVerifyPasswordResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationVerifyPasswordResponse message. Does not implicitly {@link proto.UserTwoStepVerificationVerifyPasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @static
         * @param {proto.UserTwoStepVerificationVerifyPasswordResponse} message UserTwoStepVerificationVerifyPasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationVerifyPasswordResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationVerifyPasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationVerifyPasswordResponse} UserTwoStepVerificationVerifyPasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationVerifyPasswordResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationVerifyPasswordResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationVerifyPasswordResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationVerifyPasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationVerifyPasswordResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationVerifyPasswordResponse;
  })();

  proto.UserTwoStepVerificationVerifyRecoveryEmail = (function() {

    /**
         * Properties of a UserTwoStepVerificationVerifyRecoveryEmail.
         * @memberof proto
         * @interface IUserTwoStepVerificationVerifyRecoveryEmail
         * @property {proto.Request|null} [request] UserTwoStepVerificationVerifyRecoveryEmail request
         * @property {string|null} [token] UserTwoStepVerificationVerifyRecoveryEmail token
         */

    /**
         * Constructs a new UserTwoStepVerificationVerifyRecoveryEmail.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationVerifyRecoveryEmail.
         * @implements IUserTwoStepVerificationVerifyRecoveryEmail
         * @constructor
         * @param {proto.IUserTwoStepVerificationVerifyRecoveryEmail=} [properties] Properties to set
         */
    function UserTwoStepVerificationVerifyRecoveryEmail(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationVerifyRecoveryEmail request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @instance
         */
    UserTwoStepVerificationVerifyRecoveryEmail.prototype.request = null;

    /**
         * UserTwoStepVerificationVerifyRecoveryEmail token.
         * @member {string} token
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @instance
         */
    UserTwoStepVerificationVerifyRecoveryEmail.prototype.token = '';

    /**
         * Creates a new UserTwoStepVerificationVerifyRecoveryEmail instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @static
         * @param {proto.IUserTwoStepVerificationVerifyRecoveryEmail=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationVerifyRecoveryEmail} UserTwoStepVerificationVerifyRecoveryEmail instance
         */
    UserTwoStepVerificationVerifyRecoveryEmail.create = function create(properties) {
      return new UserTwoStepVerificationVerifyRecoveryEmail(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationVerifyRecoveryEmail message. Does not implicitly {@link proto.UserTwoStepVerificationVerifyRecoveryEmail.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @static
         * @param {proto.UserTwoStepVerificationVerifyRecoveryEmail} message UserTwoStepVerificationVerifyRecoveryEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationVerifyRecoveryEmail.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationVerifyRecoveryEmail message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationVerifyRecoveryEmail} UserTwoStepVerificationVerifyRecoveryEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationVerifyRecoveryEmail.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationVerifyRecoveryEmail();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationVerifyRecoveryEmail message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationVerifyRecoveryEmail.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserTwoStepVerificationVerifyRecoveryEmail;
  })();

  proto.UserTwoStepVerificationVerifyRecoveryEmailResponse = (function() {

    /**
         * Properties of a UserTwoStepVerificationVerifyRecoveryEmailResponse.
         * @memberof proto
         * @interface IUserTwoStepVerificationVerifyRecoveryEmailResponse
         * @property {proto.Response|null} [response] UserTwoStepVerificationVerifyRecoveryEmailResponse response
         */

    /**
         * Constructs a new UserTwoStepVerificationVerifyRecoveryEmailResponse.
         * @memberof proto
         * @classdesc Represents a UserTwoStepVerificationVerifyRecoveryEmailResponse.
         * @implements IUserTwoStepVerificationVerifyRecoveryEmailResponse
         * @constructor
         * @param {proto.IUserTwoStepVerificationVerifyRecoveryEmailResponse=} [properties] Properties to set
         */
    function UserTwoStepVerificationVerifyRecoveryEmailResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserTwoStepVerificationVerifyRecoveryEmailResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @instance
         */
    UserTwoStepVerificationVerifyRecoveryEmailResponse.prototype.response = null;

    /**
         * Creates a new UserTwoStepVerificationVerifyRecoveryEmailResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @static
         * @param {proto.IUserTwoStepVerificationVerifyRecoveryEmailResponse=} [properties] Properties to set
         * @returns {proto.UserTwoStepVerificationVerifyRecoveryEmailResponse} UserTwoStepVerificationVerifyRecoveryEmailResponse instance
         */
    UserTwoStepVerificationVerifyRecoveryEmailResponse.create = function create(properties) {
      return new UserTwoStepVerificationVerifyRecoveryEmailResponse(properties);
    };

    /**
         * Encodes the specified UserTwoStepVerificationVerifyRecoveryEmailResponse message. Does not implicitly {@link proto.UserTwoStepVerificationVerifyRecoveryEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @static
         * @param {proto.UserTwoStepVerificationVerifyRecoveryEmailResponse} message UserTwoStepVerificationVerifyRecoveryEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserTwoStepVerificationVerifyRecoveryEmailResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a UserTwoStepVerificationVerifyRecoveryEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserTwoStepVerificationVerifyRecoveryEmailResponse} UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserTwoStepVerificationVerifyRecoveryEmailResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserTwoStepVerificationVerifyRecoveryEmailResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserTwoStepVerificationVerifyRecoveryEmailResponse message.
         * @function verify
         * @memberof proto.UserTwoStepVerificationVerifyRecoveryEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserTwoStepVerificationVerifyRecoveryEmailResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      return null;
    };

    return UserTwoStepVerificationVerifyRecoveryEmailResponse;
  })();

  proto.UserUpdateStatus = (function() {

    /**
         * Properties of a UserUpdateStatus.
         * @memberof proto
         * @interface IUserUpdateStatus
         * @property {proto.Request|null} [request] UserUpdateStatus request
         * @property {proto.UserUpdateStatus.Status|null} [status] UserUpdateStatus status
         */

    /**
         * Constructs a new UserUpdateStatus.
         * @memberof proto
         * @classdesc Represents a UserUpdateStatus.
         * @implements IUserUpdateStatus
         * @constructor
         * @param {proto.IUserUpdateStatus=} [properties] Properties to set
         */
    function UserUpdateStatus(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserUpdateStatus request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserUpdateStatus
         * @instance
         */
    UserUpdateStatus.prototype.request = null;

    /**
         * UserUpdateStatus status.
         * @member {proto.UserUpdateStatus.Status} status
         * @memberof proto.UserUpdateStatus
         * @instance
         */
    UserUpdateStatus.prototype.status = 0;

    /**
         * Creates a new UserUpdateStatus instance using the specified properties.
         * @function create
         * @memberof proto.UserUpdateStatus
         * @static
         * @param {proto.IUserUpdateStatus=} [properties] Properties to set
         * @returns {proto.UserUpdateStatus} UserUpdateStatus instance
         */
    UserUpdateStatus.create = function create(properties) {
      return new UserUpdateStatus(properties);
    };

    /**
         * Encodes the specified UserUpdateStatus message. Does not implicitly {@link proto.UserUpdateStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.UserUpdateStatus
         * @static
         * @param {proto.UserUpdateStatus} message UserUpdateStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserUpdateStatus.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      return writer;
    };

    /**
         * Decodes a UserUpdateStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserUpdateStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserUpdateStatus} UserUpdateStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserUpdateStatus.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserUpdateStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserUpdateStatus message.
         * @function verify
         * @memberof proto.UserUpdateStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserUpdateStatus.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      return null;
    };

    /**
         * Status enum.
         * @name proto.UserUpdateStatus.Status
         * @enum {string}
         * @property {number} ONLINE=0 ONLINE value
         * @property {number} OFFLINE=1 OFFLINE value
         */
    UserUpdateStatus.Status = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'ONLINE'] = 0;
      values[valuesById[1] = 'OFFLINE'] = 1;
      return values;
    })();

    return UserUpdateStatus;
  })();

  proto.UserUpdateStatusResponse = (function() {

    /**
         * Properties of a UserUpdateStatusResponse.
         * @memberof proto
         * @interface IUserUpdateStatusResponse
         * @property {proto.Response|null} [response] UserUpdateStatusResponse response
         * @property {proto.UserUpdateStatus.Status|null} [status] UserUpdateStatusResponse status
         * @property {Long|null} [userId] UserUpdateStatusResponse userId
         */

    /**
         * Constructs a new UserUpdateStatusResponse.
         * @memberof proto
         * @classdesc Represents a UserUpdateStatusResponse.
         * @implements IUserUpdateStatusResponse
         * @constructor
         * @param {proto.IUserUpdateStatusResponse=} [properties] Properties to set
         */
    function UserUpdateStatusResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserUpdateStatusResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserUpdateStatusResponse
         * @instance
         */
    UserUpdateStatusResponse.prototype.response = null;

    /**
         * UserUpdateStatusResponse status.
         * @member {proto.UserUpdateStatus.Status} status
         * @memberof proto.UserUpdateStatusResponse
         * @instance
         */
    UserUpdateStatusResponse.prototype.status = 0;

    /**
         * UserUpdateStatusResponse userId.
         * @member {Long} userId
         * @memberof proto.UserUpdateStatusResponse
         * @instance
         */
    UserUpdateStatusResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserUpdateStatusResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserUpdateStatusResponse
         * @static
         * @param {proto.IUserUpdateStatusResponse=} [properties] Properties to set
         * @returns {proto.UserUpdateStatusResponse} UserUpdateStatusResponse instance
         */
    UserUpdateStatusResponse.create = function create(properties) {
      return new UserUpdateStatusResponse(properties);
    };

    /**
         * Encodes the specified UserUpdateStatusResponse message. Does not implicitly {@link proto.UserUpdateStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserUpdateStatusResponse
         * @static
         * @param {proto.UserUpdateStatusResponse} message UserUpdateStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserUpdateStatusResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.status != null && message.hasOwnProperty('status')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserUpdateStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserUpdateStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserUpdateStatusResponse} UserUpdateStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserUpdateStatusResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserUpdateStatusResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.status = reader.int32();
            break;
          case 8:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserUpdateStatusResponse message.
         * @function verify
         * @memberof proto.UserUpdateStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserUpdateStatusResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.status != null && message.hasOwnProperty('status')) {
        switch (message.status) {
          default:
            return 'status: enum value expected';
          case 0:
          case 1:
            break;
        }
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserUpdateStatusResponse;
  })();

  proto.UserUsernameToId = (function() {

    /**
         * Properties of a UserUsernameToId.
         * @memberof proto
         * @interface IUserUsernameToId
         * @property {proto.Request|null} [request] UserUsernameToId request
         * @property {string|null} [username] UserUsernameToId username
         */

    /**
         * Constructs a new UserUsernameToId.
         * @memberof proto
         * @classdesc Represents a UserUsernameToId.
         * @implements IUserUsernameToId
         * @constructor
         * @param {proto.IUserUsernameToId=} [properties] Properties to set
         */
    function UserUsernameToId(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserUsernameToId request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserUsernameToId
         * @instance
         */
    UserUsernameToId.prototype.request = null;

    /**
         * UserUsernameToId username.
         * @member {string} username
         * @memberof proto.UserUsernameToId
         * @instance
         */
    UserUsernameToId.prototype.username = '';

    /**
         * Creates a new UserUsernameToId instance using the specified properties.
         * @function create
         * @memberof proto.UserUsernameToId
         * @static
         * @param {proto.IUserUsernameToId=} [properties] Properties to set
         * @returns {proto.UserUsernameToId} UserUsernameToId instance
         */
    UserUsernameToId.create = function create(properties) {
      return new UserUsernameToId(properties);
    };

    /**
         * Encodes the specified UserUsernameToId message. Does not implicitly {@link proto.UserUsernameToId.verify|verify} messages.
         * @function encode
         * @memberof proto.UserUsernameToId
         * @static
         * @param {proto.UserUsernameToId} message UserUsernameToId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserUsernameToId.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);}
      return writer;
    };

    /**
         * Decodes a UserUsernameToId message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserUsernameToId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserUsernameToId} UserUsernameToId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserUsernameToId.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserUsernameToId();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserUsernameToId message.
         * @function verify
         * @memberof proto.UserUsernameToId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserUsernameToId.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return UserUsernameToId;
  })();

  proto.UserUsernameToIdResponse = (function() {

    /**
         * Properties of a UserUsernameToIdResponse.
         * @memberof proto
         * @interface IUserUsernameToIdResponse
         * @property {proto.Response|null} [response] UserUsernameToIdResponse response
         * @property {Long|null} [userId] UserUsernameToIdResponse userId
         */

    /**
         * Constructs a new UserUsernameToIdResponse.
         * @memberof proto
         * @classdesc Represents a UserUsernameToIdResponse.
         * @implements IUserUsernameToIdResponse
         * @constructor
         * @param {proto.IUserUsernameToIdResponse=} [properties] Properties to set
         */
    function UserUsernameToIdResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserUsernameToIdResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserUsernameToIdResponse
         * @instance
         */
    UserUsernameToIdResponse.prototype.response = null;

    /**
         * UserUsernameToIdResponse userId.
         * @member {Long} userId
         * @memberof proto.UserUsernameToIdResponse
         * @instance
         */
    UserUsernameToIdResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

    /**
         * Creates a new UserUsernameToIdResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserUsernameToIdResponse
         * @static
         * @param {proto.IUserUsernameToIdResponse=} [properties] Properties to set
         * @returns {proto.UserUsernameToIdResponse} UserUsernameToIdResponse instance
         */
    UserUsernameToIdResponse.create = function create(properties) {
      return new UserUsernameToIdResponse(properties);
    };

    /**
         * Encodes the specified UserUsernameToIdResponse message. Does not implicitly {@link proto.UserUsernameToIdResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserUsernameToIdResponse
         * @static
         * @param {proto.UserUsernameToIdResponse} message UserUsernameToIdResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserUsernameToIdResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.userId != null && message.hasOwnProperty('userId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userId);}
      return writer;
    };

    /**
         * Decodes a UserUsernameToIdResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserUsernameToIdResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserUsernameToIdResponse} UserUsernameToIdResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserUsernameToIdResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserUsernameToIdResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 3:
            message.userId = reader.uint64();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserUsernameToIdResponse message.
         * @function verify
         * @memberof proto.UserUsernameToIdResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserUsernameToIdResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.userId != null && message.hasOwnProperty('userId')) {
        if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high))) {return 'userId: integer|Long expected';}
      }
      return null;
    };

    return UserUsernameToIdResponse;
  })();

  proto.UserVerify = (function() {

    /**
         * Properties of a UserVerify.
         * @memberof proto
         * @interface IUserVerify
         * @property {proto.Request|null} [request] UserVerify request
         * @property {number|null} [code] UserVerify code
         * @property {string|null} [username] UserVerify username
         */

    /**
         * Constructs a new UserVerify.
         * @memberof proto
         * @classdesc Represents a UserVerify.
         * @implements IUserVerify
         * @constructor
         * @param {proto.IUserVerify=} [properties] Properties to set
         */
    function UserVerify(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserVerify request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserVerify
         * @instance
         */
    UserVerify.prototype.request = null;

    /**
         * UserVerify code.
         * @member {number} code
         * @memberof proto.UserVerify
         * @instance
         */
    UserVerify.prototype.code = 0;

    /**
         * UserVerify username.
         * @member {string} username
         * @memberof proto.UserVerify
         * @instance
         */
    UserVerify.prototype.username = '';

    /**
         * Creates a new UserVerify instance using the specified properties.
         * @function create
         * @memberof proto.UserVerify
         * @static
         * @param {proto.IUserVerify=} [properties] Properties to set
         * @returns {proto.UserVerify} UserVerify instance
         */
    UserVerify.create = function create(properties) {
      return new UserVerify(properties);
    };

    /**
         * Encodes the specified UserVerify message. Does not implicitly {@link proto.UserVerify.verify|verify} messages.
         * @function encode
         * @memberof proto.UserVerify
         * @static
         * @param {proto.UserVerify} message UserVerify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserVerify.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.code != null && message.hasOwnProperty('code')) {writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.code);}
      if (message.username != null && message.hasOwnProperty('username')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);}
      return writer;
    };

    /**
         * Decodes a UserVerify message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserVerify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserVerify} UserVerify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserVerify.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserVerify();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.code = reader.uint32();
            break;
          case 3:
            message.username = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserVerify message.
         * @function verify
         * @memberof proto.UserVerify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserVerify.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.code != null && message.hasOwnProperty('code')) {
        if (!$util.isInteger(message.code)) {return 'code: integer expected';}
      }
      if (message.username != null && message.hasOwnProperty('username')) {
        if (!$util.isString(message.username)) {return 'username: string expected';}
      }
      return null;
    };

    return UserVerify;
  })();

  proto.UserVerifyResponse = (function() {

    /**
         * Properties of a UserVerifyResponse.
         * @memberof proto
         * @interface IUserVerifyResponse
         * @property {proto.Response|null} [response] UserVerifyResponse response
         * @property {string|null} [token] UserVerifyResponse token
         * @property {boolean|null} [newUser] UserVerifyResponse newUser
         */

    /**
         * Constructs a new UserVerifyResponse.
         * @memberof proto
         * @classdesc Represents a UserVerifyResponse.
         * @implements IUserVerifyResponse
         * @constructor
         * @param {proto.IUserVerifyResponse=} [properties] Properties to set
         */
    function UserVerifyResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserVerifyResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserVerifyResponse
         * @instance
         */
    UserVerifyResponse.prototype.response = null;

    /**
         * UserVerifyResponse token.
         * @member {string} token
         * @memberof proto.UserVerifyResponse
         * @instance
         */
    UserVerifyResponse.prototype.token = '';

    /**
         * UserVerifyResponse newUser.
         * @member {boolean} newUser
         * @memberof proto.UserVerifyResponse
         * @instance
         */
    UserVerifyResponse.prototype.newUser = false;

    /**
         * Creates a new UserVerifyResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserVerifyResponse
         * @static
         * @param {proto.IUserVerifyResponse=} [properties] Properties to set
         * @returns {proto.UserVerifyResponse} UserVerifyResponse instance
         */
    UserVerifyResponse.create = function create(properties) {
      return new UserVerifyResponse(properties);
    };

    /**
         * Encodes the specified UserVerifyResponse message. Does not implicitly {@link proto.UserVerifyResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserVerifyResponse
         * @static
         * @param {proto.UserVerifyResponse} message UserVerifyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserVerifyResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      if (message.newUser != null && message.hasOwnProperty('newUser')) {writer.uint32(/* id 3, wireType 0 =*/24).bool(message.newUser);}
      return writer;
    };

    /**
         * Decodes a UserVerifyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserVerifyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserVerifyResponse} UserVerifyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserVerifyResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserVerifyResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          case 3:
            message.newUser = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserVerifyResponse message.
         * @function verify
         * @memberof proto.UserVerifyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserVerifyResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      if (message.newUser != null && message.hasOwnProperty('newUser')) {
        if (typeof message.newUser !== 'boolean') {return 'newUser: boolean expected';}
      }
      return null;
    };

    return UserVerifyResponse;
  })();

  proto.UserVerifyNewDevice = (function() {

    /**
         * Properties of a UserVerifyNewDevice.
         * @memberof proto
         * @interface IUserVerifyNewDevice
         * @property {proto.Request|null} [request] UserVerifyNewDevice request
         * @property {string|null} [token] UserVerifyNewDevice token
         */

    /**
         * Constructs a new UserVerifyNewDevice.
         * @memberof proto
         * @classdesc Represents a UserVerifyNewDevice.
         * @implements IUserVerifyNewDevice
         * @constructor
         * @param {proto.IUserVerifyNewDevice=} [properties] Properties to set
         */
    function UserVerifyNewDevice(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserVerifyNewDevice request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.UserVerifyNewDevice
         * @instance
         */
    UserVerifyNewDevice.prototype.request = null;

    /**
         * UserVerifyNewDevice token.
         * @member {string} token
         * @memberof proto.UserVerifyNewDevice
         * @instance
         */
    UserVerifyNewDevice.prototype.token = '';

    /**
         * Creates a new UserVerifyNewDevice instance using the specified properties.
         * @function create
         * @memberof proto.UserVerifyNewDevice
         * @static
         * @param {proto.IUserVerifyNewDevice=} [properties] Properties to set
         * @returns {proto.UserVerifyNewDevice} UserVerifyNewDevice instance
         */
    UserVerifyNewDevice.create = function create(properties) {
      return new UserVerifyNewDevice(properties);
    };

    /**
         * Encodes the specified UserVerifyNewDevice message. Does not implicitly {@link proto.UserVerifyNewDevice.verify|verify} messages.
         * @function encode
         * @memberof proto.UserVerifyNewDevice
         * @static
         * @param {proto.UserVerifyNewDevice} message UserVerifyNewDevice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserVerifyNewDevice.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.token != null && message.hasOwnProperty('token')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);}
      return writer;
    };

    /**
         * Decodes a UserVerifyNewDevice message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserVerifyNewDevice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserVerifyNewDevice} UserVerifyNewDevice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserVerifyNewDevice.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserVerifyNewDevice();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          case 2:
            message.token = reader.string();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserVerifyNewDevice message.
         * @function verify
         * @memberof proto.UserVerifyNewDevice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserVerifyNewDevice.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      if (message.token != null && message.hasOwnProperty('token')) {
        if (!$util.isString(message.token)) {return 'token: string expected';}
      }
      return null;
    };

    return UserVerifyNewDevice;
  })();

  proto.UserVerifyNewDeviceResponse = (function() {

    /**
         * Properties of a UserVerifyNewDeviceResponse.
         * @memberof proto
         * @interface IUserVerifyNewDeviceResponse
         * @property {proto.Response|null} [response] UserVerifyNewDeviceResponse response
         * @property {string|null} [appName] UserVerifyNewDeviceResponse appName
         * @property {number|null} [appId] UserVerifyNewDeviceResponse appId
         * @property {number|null} [appBuildVersion] UserVerifyNewDeviceResponse appBuildVersion
         * @property {string|null} [appVersion] UserVerifyNewDeviceResponse appVersion
         * @property {proto.Platform|null} [platform] UserVerifyNewDeviceResponse platform
         * @property {string|null} [platformVersion] UserVerifyNewDeviceResponse platformVersion
         * @property {proto.Device|null} [device] UserVerifyNewDeviceResponse device
         * @property {string|null} [deviceName] UserVerifyNewDeviceResponse deviceName
         * @property {boolean|null} [twoStepVerification] UserVerifyNewDeviceResponse twoStepVerification
         */

    /**
         * Constructs a new UserVerifyNewDeviceResponse.
         * @memberof proto
         * @classdesc Represents a UserVerifyNewDeviceResponse.
         * @implements IUserVerifyNewDeviceResponse
         * @constructor
         * @param {proto.IUserVerifyNewDeviceResponse=} [properties] Properties to set
         */
    function UserVerifyNewDeviceResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * UserVerifyNewDeviceResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.response = null;

    /**
         * UserVerifyNewDeviceResponse appName.
         * @member {string} appName
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.appName = '';

    /**
         * UserVerifyNewDeviceResponse appId.
         * @member {number} appId
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.appId = 0;

    /**
         * UserVerifyNewDeviceResponse appBuildVersion.
         * @member {number} appBuildVersion
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.appBuildVersion = 0;

    /**
         * UserVerifyNewDeviceResponse appVersion.
         * @member {string} appVersion
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.appVersion = '';

    /**
         * UserVerifyNewDeviceResponse platform.
         * @member {proto.Platform} platform
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.platform = 0;

    /**
         * UserVerifyNewDeviceResponse platformVersion.
         * @member {string} platformVersion
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.platformVersion = '';

    /**
         * UserVerifyNewDeviceResponse device.
         * @member {proto.Device} device
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.device = 0;

    /**
         * UserVerifyNewDeviceResponse deviceName.
         * @member {string} deviceName
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.deviceName = '';

    /**
         * UserVerifyNewDeviceResponse twoStepVerification.
         * @member {boolean} twoStepVerification
         * @memberof proto.UserVerifyNewDeviceResponse
         * @instance
         */
    UserVerifyNewDeviceResponse.prototype.twoStepVerification = false;

    /**
         * Creates a new UserVerifyNewDeviceResponse instance using the specified properties.
         * @function create
         * @memberof proto.UserVerifyNewDeviceResponse
         * @static
         * @param {proto.IUserVerifyNewDeviceResponse=} [properties] Properties to set
         * @returns {proto.UserVerifyNewDeviceResponse} UserVerifyNewDeviceResponse instance
         */
    UserVerifyNewDeviceResponse.create = function create(properties) {
      return new UserVerifyNewDeviceResponse(properties);
    };

    /**
         * Encodes the specified UserVerifyNewDeviceResponse message. Does not implicitly {@link proto.UserVerifyNewDeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.UserVerifyNewDeviceResponse
         * @static
         * @param {proto.UserVerifyNewDeviceResponse} message UserVerifyNewDeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    UserVerifyNewDeviceResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.appName != null && message.hasOwnProperty('appName')) {writer.uint32(/* id 2, wireType 2 =*/18).string(message.appName);}
      if (message.appId != null && message.hasOwnProperty('appId')) {writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.appId);}
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.appBuildVersion);}
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {writer.uint32(/* id 5, wireType 2 =*/42).string(message.appVersion);}
      if (message.platform != null && message.hasOwnProperty('platform')) {writer.uint32(/* id 6, wireType 0 =*/48).int32(message.platform);}
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {writer.uint32(/* id 7, wireType 2 =*/58).string(message.platformVersion);}
      if (message.device != null && message.hasOwnProperty('device')) {writer.uint32(/* id 8, wireType 0 =*/64).int32(message.device);}
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceName);}
      if (message.twoStepVerification != null && message.hasOwnProperty('twoStepVerification')) {writer.uint32(/* id 10, wireType 0 =*/80).bool(message.twoStepVerification);}
      return writer;
    };

    /**
         * Decodes a UserVerifyNewDeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UserVerifyNewDeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UserVerifyNewDeviceResponse} UserVerifyNewDeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    UserVerifyNewDeviceResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UserVerifyNewDeviceResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.appName = reader.string();
            break;
          case 3:
            message.appId = reader.uint32();
            break;
          case 4:
            message.appBuildVersion = reader.uint32();
            break;
          case 5:
            message.appVersion = reader.string();
            break;
          case 6:
            message.platform = reader.int32();
            break;
          case 7:
            message.platformVersion = reader.string();
            break;
          case 8:
            message.device = reader.int32();
            break;
          case 9:
            message.deviceName = reader.string();
            break;
          case 10:
            message.twoStepVerification = reader.bool();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a UserVerifyNewDeviceResponse message.
         * @function verify
         * @memberof proto.UserVerifyNewDeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    UserVerifyNewDeviceResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.appName != null && message.hasOwnProperty('appName')) {
        if (!$util.isString(message.appName)) {return 'appName: string expected';}
      }
      if (message.appId != null && message.hasOwnProperty('appId')) {
        if (!$util.isInteger(message.appId)) {return 'appId: integer expected';}
      }
      if (message.appBuildVersion != null && message.hasOwnProperty('appBuildVersion')) {
        if (!$util.isInteger(message.appBuildVersion)) {return 'appBuildVersion: integer expected';}
      }
      if (message.appVersion != null && message.hasOwnProperty('appVersion')) {
        if (!$util.isString(message.appVersion)) {return 'appVersion: string expected';}
      }
      if (message.platform != null && message.hasOwnProperty('platform')) {
        switch (message.platform) {
          default:
            return 'platform: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      }
      if (message.platformVersion != null && message.hasOwnProperty('platformVersion')) {
        if (!$util.isString(message.platformVersion)) {return 'platformVersion: string expected';}
      }
      if (message.device != null && message.hasOwnProperty('device')) {
        switch (message.device) {
          default:
            return 'device: enum value expected';
          case 0:
          case 1:
          case 2:
          case 3:
            break;
        }
      }
      if (message.deviceName != null && message.hasOwnProperty('deviceName')) {
        if (!$util.isString(message.deviceName)) {return 'deviceName: string expected';}
      }
      if (message.twoStepVerification != null && message.hasOwnProperty('twoStepVerification')) {
        if (typeof message.twoStepVerification !== 'boolean') {return 'twoStepVerification: boolean expected';}
      }
      return null;
    };

    return UserVerifyNewDeviceResponse;
  })();

  proto.WalletGetAccessToken = (function() {

    /**
         * Properties of a WalletGetAccessToken.
         * @memberof proto
         * @interface IWalletGetAccessToken
         * @property {proto.Request|null} [request] WalletGetAccessToken request
         */

    /**
         * Constructs a new WalletGetAccessToken.
         * @memberof proto
         * @classdesc Represents a WalletGetAccessToken.
         * @implements IWalletGetAccessToken
         * @constructor
         * @param {proto.IWalletGetAccessToken=} [properties] Properties to set
         */
    function WalletGetAccessToken(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * WalletGetAccessToken request.
         * @member {proto.Request|null|undefined} request
         * @memberof proto.WalletGetAccessToken
         * @instance
         */
    WalletGetAccessToken.prototype.request = null;

    /**
         * Creates a new WalletGetAccessToken instance using the specified properties.
         * @function create
         * @memberof proto.WalletGetAccessToken
         * @static
         * @param {proto.IWalletGetAccessToken=} [properties] Properties to set
         * @returns {proto.WalletGetAccessToken} WalletGetAccessToken instance
         */
    WalletGetAccessToken.create = function create(properties) {
      return new WalletGetAccessToken(properties);
    };

    /**
         * Encodes the specified WalletGetAccessToken message. Does not implicitly {@link proto.WalletGetAccessToken.verify|verify} messages.
         * @function encode
         * @memberof proto.WalletGetAccessToken
         * @static
         * @param {proto.WalletGetAccessToken} message WalletGetAccessToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    WalletGetAccessToken.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.request != null && message.hasOwnProperty('request')) {$root.proto.Request.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      return writer;
    };

    /**
         * Decodes a WalletGetAccessToken message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WalletGetAccessToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WalletGetAccessToken} WalletGetAccessToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    WalletGetAccessToken.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WalletGetAccessToken();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.request = $root.proto.Request.decode(reader, reader.uint32());
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a WalletGetAccessToken message.
         * @function verify
         * @memberof proto.WalletGetAccessToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    WalletGetAccessToken.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.request != null && message.hasOwnProperty('request')) {
        let error = $root.proto.Request.verify(message.request);
        if (error) {return 'request.' + error;}
      }
      return null;
    };

    return WalletGetAccessToken;
  })();

  proto.WalletGetAccessTokenResponse = (function() {

    /**
         * Properties of a WalletGetAccessTokenResponse.
         * @memberof proto
         * @interface IWalletGetAccessTokenResponse
         * @property {proto.Response|null} [response] WalletGetAccessTokenResponse response
         * @property {proto.WalletGetAccessTokenResponse.TokenType|null} [tokenType] WalletGetAccessTokenResponse tokenType
         * @property {string|null} [accessToken] WalletGetAccessTokenResponse accessToken
         * @property {number|null} [expiresIn] WalletGetAccessTokenResponse expiresIn
         */

    /**
         * Constructs a new WalletGetAccessTokenResponse.
         * @memberof proto
         * @classdesc Represents a WalletGetAccessTokenResponse.
         * @implements IWalletGetAccessTokenResponse
         * @constructor
         * @param {proto.IWalletGetAccessTokenResponse=} [properties] Properties to set
         */
    function WalletGetAccessTokenResponse(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
          if (properties[keys[i]] != null) {this[keys[i]] = properties[keys[i]];}
        }
      }
    }

    /**
         * WalletGetAccessTokenResponse response.
         * @member {proto.Response|null|undefined} response
         * @memberof proto.WalletGetAccessTokenResponse
         * @instance
         */
    WalletGetAccessTokenResponse.prototype.response = null;

    /**
         * WalletGetAccessTokenResponse tokenType.
         * @member {proto.WalletGetAccessTokenResponse.TokenType} tokenType
         * @memberof proto.WalletGetAccessTokenResponse
         * @instance
         */
    WalletGetAccessTokenResponse.prototype.tokenType = 0;

    /**
         * WalletGetAccessTokenResponse accessToken.
         * @member {string} accessToken
         * @memberof proto.WalletGetAccessTokenResponse
         * @instance
         */
    WalletGetAccessTokenResponse.prototype.accessToken = '';

    /**
         * WalletGetAccessTokenResponse expiresIn.
         * @member {number} expiresIn
         * @memberof proto.WalletGetAccessTokenResponse
         * @instance
         */
    WalletGetAccessTokenResponse.prototype.expiresIn = 0;

    /**
         * Creates a new WalletGetAccessTokenResponse instance using the specified properties.
         * @function create
         * @memberof proto.WalletGetAccessTokenResponse
         * @static
         * @param {proto.IWalletGetAccessTokenResponse=} [properties] Properties to set
         * @returns {proto.WalletGetAccessTokenResponse} WalletGetAccessTokenResponse instance
         */
    WalletGetAccessTokenResponse.create = function create(properties) {
      return new WalletGetAccessTokenResponse(properties);
    };

    /**
         * Encodes the specified WalletGetAccessTokenResponse message. Does not implicitly {@link proto.WalletGetAccessTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.WalletGetAccessTokenResponse
         * @static
         * @param {proto.WalletGetAccessTokenResponse} message WalletGetAccessTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
    WalletGetAccessTokenResponse.encode = function encode(message, writer) {
      if (!writer) {writer = $Writer.create();}
      if (message.response != null && message.hasOwnProperty('response')) {$root.proto.Response.encode(message.response, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();}
      if (message.tokenType != null && message.hasOwnProperty('tokenType')) {writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tokenType);}
      if (message.accessToken != null && message.hasOwnProperty('accessToken')) {writer.uint32(/* id 3, wireType 2 =*/26).string(message.accessToken);}
      if (message.expiresIn != null && message.hasOwnProperty('expiresIn')) {writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expiresIn);}
      return writer;
    };

    /**
         * Decodes a WalletGetAccessTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WalletGetAccessTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WalletGetAccessTokenResponse} WalletGetAccessTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
    WalletGetAccessTokenResponse.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader)) {reader = $Reader.create(reader);}
      let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WalletGetAccessTokenResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.response = $root.proto.Response.decode(reader, reader.uint32());
            break;
          case 2:
            message.tokenType = reader.int32();
            break;
          case 3:
            message.accessToken = reader.string();
            break;
          case 4:
            message.expiresIn = reader.uint32();
            break;
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
         * Verifies a WalletGetAccessTokenResponse message.
         * @function verify
         * @memberof proto.WalletGetAccessTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
    WalletGetAccessTokenResponse.verify = function verify(message) {
      if (typeof message !== 'object' || message === null) {return 'object expected';}
      if (message.response != null && message.hasOwnProperty('response')) {
        let error = $root.proto.Response.verify(message.response);
        if (error) {return 'response.' + error;}
      }
      if (message.tokenType != null && message.hasOwnProperty('tokenType')) {
        switch (message.tokenType) {
          default:
            return 'tokenType: enum value expected';
          case 0:
            break;
        }
      }
      if (message.accessToken != null && message.hasOwnProperty('accessToken')) {
        if (!$util.isString(message.accessToken)) {return 'accessToken: string expected';}
      }
      if (message.expiresIn != null && message.hasOwnProperty('expiresIn')) {
        if (!$util.isInteger(message.expiresIn)) {return 'expiresIn: integer expected';}
      }
      return null;
    };

    /**
         * TokenType enum.
         * @name proto.WalletGetAccessTokenResponse.TokenType
         * @enum {string}
         * @property {number} BEARER=0 BEARER value
         */
    WalletGetAccessTokenResponse.TokenType = (function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'BEARER'] = 0;
      return values;
    })();

    return WalletGetAccessTokenResponse;
  })();

  return proto;
})();

export { $root as default };
